<?xml version="1.0" encoding="UTF-8"?>
<xs:schema 
  xmlns:xs="http://www.w3.org/2001/XMLSchema"  
  xmlns:soae="http://www.intel.com/soae/wsdl/wsdl11-2007a/" 
  xmlns:wssec="http://www.intel.com/soae/localService/wssecDefinition-2007a/" 
  targetNamespace="http://www.intel.com/soae/localService/wssecDefinition-2007a/">
  <!-- ======================================================================================================= -->
  <!--  Web Service Security Definition (WSSEC) Schema                                                         -->
  <!-- ======================================================================================================= -->
  <xs:element name="webServiceSecurityDefinition" type="wssec:WebServiceSecurityDefinition"/>
  <xs:complexType name="WebServiceSecurityDefinition">
    <xs:annotation>
      <xs:documentation>
        Defines application developer level Web Service Security Information.
        Actual security token, e.g., private key, trusted CA group, etc., and associate critical Cryptographic Security Parameters (CSPs), 
        e.g., verification depth, CRL checking, etc., are defined in associated security config file.
      </xs:documentation>
    </xs:annotation>
    <xs:sequence>
      <xs:choice>
        <xs:sequence>
          <!-- constraint: these elements must be defined if usage = verify -->
          <xs:element name="signatureAcceptMethods" type="wssec:SignatureAcceptMethods">
            <xs:annotation>
              <xs:documentation>What signature methods will be acceptable to receiving application</xs:documentation>
            </xs:annotation>
          </xs:element>
          <xs:element name="digestAcceptMethods" type="wssec:DigestAcceptMethods">
            <xs:annotation>
              <xs:documentation>What digest methods will be acceptable to receiving application</xs:documentation>
            </xs:annotation>
          </xs:element>
          <xs:element name="canonicalAcceptMethods" type="wssec:CanonicalAcceptMethods">
            <xs:annotation>
              <xs:documentation>What canonicalization methods will be acceptable to receiving application</xs:documentation>
            </xs:annotation>
          </xs:element>
          <xs:element name="processingInstructions" type="wssec:ProcessingInstructions" minOccurs="0">
            <xs:annotation>
              <xs:documentation>Special processing instructions for signature verify operation</xs:documentation>
            </xs:annotation>
          </xs:element>
          <xs:element name="targetElements" type="wssec:TargetElements" minOccurs="0">
            <xs:annotation>
              <xs:documentation>
                Identify what information in the message header or body must have been signed by the sender/originator. 
                This optional element allows receiver to verify that the send/originator signed what the receiver expected.
              </xs:documentation>
            </xs:annotation>
          </xs:element>
          <xs:element name="targetAttachments" type="wssec:TargetAttachments" minOccurs="0">
            <xs:annotation>
              <xs:documentation>Identify what attachments must be covered by the signature</xs:documentation>
              <xs:documentation>
                Identify what message atachments must have been signed by the sender/originator. 
                This optional element allows receiver to verify that the send/originator signed what the receiver expected.
              </xs:documentation>
            </xs:annotation>
          </xs:element>
          <xs:element name="targetHeader" type="wssec:HeaderLocation" minOccurs="0">
            <xs:annotation>
              <xs:documentation>
                Identify where the signature header is located.
                When this element is not present, we will default to expecting the signature header in wsse:Security
                  /soap:Envelope/soap:Header/wsse:Security/dsig:Signature
              </xs:documentation>
            </xs:annotation>
          </xs:element>
          <xs:element name="incomingKeyinfoSaveTarget" type="xs:boolean" default="false" minOccurs="0">
            <xs:annotation>
              <xs:documentation>
                If present then it identifies the name of a message lifetime data cache entity that will be populated by 
                SOAE WSSEC code with the the identifying KeyInfo, e.g., username or X.509 certificate, specified in the 
                signature from the incoming request being processed.
                This functionality is not implemented in R2.0.KeyInfoType
              </xs:documentation>
              <xs:appinfo>data will be saved in message lifetime data cache variable: msg:internal:verify-resolved-certificate-policy_name</xs:appinfo>
            </xs:annotation>
          </xs:element>
          <xs:element name="keyInfoAcceptType" type="wssec:KeyInfo" minOccurs="0">
            <xs:annotation>
              <xs:documentation>
                Identifies what form on KeyInfo must be present in the incoming signature header.
                This is only required when the token resolution mechanism is LDAP, SQL, xpathFromWorkflow because the
                lookup mechanism is expecting that specific type of input.
                It is not necessary when keystore is specified.
              </xs:documentation>
            </xs:annotation>
            <!-- constraint: token type = username and operation is sign or verify then keyinfo can be passwordText, passwordDigest or keyDerivation -->
            <!-- constraint: token type = username and operation is encrypt or decrypt then keyinfo can be keyDerivation -->
            <!-- constraint: token type = symmetric then keyinfo can be SAML Assertion Reference, KeyName or KeyIdentifier -->
            <!-- constraint: token type = x509 then keyinfo can be certificate, subjectName, SKI, issuerSerialNumber, ThumbprintSha1, SAML Assertion Reference,
                                                                   DerivedKeyTokenWithX509EncryptedKey or DerivedKeyTokenWithEncryptedKeySha1
            -->
          </xs:element>
          <xs:element name="holderOfKeyKeyInfoAcceptType" type="wssec:SamlAssertionKeyInfo" minOccurs="0">
            <xs:annotation>
              <xs:documentation>
                This identifies the type of KeyInfo type that we expect to find in SAML assertion holder-of-key
                KeyInfo element.
              </xs:documentation>
            </xs:annotation>
            <!-- constraint: 
                   1) ONLY PRESENT if keyInfoAcceptType is SamlAssertionReference
                   2) if (tokenType == x509) then associated X.509 Certifcate security token is RESTRICTED according to 
                      the following:
                      Holder-of-key type | Allowable Combinations of X.509 Certificate Security Token Options
                      ________________________________________________________________________________________
                         SubjectName     | use = dynamic; dynamicMechanism = data-cache, keystore, ldap
                                         | use = static
                      ________________________________________________________________________________________
                            SKI          | use = dynamic; dynamicMechanism = data-cache, keystore, ldap 
                                         | use = static
                      ________________________________________________________________________________________
                        ThumbprintSha1   | use = dynamic; dynamicMechanism = data-cache, keystore, ldap
                                         | use = static
                      ________________________________________________________________________________________
                         Certificate     | use = incoming-message
                                         | use = static
                      ________________________________________________________________________________________
                           KeyName       | use = dynamic; dynamicMechanism = data-cache, keystore, ldap
                                         | use = static
                      ________________________________________________________________________________________
                   3) if (tokenType == x509) then holderOfKeyKeyInfoAcceptType can be set to X509Certifcate, X509SubjectName,
                                                  X509SKI, X509ThumbprintSha1, RSAKeyValue, DSAKeyValue, KeyName or 
                                                  X509IssuerSerialNumber.
                   4) if (tokenType == symmetric) then holderOfKeyKeyInfoAcceptType can be set to BinarySecret, KeyName or 
                                                       KeyValue.
            -->
          </xs:element>
          <xs:element name="expectMimeAttachmentsToBeProcessed" type="xs:boolean" default="false" minOccurs="0">
            <xs:annotation>
              <xs:documentation>
                Temporary kludge that will be removed when we can merge the XML and MIME versions of the extension function into a single version.
                This is here so that SD action builder knows what form of the extension function are to be generated. This was never an issue in the past
                because developer had to explicit code in the correct extension function in their workflow, i.e., including setting imakey and omakey when
                MIME attachments were being processed.
              </xs:documentation>
            </xs:annotation>
          </xs:element>
          <xs:element name="minimumAcceptableHmacOutputLength" type="wssec:HmacOutputLength" minOccurs="0">
            <xs:annotation>
              <xs:documentation>
                Protect against HMAC truncation attacks where attacker can add/modify HMAC-based signature to have a zero or small
                size. The attacker can then make quesses at the resulting limited number of potential signature values.
                This allows the consumer to ensure that the number of potential values remain large, i.e., secure.
              </xs:documentation>
            </xs:annotation>
          </xs:element>
          <xs:element name="keyEncryptionAcceptMethods" type="wssec:KeyEncryptionAcceptMethods" minOccurs="0">
            <xs:annotation>
              <xs:documentation>
                What encryption methods will be acceptable to receiving application performing a decryption operation over the symmetric key used by the bulk encryption
              </xs:documentation>
            </xs:annotation>
            <!-- constraint: MUST be PRESENT if ((tokenType == x509) AND (keyInfo == DerivedKeyTokenWithX509EncryptedKey)) -->
            <!-- constraint: MUST be ABSENT if NOT((tokenType == x509) AND (keyInfo == DerivedKeyTokenWithX509EncryptedKey)) -->
          </xs:element>
          <xs:element name="requiredElements" type="wssec:TargetElements" minOccurs="0">
            <xs:annotation>
              <xs:documentation>
                Identify what information in the message header or body must be present for the verifier to consider it a valid message.
                WS-Security Policy RequiredElements and RequiredParts assertions are mapped to this entity.
                Note: requireElement semantics are more general then WS-Security Policy Required assertions by allowing lements in the
                SOAP body to be checked.
              </xs:documentation>
            </xs:annotation>
          </xs:element>
        </xs:sequence>
        <xs:sequence>
          <!-- constraint: these elements must be defined if usage = sign -->
          <xs:element name="signatureGenerationMethod">
            <xs:complexType>
              <xs:annotation>
                <xs:documentation>What signature methods will we use when generating a signature</xs:documentation>
              </xs:annotation>
              <xs:attribute name="method" type="wssec:SignatureGenerationMethod" use="required"/>
              <xs:attribute name="hmacOutputLength" type="wssec:HmacOutputLength" use="optional">
                <xs:annotation>
                  <xs:appinfo>
                    In Service Designer policy editor, this attribute should have a separate option to indicate if it is
                    present. By default, it should be true.
                  </xs:appinfo>
                  <xs:documentation>
                    Including it can improve security against MIM attacks, but some implementation like MS ADFS will not 
                    process this option correctly.
                  </xs:documentation>
                </xs:annotation>
                <!-- constraint: ONLY ALLOWED if (method == HmacWithXxx) AND (tokenType == (username OR symmetric))) -->
                <!-- When hmacOutputLength is enabled, it should default to the full size of the associated digest method -->
              </xs:attribute>
            </xs:complexType>
          </xs:element>
          <xs:element name="digestGenerationMethod">
            <xs:annotation>
              <xs:documentation>What digest methods will we use when generating a signature</xs:documentation>
            </xs:annotation>
            <xs:complexType>
              <xs:attribute name="method" type="wssec:DigestGenerationMethod" use="required"/>
            </xs:complexType>
          </xs:element>
          <xs:element name="canonicalGenerationMethod">
            <xs:annotation>
              <xs:documentation>What canonicalization methods will we use when generating a signature</xs:documentation>
            </xs:annotation>
            <xs:complexType>
              <xs:attribute name="method" type="wssec:CanonicalGenerationMethod" use="required"/>
            </xs:complexType>
          </xs:element>
          <xs:element name="keyInfo" type="wssec:KeyInfoType"/>
          <xs:element name="holderOfKeyKeyInfoExpectedType" type="wssec:SamlAssertionKeyInfo" minOccurs="0">
            <xs:annotation>
              <xs:documentation>
                This identifies the type of KeyInfo type that we expect to find in SAML assertion holder-of-key
                KeyInfo element.
              </xs:documentation>
            </xs:annotation>
            <!-- constraint: 
                   1) ONLY PRESENT if keyInfo Format attribute is SamlAssertionReference
            -->
          </xs:element>
          <xs:element name="existingBstLocation" type="wssec:HeaderLocation" minOccurs="0">
            <xs:annotation>
              <xs:documentation>Identifies an existing binary security token (BST) that sign operation should reference</xs:documentation>
            </xs:annotation>
            <!-- constraint: ONLY PRESENT if (keyinfo format == useExistingBST) -->
            <!-- constraint: operational code should check that identified BST is on the correct type and that it matches the actual 
                             key material being supplied.
            -->
          </xs:element>
          <xs:element name="derivedKeyTokenCreationInfo" type="wssec:DerivedKeyTokenCreationInfo" minOccurs="0">
            <!-- constraint: ONLY PRESENT if (keyInfo format == DerivedKeyTokenWithX509EncryptedKey) -->
          </xs:element>
          <xs:element name="encryptedKeySha1CreationInfo" type="wssec:EncryptedKeySha1CreationInfo" minOccurs="0">
            <xs:annotation>
              <xs:documentation>
                Determines which WS-SecureConversation DerivedKeyToken and associated secret should be use.
                If this element is not present then the first DerivedKeyToken associated with an incoming signature will be utilized.
              </xs:documentation>
            </xs:annotation>
            <!-- constraint: ONLY PRESENT if (keyInfo format == DerivedKeyTokenWithEncryptedKeySha1) -->
          </xs:element>
          <xs:element name="processingInstructions" type="wssec:ProcessingInstructions" minOccurs="0">
            <xs:annotation>
              <xs:documentation>Special processing instructions for signature generation operation</xs:documentation>
            </xs:annotation>
          </xs:element>
          <!-- constraint: For a sign operation: the "TargetElement" and "TargetAttachments" elements both can NOT be absent or empty -->
          <xs:element name="targetElements" type="wssec:TargetElements" minOccurs="0">
            <xs:annotation>
              <xs:documentation>Identify what information is to be signed</xs:documentation>
            </xs:annotation>
          </xs:element>
          <xs:element name="targetAttachments" type="wssec:TargetAttachments" minOccurs="0">
            <xs:annotation>
              <xs:documentation>Identify what information is to be signed</xs:documentation>
            </xs:annotation>
          </xs:element>
          <xs:element name="requiredElements" type="wssec:TargetElements" minOccurs="0">
            <xs:annotation>
              <xs:documentation>
                Identify what information in the message header or body must be present for the signer to consider it a valid message.
                WS-Security Policy RequiredElements and RequiredParts assertions are mapped to this entity.
                Note: requireElement semantics are more general then WS-Security Policy Required assertions by allowing lements in the
                SOAP body to be checked.
              </xs:documentation>
            </xs:annotation>
          </xs:element>
        </xs:sequence>
        <xs:sequence>
          <!-- constraint: these elements must be defined if usage = decrypt -->
          <xs:element name="dataEncryptionAcceptMethods" type="wssec:DataEncryptionAcceptMethods">
            <xs:annotation>
              <xs:documentation>
                What encryption methods will be acceptable to receiving application performing a decryption operation over the bulk data
              </xs:documentation>
            </xs:annotation>
          </xs:element>
          <xs:element name="keyEncryptionAcceptMethods" type="wssec:KeyEncryptionAcceptMethods" minOccurs="0">
            <xs:annotation>
              <xs:documentation>
                What encryption methods will be acceptable to receiving application performing a decryption operation over the symmetric key used by the bulk encryption
              </xs:documentation>
            </xs:annotation>
            <!-- constraint: MUST be present when tokenType is x509 or symmetric -->
            <!-- constraint: MUST be absent when tokenType is username because that implies at key derivation method being used to generate the symmetric being used -->
          </xs:element>
          <xs:element name="processingInstructions" type="wssec:ProcessingInstructions" minOccurs="0">
            <xs:annotation>
              <xs:documentation>Special processing instructions for decryption operation</xs:documentation>
            </xs:annotation>
          </xs:element>
          <xs:element name="targetElements" type="wssec:TargetElements" minOccurs="0">
            <xs:annotation>
              <xs:documentation>
                Identify what information in the message header and body must have been encrypted by the sender/originator. 
                The actual elements that were encrypted will only be know after they have been decrypted.
                This optional element allows receiver to verify that the send/originator encrypted what the receiver expected.
              </xs:documentation>
            </xs:annotation>
          </xs:element>
          <xs:element name="targetAttachments" type="wssec:TargetAttachments" minOccurs="0">
            <xs:annotation>
              <xs:documentation>
                Identify what message attachments must have been encrypted by the sender/originator. 
                The actual attachments that were encrypted will only be know after they have been decrypted.
                This optional element allows receiver to verify that the send/originator encrypted what the receiver expected.
              </xs:documentation>
            </xs:annotation>
          </xs:element>
          <xs:element name="targetHeader" type="wssec:HeaderLocation" minOccurs="0">
            <xs:annotation>
              <xs:documentation>
                Identify where the encryption header is located.
                When this element is not present, we will default to expecting the encryption header in wsse:Security
                  /soap:Envelope/soap:Header/wsse:Security/xenc:EncryptedKey
              </xs:documentation>
            </xs:annotation>
          </xs:element>
          <xs:element name="incomingKeyinfoSaveTarget" type="xs:boolean" default="false" minOccurs="0">
            <xs:annotation>
              <xs:documentation>
                If present then it identifies the name of a message lifetime data cache entity that will be populated by 
                SOAE WSSEC code with the identifying KeyInfo, e.g., username or X.509 certificate, specified in the encryption 
                from the incoming request being processed.
              </xs:documentation>
              <xs:appinfo>
                Data will be saved in message lifetime data cache variable: msg:internal:decrypt-resolved-certificate-policy_name
                We will not implement this functionality until an actual customer need arise!
              </xs:appinfo>
            </xs:annotation>
          </xs:element>
          <xs:element name="keyInfoAcceptType" type="wssec:KeyInfo" minOccurs="0">
            <xs:annotation>
              <xs:documentation>
                Identifies what form on KeyInfo must be present in the incoming encryption header.
                This is only required when the token resolution mechanism is LDAP, SQL, xpathFromWorkflow because the
                lookup mechanism is expecting that specific type of input.
                It is not necessary when keystore is specified.
              </xs:documentation>
            </xs:annotation>
            <!-- constraint: token type = username then keyInfoAcceptType can be keyDerivation -->
            <!-- constraint: token type = symmetric then keyInfoAcceptType can be KeyName or KeyIdentifier -->
            <!-- constraint: token type = x509 then keyInfoAcceptType can be certificate, subjectName, SKI, issuerSerialNumber, [sha1 | md5]-fingerprint,
                             generatedSki, and generatedSkishort. Note: when generatedSki and generatedSkiShort are specified then full certificate
                             must actually be received and the generate SKI long or short form generated for passing onto the application selected
                             resolution mechansims, e.g., LDAP, keystore, SQL, etc.
            -->
          </xs:element>
          <xs:element name="expectMimeAttachmentsToBeProcessed" type="xs:boolean" default="false" minOccurs="0">
            <xs:annotation>
              <xs:documentation>
                Temporary kludge that will be removed when we can merge the XML and MIME versions of the extension function into a single version.
                This is here so that SD action builder knows what form of the extension function are to be generated. This was never an issue in the past
                because developer had to explicit code in the correct extension function in their workflow, i.e., including setting imakey and omakey when
                MIME attachments were being processed.
              </xs:documentation>
            </xs:annotation>
          </xs:element>
          <xs:element name="requiredElements" type="wssec:TargetElements" minOccurs="0">
            <xs:annotation>
              <xs:documentation>
                Identify what information in the message header or body must be present for the decryptor of a message to consider it a valid message.
                WS-Security Policy RequiredElements and RequiredParts assertions are mapped to this entity.
                Note: requireElement semantics are more general then WS-Security Policy Required assertions by allowing lements in the
                SOAP body to be checked.
                
                This check will be performed after the associated decryption operation has completed.
              </xs:documentation>
            </xs:annotation>
          </xs:element>
        </xs:sequence>
        <xs:sequence>
          <!-- constraint: this element must be defined if usage = encrypt -->
          <xs:element name="dataEncryptionGenerationMethod">
            <xs:complexType>
              <xs:annotation>
                <xs:documentation>What encryption methods will we use when encrypting</xs:documentation>
              </xs:annotation>
              <xs:attribute name="method" type="wssec:DataEncryptionGenerationMethod" use="required"/>
              <xs:attribute name="arc4KeySize" type="wssec:Arc4KeySize" use="optional" default="128">
                <!-- constraint: This attribute should only be present if the "method" attribute is equal to "arc4" -->
                <!-- constraint: If token type == username and KeyInfo == key derivation then key length must be 160 bit or less -->
              </xs:attribute>
            </xs:complexType>
          </xs:element>
          <xs:element name="keyEncryptionGenerationMethod" type="wssec:KeyEncryptionGenerationMethodType" minOccurs="0"/>
          <xs:element name="keyInfo" type="wssec:KeyInfoType"/>
          <xs:element name="existingBstLocation" type="wssec:HeaderLocation" minOccurs="0">
            <xs:annotation>
              <xs:documentation>Identifies an existing binary security token (BST) that sign operation should reference</xs:documentation>
            </xs:annotation>
            <!-- constraint: ONLY PRESENT if (keyinfo format == useExistingBST) -->
            <!-- constraint: operational code should check that identified BST is on the correct type and that it matches the actual 
                             key material being supplied.
            -->
          </xs:element>
          <xs:element name="derivedKeyInfo" type="wssec:DerivedKeyTokenCreationInfo" minOccurs="0">
            <!-- constraint: ONLY PRESENT if (keyInfo format == DerivedKeyTokenWithX509EncryptedKey) -->
          </xs:element>
          <!-- constraint: For a encrypt operation: the "TargetElement" and "TargetAttachments" elements both can NOT be absent or empty -->
          <xs:element name="targetElements" type="wssec:TargetElements" minOccurs="0">
            <xs:annotation>
              <xs:documentation>Identify what information is to be encrypted</xs:documentation>
            </xs:annotation>
          </xs:element>
          <xs:element name="targetAttachments" type="wssec:TargetAttachments" minOccurs="0">
            <xs:annotation>
              <xs:documentation>Identify what information is to be encrypted</xs:documentation>
            </xs:annotation>
          </xs:element>
          <xs:element name="requiredElements" type="wssec:TargetElements" minOccurs="0">
            <xs:annotation>
              <xs:documentation>
                Identify what information in the message header or body must be present for the encryptor of a message to consider it a valid message.
                WS-Security Policy RequiredElements and RequiredParts assertions are mapped to this entity.
                Note: requireElement semantics are more general then WS-Security Policy Required assertions by allowing lements in the
                SOAP body to be checked.
                
                This check will be performed before the associated encryption operation is performed.
              </xs:documentation>
            </xs:annotation>
          </xs:element>
        </xs:sequence>
        <xs:element name="createUsernameToken" type="wssec:CreateUsernameToken">
          <!-- constraint: 1) ONLY ALLOWED if (token type == username) 
                           2) ONLY ALLOWED if (usage == (createSecurityToken OR ignore))
          -->
        </xs:element>
        <xs:element name="createSamlAssertion" type="wssec:CreateSamlAssertion">
          <!-- constraint: 1) ONLY ALLOWED if (token type == saml) 
                           2) ONLY ALLOWED if (usage == (createSecurityToken OR ignore))
          -->
        </xs:element>
        <xs:element name="createKerberosToken" type="wssec:CreateKerberosToken">
          <!-- constraint: 1) ONLY ALLOWED if (token type == kerberos) 
                           2) ONLY ALLOWED if (usage == (createSecurityToken OR ignore))
          -->
        </xs:element>
        <xs:element name="packageBinarySecurityToken" type="wssec:PackageBST">
          <!-- constraint: 1) ONLY ALLOWED if (token type == (X509 OR kerberos [OR LTPA]))
                           2) ONLY ALLOWED if (usage == (createSecurityToken OR ignore))
          -->
        </xs:element>
        <xs:element name="generateSignatureConfirmations" type="wssec:EmptyType">
          <xs:annotation>
            <xs:documentation>
              Generate a signature confirmation element based upon whatever signature confirmation status were saved.
            </xs:documentation>
          </xs:annotation>
        </xs:element>
        <xs:element name="verifySignatureConfirmations">
          <xs:annotation>
            <xs:documentation>
              Verify all expected signature confirmation elements.
            </xs:documentation>
          </xs:annotation>
          <xs:complexType>
            <xs:attribute name="stripSignatureConfirmations" type="xs:boolean" use="optional" default="true"/>
          </xs:complexType>
        </xs:element>
        <xs:element name="checkWsTimestamp">
          <xs:annotation>
            <xs:documentation>Use a WS-Security timestamp to check the freshness and uniqueness of a request.</xs:documentation>
          </xs:annotation>
          <xs:complexType>
            <xs:sequence>
              <xs:element name="wssecurityTimestampCheckObject" type="wssec:NameType">
                <xs:annotation>
                  <xs:documentation>Name of a WsSecurityTimestampCheck object with the associate security config package.</xs:documentation>
                </xs:annotation>
              </xs:element>
              <xs:element name="stripTimestamp" type="xs:boolean" default="false">
                <xs:annotation>
                  <xs:documentation>
                    Controls if we strip/remove the WS-Security Timestamp after the successful checking of the timestamp.
                  </xs:documentation>
                </xs:annotation>
              </xs:element>
            </xs:sequence>
          </xs:complexType>
          <!-- constraint: wssecVersion and soapVersion attributes usage be populated. usage should be populated with value of ignore. -->
        </xs:element>
        <xs:element name="generateWsTimestamp">
          <xs:annotation>
            <xs:documentation>
              Generate a WS-Security Timestamp if one does not currently exist within document SOAP WS-Security header.
            </xs:documentation>
          </xs:annotation>
          <!-- constraint: wssecVersion and soapVersion attributes can be populated. usage should be populated with value of ignore or createSecurityToken. -->
          <xs:complexType>
            <xs:sequence>
              <xs:element name="maximumExpirationTime" default="0">
                <xs:annotation>
                  <xs:documentation>
                    Maximum Expiration Time in seconds.
                    Inidicates how long that this WS-Security Timestamp will be exist before becoming expired.
                    
                    If zero is specified then no wse:Expires element will be generated within timestamp being generated.
                  </xs:documentation>
                  <xs:appinfo>
                    <units>seconds</units>
                  </xs:appinfo>
                </xs:annotation>
                <xs:simpleType>
                  <xs:restriction base="xs:unsignedInt">
                    <xs:maxInclusive value="86400"/>
                  </xs:restriction>
                </xs:simpleType>
              </xs:element>
            </xs:sequence>
          </xs:complexType>
        </xs:element>
        <xs:element name="jwsSign" type="wssec:JwsSign">
          <xs:annotation>
            <xs:documentation>JSON Web Signature (JWS) generation</xs:documentation>
          </xs:annotation>
        </xs:element>
        <xs:element name="jwsVerify" type="wssec:JwsVerify">
          <xs:annotation>
            <xs:documentation>JSON Web Signature (JWS) verify</xs:documentation>
          </xs:annotation>
        </xs:element>
        <xs:element name="jweEncrypt" type="wssec:JweEncrypt">
          <xs:annotation>
            <xs:documentation>JSON Web Encryption (JWE) encryption</xs:documentation>
          </xs:annotation>
        </xs:element>
        <xs:element name="jweDecrypt" type="wssec:JweDecrypt">
          <xs:annotation>
            <xs:documentation>JSON Web Encryption (JWE) decryption</xs:documentation>
          </xs:annotation>
        </xs:element>
      </xs:choice>
      <xs:element name="securityTokens" minOccurs="0">
        <xs:complexType>
          <xs:sequence>
            <xs:element name="token" maxOccurs="unbounded">
              <xs:complexType>
                <xs:attribute name="type" use="required">
                  <xs:simpleType>
                    <xs:restriction base="xs:NMTOKEN">
                      <xs:enumeration value="x509KeyPair">
                        <xs:annotation>
                          <xs:documentation>
                            Name of an asymmetricKeyPair element. Resolution based upon value of associated "use" attribute.
                            This asymmetricKeyPair element identifies either a RSA or DSA public/private key pair. The public key is usually package 
                            within an X.509 certificate. The private key and associated certificate can be package in the same file or in separate files.
                            Depending upon the type of PKI encoding being used, the full Certificate Authority path from the leaf certificate upto the root
                            Certification Authority can also be included within the actual file. When this occurs, the following caPAth element is not 
                            required to be specified.
                            
                            This element is used to populate the near-end private key, near-end certificate [and CA Path] for signature generation and decryption.
                            For signature generation and decryption, the near-end private key is used in the actual cryptographic operation. 
                            For signature generation, the near-end certificate and caPath may be package into the keyinfo of the actual message being send 
                            if keyInfo format=Certificate. If keyInfo format=[IssuerSerial | SubjectName | SKI] then the near-end certificate is used to supply
                            this information.
                            For signature generation, any CA Path certificates that are present in the specified x509KeyPair will not be utilized in this release.
                            Only explicitly defined caPath certificates will be supported.
                          </xs:documentation>
                        </xs:annotation>
                        <!-- constraint: MUST be PRESENT if ((usage == "decrypt") AND (tokenType == "x509")) -->
                        <!-- constraint: MUST be PRESENT if ((usage != "sign") AND (tokenType == "x509") AND 
                                                             (keyInfo != "DerivedKeyTokenWithX509EncryptedKey")
                                                            )
                        -->
                        <!-- constraint: NOT ALLOWED if ((usage != "sign") AND (tokenType == "x509") AND 
                                                         (keyInfo == "DerivedKeyTokenWithX509EncryptedKey")
                                                        )
                        -->
                        <!-- constraint: NOT ALLOWED if ((usage != ("sign" OR "decrypt" OR "encrypt")) AND (tokenType != "x509")) -->
                        <!-- constraint: MUST be PRESENT if ((usage == "verify") AND (tokenType == "x509") AND
                                                             (keyInfo == "DerivedKeyTokenWithX509EncryptedKey")
                                                            )
                        -->
                        <!-- constraint: NOT ALLOWED if ((usage == "verify") AND (tokenType == "x509") AND
                                                         (keyInfo != "DerivedKeyTokenWithX509EncryptedKey")
                                                        )
                        -->
                        <!-- constraint: NOT ALLOWED if ((usage == "verify") AND (tokenType != "x509")) -->
                        <!-- constraint: at most one token with this value may be present -->
                      </xs:enumeration>
                      <xs:enumeration value="x509CaPath">
                        <xs:annotation>
                          <xs:documentation>
                            Name of a caPath element. Resolution based upon value of associated "use" attribute.
                            This element identifies a list of untrusted Certificate Authorities.
                            It can be specified in two possible formats (See "Web Services Security X.509 Certificate Token Profile 1.1 OASIS Standard
                            Specification, 1 February 2006" for details.
                            1) one or more PEM format Certificate Authorities certificates concatenated in the same physical file. The order of certificates is 
                               such that the subject of the first certificate is the issuer of the second certificate, etc. Additionally, the certificate path 
                               excludes the end-entity certficate. This format is implied by a BinarySecurityToken with its attribute 
                               ValueType"#X509PKIPathv1".
                               See ITU-T Rec.X.509 (2000)/Cor.1 (10/2001 E) for details.
                            2) PKCS7 bag. This format is implied by a BinarySecurityToken with its attribute ValueType="#PKCS7".
                            
                            In signature generation, this caPath should be physically packaged within the actual message being sent.
                            
                            In signature verification, the caPath is utilized in checkTrust to supply missing immediate Certificate Authorities certificates
                            between the far-end certificate and a CA certificate within the trustedCaGroup of CA certificates. The source of the CA Path 
                            certifcates is identified via the associated "use" attribute.
                          </xs:documentation>
                        </xs:annotation>
                        <!-- constraint: ONLY PRESENT if ((usage == ([sign OR] verify) AND (tokenType == "x509") AND 
                                                          (keyInfo != (DerivedKeyTokenWithX509EncryptedKey OR DerivedKeyTokenWithEncryptedKeySha1))
                                                         ) 
                        -->
                        <!-- constraint: at most one token with this value may be present -->
                        <!-- constraint: when usage is "verify", this security token is only utilized when the verification depth set in the associated
                                         webServiceAuthenticationPolicy is 2 or greater. If depth is zero or 1, then no intermediate CA certificates are required.
                                         Potentially a warning message should generated by some entity that is validating the actual SOAE cluster before it is deployed.
                        -->
                      </xs:enumeration>
                      <xs:enumeration value="x509Certificate">
                        <xs:annotation>
                          <xs:documentation>
                            Name of a certificate element. Resolution based upon value of associated "use" attribute.
                            
                            For signature verification, this element is usually utilized with use="incoming-message" to indicate that the actual
                            far-end certificate is contained in the actual incoming message. However, use="static" would indicate that the certificate 
                            to be used should come from the  predefine, statically provisioned certificates in the associated security config file. 
                            Therefore, any certificate packaged in the incoming message by the sendre will not be utilized by the signature verification 
                            authentication processing code.
                            
                            For encryption, the public key is used in the actual cryptographic operation. Additionally, the far-end certificate are package
                            into the keyinfo of the actual message being send, or the far-end certificate is used to supply the issuer/serialNumber, SKI or 
                            to perform either and internal or external lookup to get key information for the actual message.
                            Since encryption is for a specific destination, either a local or external lookup is usually required to get the matching 
                            destination certificate to use. This implies when use is static that this element can only be utilized where a single known 
                            destination exist.
                            
                            In a future release, we may want to support this for decryption when use is incoming-message and x509KeyPair use is dynamic, 
                            i.e., incoming certificate used by application to determine the private key to utilized.
                          </xs:documentation>
                        </xs:annotation>
                        <!-- constraint: Must be present if usage == ["encrypt" | "verify"] and tokenType == "x509" -->
                        <!-- constraint: Must be absent if usage != ["encrypt" | "verify"], or tokenType != "x509" -->
                        <!-- constraint: MUST be PRESENT if ((tokenType == "x509") AND (usage == sign) AND 
                                                             (keyInfo format == DerivedKeyTokenWithX509EncryptedKey)
                                                            )
                        -->
                        <!-- constraint: at most one token with this value may be present -->
                      </xs:enumeration>
                      <xs:enumeration value="authenticationPolicy">
                        <xs:annotation>
                          <xs:documentation>
                            Name of a webServiceAuthenticationPolicy element in security config to utilize for this signature verification operation.
                            Note: a security adminstrator could disable the authentication of the signer by disabling far-end authentication by setting that
                            element in the specified webServiceAuthenticationPolicy to false.
                          </xs:documentation>
                        </xs:annotation>
                        <!-- constraint: MUST be PRESENT if ((usage == verify) AND (tokenType == "x509") AND 
                                                             (keyInfo != (DerivedKeyTokenWithX509EncryptedKey OR DerivedKeyTokenWithEncryptedKeySha1))
                                                            ) 
                        -->
                        <!-- constraint: MUST be PRESENT if ((usage == verify) AND (tokenType == username)) -->
                        <!-- constraint: associate "use" attribute must be static -->
                        <!-- constraint: MUST NOT be PRESENT if (usage != "verify") -->
                        <!-- constraint: MUST NOT be PRESENT if ((usage == verify) AND (tokenType == symmetric)) -->
                        <!-- constraint: at most one token with this value may be present  -->
                      </xs:enumeration>
                      <xs:enumeration value="username">
                        <xs:annotation>
                          <xs:documentation>
                            Username token related security parameters.
                            A username token implies that both the username and its associated password will be available to the security operation using 
                            the specified resolution mechanism, e.g., static using associated security config, dynamic from keystore, etc.
                          </xs:documentation>
                        </xs:annotation>
                        <!-- constraint: must be present if tokenType == "username" -->
                        <!-- constraint: at most one token with this value may be present  -->
                        <!-- constraint: must be absent if tokenType != "username" -->
                      </xs:enumeration>
                      <xs:enumeration value="secret">
                        <xs:annotation>
                          <xs:documentation>Name of a sharedSecret element related security parameters.</xs:documentation>
                        </xs:annotation>
                        <!-- constraint: MUST be PRESENT if NOT((tokenType == symmetric) AND 
                                                                (keyInfoAcceptType == SamlAssertionReference) AND
                                                                (holderOfKeyKeyInfoAcceptType == BinarySecret)
                                                            ) 
                        -->
                        <!-- constraint: MUST NOT be PRESENT if ((tokenType == symmetric) AND 
                                                                 (keyInfoAcceptType == SamlAssertionReference) AND
                                                                 (holderOfKeyKeyInfoAcceptType == BinarySecret)
                                                            ) 
                        -->
                        <!-- constraint: at most one token with this value may be present  -->
                        <!-- constraint: must be absent if tokenType != "symmetric" -->
                      </xs:enumeration>
                      <xs:enumeration value="IVencoding">
                        <xs:annotation>
                          <xs:documentation>
                            This option allows an application to use a proprietary encoding of the initialization vector, IV, associated with block 
                            bulk encryption, i.e., des3, aes128, aes192 or aes256.
                            Normally, the automatically generated IV will be package before the encrypted bulk data according to
                            the "XML Encryption Syntax and Processing W3C Recommendation 10 December 2002". Both the IV and encrypted 
                            data will be based64.
                            
                            When this optional security information is specified on an encryption operation, the WS-Security built-in code will:
                            1) automatically generate a random IV value,
                            2) used this random IV to seed the bulk encryption operation,
                            3) return the IV to the application.
                            When this optional security information is specified on a decryption operation, the WS-Security built-in code will:
                            1) use the user specified IV and not assume that it is packaged in front of the encrypted bulk data.
                          </xs:documentation>
                        </xs:annotation>
                        <!-- constraint: can only be present if operation type is either encryption or decryption, 
                                         and dataEncryptionGenerationMethod method is des3, aes128, aes192 or aes256.
                        -->
                        <!-- constraint: if type == "IVencoding" then use must be "dynamic" -->
                        <!-- constraint: if type == "IVencoding" then dynamicMechanism must be "data-cache" -->
                        <!-- constraint: if type == "IVencoding" then dataCacheLifetime must be "message" -->
                        <!-- constraint: if type == "IVencoding" then applicationDataCachePrefix, identifier, passwordIdentifier, sourceType must be 
                                         absent/not present 
                        -->
                      </xs:enumeration>
                    </xs:restriction>
                  </xs:simpleType>
                </xs:attribute>
                <xs:attribute name="use" type="wssec:ResolveFrom" use="required"/>
                <xs:attribute name="name" type="wssec:NameType" use="optional">
                  <!-- constraint: This attribute MUST be present when the "use" attribute is "static".
                                   This attribute MUST NOT be present when the "use" is "incoming-message" or "dynamic".
                                   When the "use" attribute is "static", then "name" identifies an element in a security config file.
                  -->
                </xs:attribute>
                <xs:attribute name="dynamicMechanism" use="optional">
                  <xs:annotation>
                    <xs:documentation>What type of dynamic token resolution mechanism is to be use</xs:documentation>
                  </xs:annotation>
                  <!-- constraint: must be present if use is dynamic, otherwise must be absent -->
                  <xs:simpleType>
                    <xs:restriction base="xs:string">
                      <xs:enumeration value="data-cache">
                        <xs:annotation>
                          <xs:documentation>
                              Key info being retrieved from application or message lifetime data cache variables.
                          </xs:documentation>
                        </xs:annotation>
                        <!--  constraint:
                              1) NOT ALLOWED if ((token type is X.509) AND (operation is sign | decrypt))
                                 Note: could support with some work.
                        -->
                      </xs:enumeration>
                      <xs:enumeration value="keystore">
                        <xs:annotation>
                          <xs:documentation>
                              Key info being retrieved from statically provisioned keystore..
                          </xs:documentation>
                        </xs:annotation>
                        <!--  constraint:
                              1) NOT ALLOWED if ((token type is X.509) AND (operation is sign | decrypt))
                        -->
                      </xs:enumeration>
                      <xs:enumeration value="ldap">
                        <xs:annotation>
                          <xs:documentation>
                            Key info being retrieved from LDAP invocation agent.
                          </xs:documentation>
                        </xs:annotation>
                        <!--  constraint:
                              1) NOT ALLOWED if ((token type is X.509) AND (operation is sign | decrypt))
                                 Note: beside the operational code changes, we would need to support LDAP using SSL and special application configuration.
                        -->
                        <!-- constraint: when this policy is bound to an action, Service Design must bound to the partnerLink -->
                      </xs:enumeration>
                      <xs:enumeration value="fromPrecedingVerifyOperation">
                        <xs:annotation>
                          <xs:documentation>
                            X.509 certificate is to come from a preceding WS-Securiy verify operation that is exporting its resolved certificate.
                          </xs:documentation>
                          <xs:appinfo>
                            Service Designer Action Builder must prompt application developer to identity the verify operation when this policy is bound to an action.
                          </xs:appinfo>
                        </xs:annotation>
                        <!-- constraint: ONLY ALLOWED if ((token type is X.509) AND (operation is encryption)) -->
                      </xs:enumeration>
                      <xs:enumeration value="securityObjectNameFromWorkflow">
                        <xs:annotation>
                          <xs:documentation>
                            Allows an application to specify the specific security object from their security config to utilize for this specific
                            WS-Security encryption operation.
                          </xs:documentation>
                          <xs:appinfo>
                            Service Designer Action Builder must prompt application developer to identity the workflow variable containing security object name 
                            when this policy is bound to an action.
                          </xs:appinfo>
                        </xs:annotation>
                        <!-- Deferred to a future release. Is not needed for BAE -->
                        <!-- constraint: 1) ONLY ALLOWED for encryption operations
                                         2) security object name MUST match the token type, e.g., 
                                            a) X509 token type => AsymmetricKeyPair, 
                                            b) symmetric token type => SharedSecret typeOfSharedSecret == symmetric-key
                        -->
                      </xs:enumeration>
                    </xs:restriction>
                  </xs:simpleType>
                </xs:attribute>
                <xs:attribute name="dataCacheLifetime" use="optional">
                  <xs:annotation>
                    <xs:documentation>
                      Data Cache lifetime.
                      For signature verification and decryption operations, the data cache lifetime will usually be "application" because
                      the the username and password will be resolved from data cache entities that the application set-up during initializtion.
                      For signature genration and decryption operations, "application" lifetime is most likely when the data cache is being
                      statically initialized at start-up. However, if the application is looking-up the username/password via some custom service, 
                      etc., the use of "message" lifetime is more likely because this processing will be per request.
                      Therefore, not specifying any default but forcing application to explicitly specify what their intentions are.
                    </xs:documentation>
                  </xs:annotation>
                  <!-- constraint: must be present if dynamicMechanism is data-cache, otherwise must be absent -->
                  <!-- constraint: must be present if dynamicMechanism is keystore and usage is sign or encrypt, otherwise must be absent -->
                  <xs:simpleType>
                    <xs:restriction base="xs:string">
                      <xs:enumeration value="application">
                        <xs:annotation>
                          <xs:documentation>
                            Accessible by all worker threads.
                            This is useful  for utilizing one common set of populated username/password pairs, etc.
                          </xs:documentation>
                        </xs:annotation>
                      </xs:enumeration>
                      <xs:enumeration value="message">
                        <xs:annotation>
                          <xs:documentation>
                            Accessible only by code associated with this specific message.
                            Variable is automatically freed when message processing completes.
                            This is useful when passing into or from WS-Security built-in function a specific username/password pair, etc.
                          </xs:documentation>
                        </xs:annotation>
                      </xs:enumeration>
                    </xs:restriction>
                  </xs:simpleType>
                </xs:attribute>
                <xs:attribute name="applicationDataCachePrefix" use="optional" default="AppUsernamesPasswords">
                  <xs:annotation>
                    <xs:documentation>
                      Used to restrict data cache variables to a subset of their namespace.
                      This is needed to ensure that an attacker can not sent in a bad username that resolves to another populated entry 
                      within the data cache.
                    </xs:documentation>
                    <xs:appinfo>Operational code should populate an explicit ":" between the data cache lifetime and extracted message KeyInfo username/keyname</xs:appinfo>
                  </xs:annotation>
                  <!-- constraint: only allowed if dynamicMechanism is data-cache -->
                  <xs:simpleType>
                    <xs:restriction base="xs:NMTOKEN">
                      <xs:minLength value="1"/>
                      <xs:maxLength value="256"/>
                    </xs:restriction>
                  </xs:simpleType>
                </xs:attribute>
                <xs:attribute name="identifier" use="optional">
                  <xs:annotation>
                    <xs:documentation>
                      Data Cache variable containing the source identity.
                    </xs:documentation>
                  </xs:annotation>
                  <!-- constraint: must be present is dynamicMechanism is data-cache or keystore, and usage is sign or encrypt; 
                                   otherwise must be absent 
                  -->
                  <xs:simpleType>
                    <xs:restriction base="xs:NMTOKEN">
                      <xs:minLength value="1"/>
                      <xs:maxLength value="256"/>
                    </xs:restriction>
                  </xs:simpleType>
                </xs:attribute>
                <xs:attribute name="passwordIdentifier" use="optional">
                  <xs:annotation>
                    <xs:documentation>Variable in data cache containing password to be utilized.</xs:documentation>
                  </xs:annotation>
                  <!-- constraint: must present if dynamicMechanism is data-cache, and usage is sign or encrypt; otherwise must be absent -->
                  <xs:simpleType>
                    <xs:restriction base="xs:NMTOKEN">
                      <xs:minLength value="1"/>
                      <xs:maxLength value="256"/>
                    </xs:restriction>
                  </xs:simpleType>
                </xs:attribute>
                <xs:attribute name="sourceType" type="wssec:KeystoreSourceType" use="optional" default="username">
                  <xs:annotation>
                    <xs:documentation>
                      When a keystore is being utilized, this parameter allows application to determine what kind of keystore 
                      attribute is being used to identify the username/password.
                    </xs:documentation>
                  </xs:annotation>
                  <!-- constraint: must be present if dynamicMechanism is keystore, and usage is sign or encrypt; otherwise must be absent -->
                </xs:attribute>
                <xs:attribute name="distinguishedNamePrefix" type="wssec:DistinguishedNameType" use="optional" default="uid=">
                  <xs:annotation>
                    <xs:documentation>
                      This string will be concaterated in front of the extracted identity, e.g., username, from the security token reference assocaited with the operation being processed.
                    </xs:documentation>
                  </xs:annotation>
                  <!-- constraint: must be present if dynamicMechanism is ldap; otherwise must be absent -->
                </xs:attribute>
                <xs:attribute name="distinguishedNamePostfix" type="wssec:DistinguishedNameType" use="optional">
                  <xs:annotation>
                    <xs:documentation>
                      This string will be concaterated behind of the extracted identity, e.g., username, from the security token reference assocaited with the operation being processed.
                    </xs:documentation>
                  </xs:annotation>
                  <!-- constraint: must be present if dynamicMechanism is ldap; otherwise must be absent -->
                </xs:attribute>
                <xs:attribute name="resultAttrName" type="wssec:DistinguishedNameType" use="optional" default="Password">
                  <xs:annotation>
                    <xs:documentation>
                      Identify the attr name whose value in the LDAP response that should contain desired response data
                    </xs:documentation>
                  </xs:annotation>
                  <!-- constraint: must be present if dynamicMechanism is ldap; otherwise must be absent -->
                </xs:attribute>
                <xs:attribute name="ldapServerUrl" type="xs:anyURI" use="optional">
                  <xs:annotation>
                    <xs:documentation>
                      Allows WS-Security Policy writer to bind LDAP IA to a specific backend server.
                      This is very useful when automatically using the same AAA policy in multiple places so that they are all bound to same LDAP server.
                    </xs:documentation>
                    <!-- This element will be mapped to two advanced fields: server host name and port in service designer.  Default port = 389 (636 for SSL/TLS future) -->
                  </xs:annotation>
                  <!-- constraint: may be present if dynamicMechanism is ldap; otherwise must be absent -->
                </xs:attribute>
                <xs:attribute name="ivIdentifier" use="optional">
                  <xs:annotation>
                    <xs:documentation>
                      Variable in message lifetime data cache associated with proprietary bulk Initialization Vector processing.
                      If the operation type is encrypt, then this is the message lifetime data-cache variable to which a base64 encoding of the 
                      initialization vector will be written to.
                      If the operation type is decrypt, then this is the message lifetime data-cache variable that WS-Security code will 
                      retrieve a base64 encoding of the initialization vector from.
                    </xs:documentation>
                  </xs:annotation>
                  <!-- constraint: must present if type is initializationVectorEncoding; otherwise must be absent -->
                  <xs:simpleType>
                    <xs:restriction base="xs:NMTOKEN">
                      <xs:minLength value="1"/>
                      <xs:maxLength value="256"/>
                    </xs:restriction>
                  </xs:simpleType>
                </xs:attribute>
              </xs:complexType>
            </xs:element>
          </xs:sequence>
        </xs:complexType>
      </xs:element>
    </xs:sequence>
    <xs:attribute name="name" type="wssec:LocalPathname" use="optional">
      <xs:annotation>
        <xs:documentation>Administrator define name of Web Service Security Definition</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="bindingType" type="wssec:BindingType" default="SOAP">
      <xs:annotation>
        <xs:documentation>Identifies what type of binding mechanism is supported by this Security Policy</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="wssecVersion" type="wssec:WssecVersion" default="2002-07">
      <xs:annotation>
        <xs:documentation>Web Service Security (WS-Security) version</xs:documentation>
      </xs:annotation>
      <!-- constraint: ONLY PRESENT if (bindingType == SOAP) -->
    </xs:attribute>
    <xs:attribute name="soapVersion" type="wssec:SoapVersion" use="optional" default="deferred">
      <xs:annotation>
        <xs:documentation>Web Service Simple Object Access Protocol (WS-SOAP) version</xs:documentation>
      </xs:annotation>
      <!-- constraint: ONLY PRESENT if (bindingType == SOAP) -->
    </xs:attribute>
    <xs:attribute name="samlVersion" type="wssec:SamlVersion" default="1.1">
      <xs:annotation>
        <xs:documentation>Security Assertion Markup Languague (SAML) version</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="samlTokenVersion" type="wssec:SamlTokenVersion" default="1.1">
      <xs:annotation>
        <xs:documentation>Security Assertion Markup Languague (SAML) Token version</xs:documentation>
      </xs:annotation>
      <!-- constraint: ONLY PRESENT if usage is (sign or verify) -->
    </xs:attribute>
    <xs:attribute name="SwAVersion" type="wssec:SwAVersion" default="1.1">
      <xs:annotation>
        <xs:documentation>Soap with Attachment (SwA) version</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="tokenType" type="wssec:TokenType" default="x509">
      <xs:annotation>
        <xs:documentation>What type of security tokens are being utilized</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="usage" type="wssec:Usage" use="required">
      <xs:annotation>
        <xs:documentation>What type of security tokens are being utilized</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="operationPrefix" use="optional" default="operation_tokenType_">
      <xs:annotation>
        <xs:documentation>
          This string will be used to prefix the ID string associated with this signature or encryption.
          All generated signatures/encryptions will have a wsu:Id attribute defined. 
          It will be the concateration of a prefix string and a UTF-8 version of a UUID.
          The default prefix will be a concateration of the operation: sign or encrypt, and 
          the token type being utilized, x509, username, or symmetric.
          The UUID, Universally Unique IDentifier, is a 128-bit random value.
          
          An application developer can control this prefix so that it is easier for a consuming
          process to more easier identify the specific signature operation that they want to 
          verify or encrypt. This is particularly useful when an incoming document contains multiple
          signatures, but only a subset will be verified or encrypted.
          It all simplify when an application wants to encrypt and then sign the encrypted data.
        </xs:documentation>
      </xs:annotation>
      <!-- constraint: only allowed if usage = sign or encrypt -->
      <xs:simpleType>
        <xs:restriction base="xs:NMTOKEN">
          <xs:minLength value="1"/>
          <xs:maxLength value="256"/>
        </xs:restriction>
      </xs:simpleType>
    </xs:attribute>
    <xs:attribute name="tokenPrefix" use="optional" default="str_">
      <xs:annotation>
        <xs:documentation>
          This string will be used to prefix the ID string associated with the security token 
          reference associated with this operation.
          All generated security token reference will have a wsu:Id attribute defined. 
          It will be the concateration of a prefix string and a UTF-8 version of a UUID.
          The default prefix will be a concateration of the token type being utilized:
            x509, username, or symmetric.
          The UUID, Universally Unique IDentifier, is a 128-bit random value.
          
          An application developer can control this prefix so that it is easier for a consuming
          process to more easier identify the specific security token reference that they want to 
          encrypt or sign.
        </xs:documentation>
      </xs:annotation>
      <!-- constraint: only allowed if usage = sign | encrypt -->
      <xs:simpleType>
        <xs:restriction base="xs:NMTOKEN">
          <xs:minLength value="1"/>
          <xs:maxLength value="256"/>
        </xs:restriction>
      </xs:simpleType>
    </xs:attribute>
    <xs:attribute name="actor" use="optional">
      <xs:annotation>
        <xs:documentation>
          SOAP actor global attribute can be used to indicate the recipient of a header element.
          
          It is used to address the question: How does an intermediary know which WS-Security header it owns? 
          A SOAP message may contain multiple WS-Security headers. Each header is identified by a unique actor. No two 
          WS-Security headers can use the same actor or omit the actor. This makes it easy for intermediaries to 
          identify which WS-Security headers contain the information they need. Of course, the intermediary does need to 
          know which actor URI it handles. Associating a URI with an actor and making sure that the intermediary knows what 
          to do is something that must be handled via programming. The actor attribute in any SOAP header is meant to say 
          "this header is meant for any endpoint acting in the capacity indicated by the actor URI." What gives that URI meaning? 
          The team that architects the Web service gives meaning to the URI. This means that an intermediary may act in varying
          capacities. As a result, that intermediary may consume zero, one, or more headers. Yes, it may even consume 
          multiple security headers. 
        </xs:documentation>
        <xs:appinfo>
          If not present that processing will defer to default WS-Security header within SOAP Header for associated operation
          and tokens.
        </xs:appinfo>
      </xs:annotation>
      <xs:simpleType>
        <xs:restriction base="xs:anyURI">
          <xs:minLength value="1"/>
        </xs:restriction>
      </xs:simpleType>
      <!-- constraint: ONLY ALLOWED if (bindingType == SOAP) -->
    </xs:attribute>
  </xs:complexType>
  <xs:simpleType name="NameType">
    <xs:annotation>
      <xs:documentation>Identifies an element in a security config file</xs:documentation>
    </xs:annotation>
    <xs:restriction base="xs:NMTOKEN">
      <xs:minLength value="1"/>
      <xs:maxLength value="64"/>
      <xs:pattern value="[-a-zA-Z0-9_:\.]*"/>
      <!-- dash A-Z a-z 0-9 underscore colon period -->
    </xs:restriction>
  </xs:simpleType>
  <xs:simpleType name="LocalPathname">
    <xs:annotation>
      <xs:documentation>
        Trying to allow any character in a normal Linux pathname that does not require special escape processing.
        Trying to restrict application to a partial local/absolute pathname, not an URI that could be external.
      </xs:documentation>
    </xs:annotation>
    <xs:restriction base="xs:anyURI">
      <xs:minLength value="1"/>
      <xs:pattern value="[a-zA-Z0-9_:/@#%=~\.\\\-\^\{\}\[\]\+]*"/>
    </xs:restriction>
  </xs:simpleType>
  <xs:simpleType name="WssecVersion">
    <xs:annotation>
      <xs:documentation>Web Service Security Versions</xs:documentation>
    </xs:annotation>
    <xs:restriction base="xs:string">
      <xs:enumeration value="2002-07"/>
      <xs:enumeration value="2002-12"/>
      <xs:enumeration value="2003-06"/>
      <xs:enumeration value="2004-01"/>
    </xs:restriction>
  </xs:simpleType>
  <xs:simpleType name="BindingType">
    <xs:annotation>
      <xs:documentation>What type of Binding mechanism is to be utilized</xs:documentation>
    </xs:annotation>
    <xs:restriction base="xs:string">
      <xs:enumeration value="SOAP"/>
      <xs:enumeration value="REST"/>
    </xs:restriction>
  </xs:simpleType>
  <xs:simpleType name="SoapVersion">
    <xs:annotation>
      <xs:documentation>Web Service (WS-)Simple Object Access Protocol (SOAP) Versions</xs:documentation>
    </xs:annotation>
    <xs:restriction base="xs:string">
      <xs:enumeration value="1.1"/>
      <xs:enumeration value="1.2"/>
      <xs:enumeration value="deferred">
        <xs:annotation>
          <xs:documentation>
            This indicates that the actual SOAP version to be utilized will be determined by Service Designer Action
            Builder based upon information associated with the workflow that the WS-Security operation has been bound to.
            This allows an application to define a single WS-Security Policy that is reusable in multiple workflows using 
            different SOAP versions. 
          </xs:documentation>
        </xs:annotation>
      </xs:enumeration>
    </xs:restriction>
  </xs:simpleType>
  <xs:simpleType name="SamlVersion">
    <xs:annotation>
      <xs:documentation>Security Assertion Markup Language Versions</xs:documentation>
    </xs:annotation>
    <xs:restriction base="xs:string">
      <xs:enumeration value="2.0"/>
      <xs:enumeration value="1.1"/>
      <xs:enumeration value="1.0"/>
    </xs:restriction>
  </xs:simpleType>
  <xs:simpleType name="SamlTokenVersion">
    <xs:annotation>
      <xs:documentation>Security Assertion Markup Language Token Versions</xs:documentation>
    </xs:annotation>
    <xs:restriction base="xs:string">
      <xs:enumeration value="1.1">
        <xs:annotation>
          <xs:documentation>Web Services Security: SAML Token Profile 1.1 OASIS Standard, 1 February 2006</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="1.0">
        <xs:annotation>
          <xs:documentation>Web Services Security: SAML Token Profile 1.0 OASIS Standard, 1 Dec. 2004</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="draft_2003-02-21">
        <xs:annotation>
          <xs:documentation>
            Web Services Security: SAML Token Profile Working Draft 06, 21 February 2003
            Uses the incorrect ValueType=saml:Assertion
          </xs:documentation>
        </xs:annotation>
      </xs:enumeration>
    </xs:restriction>
  </xs:simpleType>
  <xs:simpleType name="SwAVersion">
    <xs:annotation>
      <xs:documentation>Soap with Attachment (SwA) Versions</xs:documentation>
    </xs:annotation>
    <xs:restriction base="xs:string">
      <xs:enumeration value="1.1"/>
    </xs:restriction>
  </xs:simpleType>
  <xs:complexType name="ProcessingInstructions">
    <xs:attribute name="signTimestamp" type="xs:boolean" use="optional" default="false">
      <xs:annotation>
        <xs:documentation>Should the timestamp be signed</xs:documentation>
        <!-- constraint: This attribute usage is restricted to signature generation operations -->
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="signSecurityToken" type="xs:boolean" use="optional" default="false">
      <xs:annotation>
        <xs:documentation>
          Should the associated security token be signed.
          
          In WS-SecurityPolicy 1.2, it is recommended that the underlying protection mechanism be used
          to ensure that the supporting tokens are cryptgraphically bound to the message.
          If message level secufrity is used, then the token is added to the reference list of the signature
          operation with the Transform Algorithm=
            "http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-soap-message-security-1.0#STR-Transform"
          If transport level security, e.g., SSL/TLS, is used, then the token does not need to be added to the 
          message level signature reference list.
        </xs:documentation>
        <!-- constraint: This attribute usage is restricted to signature generation operations -->
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="stripEncryption" type="xs:boolean" use="optional" default="false">
      <xs:annotation>
        <xs:documentation>
          Should the decrypted encryption element be removed.
          This removal processing affects the following artifacts:
          1) the EncryptedKey element,
          2) the associated EncyptedData elements, and
          3) the Security Token Reference associated with the EncryptedKey element.
        </xs:documentation>
        <!-- constraint: This attribute usage is restricted to decryption operations -->
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="stripSignature" type="xs:boolean" use="optional" default="false">
      <xs:annotation>
        <xs:documentation>
          Should the verified signature operation be removed.
          This processing only affects the following artifacts:
          1) the actual Signature element.
          2) the associated SecurityTokenReference element.
          
          It does NOT cover the wsu:Id attribute on references in the signature manifest. This is because the same target 
          element could be included in multiple signatures, i.e., removing the wsu:id would break these other signatures.
          An additional complexity comes from the fact that these other signatures could be encrypted and NOT 
          visible to inspection by the system verifying and removing the signature.
        </xs:documentation>
        <!-- constraint: This attribute usage is restricted to signature verification operations -->
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="stripTimestamp" type="xs:boolean" use="optional" default="true">
      <xs:annotation>
        <xs:documentation>
          Should a successful verified signature operation remove the WS-Security Timestamp.
          This only applies if the WS-Security Timestamp is one of the references.
        </xs:documentation>
        <!-- constraint: This attribute usage is restricted to signature verification operations -->
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="stripAllReferenceIds" type="xs:boolean" use="optional" default="false">
      <xs:annotation>
        <xs:documentation>
          Should all the wsu:Id references associated with the verified signature operation be removed.
          This processing only affects the wsu:Id associated with target elements in this signature manifest. 
          
          Removing these wsu:Id may NOT always be safe is because the same target element could be included in multiple 
          signatures, i.e., removing the wsu:id would break these other signatures.
          An additional complexity comes from the fact that these other signatures could be encrypted and not 
          visible to inspection.
          
          Lastly, the removal of these wsu:Id can be very performance intensive because it requires the the associate XML 
          document fragment to be rewritten because of the change.
        </xs:documentation>
        <!-- constraint: This attribute usage is restricted to signature verification operations -->
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="saveSignatureConfirmationData" type="xs:boolean" use="optional" default="false">
      <xs:annotation>
        <xs:documentation>
          On signature generation, this instructs us to save generated signature value internally for checking reply message
          for a success signature confirmation element.
          
          On signature verification, this instructs us to save incoming signature value internally if signature is successfully
          verified. If signature verification is unsuccessful then a null signature value will be saved for signature confirmation
          element to be generated in respond message to be generated
        </xs:documentation>
        <!-- constraint: This attribute usage is restricted to signature generation and verification operations -->
      </xs:annotation>
    </xs:attribute>
  </xs:complexType>
  <xs:complexType name="KeyInfoType">
    <xs:annotation>
      <xs:documentation>Identify what form of KeyInfo is to be used</xs:documentation>
    </xs:annotation>
    <xs:attribute name="format" type="wssec:KeyInfo" use="required"/>
    <xs:attribute name="generateNonce" type="xs:boolean" use="optional" default="true">
      <xs:annotation>
        <xs:documentation>
          Should a nonce be generated as part of the UsernameToken.
          A nonce is a random value that is used to uniquely identify a specific request.
        </xs:documentation>
        <!-- constraint: only allowed if tokenType is username and usage is either encrypt or sign -->
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="generateCreatedTimestamp" type="xs:boolean" use="optional" default="true">
      <xs:annotation>
        <xs:documentation>Should a creation timestamp be generated as part of the UsernameToken</xs:documentation>
        <!-- constraint: only allowed if tokenType is username and usage is either encrypt or sign -->
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="iteration" type="xs:unsignedInt" use="optional" default="1000">
      <xs:annotation>
        <xs:documentation>
          The number of times that the hashing operation is repeated when deriving the key.
        </xs:documentation>
        <!-- constraint: only allowed if tokenType is username, keyInfo format is KeyDerivation, usage is either sign or encrypt -->
      </xs:annotation>
    </xs:attribute>
  </xs:complexType>
  <xs:simpleType name="KeyInfo">
    <xs:annotation>
      <xs:documentation>What form of KeyInfo should be package with either the signature generation or encryption.</xs:documentation>
    </xs:annotation>
    <xs:restriction base="xs:string">
      <xs:enumeration value="IssuerSerial">
        <xs:annotation>
          <xs:documentation>X509Data: issuer distinguished name/serial number from associated certificate</xs:documentation>
        </xs:annotation>
        <!-- constraint: only allowed is tokenType is x509 -->
      </xs:enumeration>
      <xs:enumeration value="SubjectName">
        <xs:annotation>
          <xs:documentation>X509Data: subject distiguished name from associated certificate</xs:documentation>
        </xs:annotation>
        <!-- constraint: only allowed is tokenType is x509 -->
      </xs:enumeration>
      <xs:enumeration value="SKI">
        <xs:annotation>
          <xs:documentation>
            X509Data: SubjectKeyIdentifier (SKI) from associated certificate.
            The subjectKeyIdentifier is an optional element with a certificate. 
            We can generate all the well-defined forms of it but we have no way of know what form the recepient will be expecting.
            This can cause interoperate failures.
            Therefore, WSSEC will automatically use optional element in specified certificate.
            If specified certificate does not contain optional SKI, WSSEC processing will fail.
          </xs:documentation>
        </xs:annotation>
        <!-- constraint: only allowed is tokenType is x509 -->
      </xs:enumeration>
      <xs:enumeration value="ThumbprintSha1">
        <xs:annotation>
          <xs:documentation>
            X509Data: ThumbprintSHA1 from associated certificate.
            The ThumbrintSHA1 is derived from the certificate. 
            It is also referred to s the SHA-1 Fingerprint in most browsers and X.509 PKI systems and our local keystore query mechanism.
          </xs:documentation>
        </xs:annotation>
        <!-- constraint: only allowed is tokenType is x509 -->
      </xs:enumeration>
      <xs:enumeration value="Certificate">
        <xs:annotation>
          <xs:documentation>X509Data: associated certificate</xs:documentation>
        </xs:annotation>
        <!-- constraint: only allowed is tokenType is x509 -->
      </xs:enumeration>
      <xs:enumeration value="CertificatePath">
        <xs:annotation>
          <xs:documentation>
            An ordered list of X.509 certificates packaged in a PKIPath.
            X509Data: ValueType attribute = #X509PKIPathv1. 
          </xs:documentation>
        </xs:annotation>
        <!-- constraint: 1) ONLY ALLOWED if (tokenType == x509) 
                         2) ONLY PRESENT if (operation == (sign OR verify))
        -->
      </xs:enumeration>
      <xs:enumeration value="PasswordText">
        <xs:annotation>
          <xs:documentation>
            Username token: the actual password, password hash or derived password is being passed in the clear in the message.
            Standards RECOMMEND that the password, password hash or derived password only be passed when either transport level security
            such as TLS or the token itself is being encrypted.
          </xs:documentation>
        </xs:annotation>
        <!-- constraint: only allowed is tokenType is username and operation is sign or verify -->
      </xs:enumeration>
      <xs:enumeration value="PasswordDigest">
        <xs:annotation>
          <xs:documentation>
            Username token: the Base64( SHA-1([nonce +] [creationTime +] password)) is being passed in the message. 
            Where nonce and creationTime are optional. The nonce is a random value created by the sender to counteract replay attacks.
            The creationTime is a timestamp indicating when the message was created.
            The receiver is assumed to maintain a cache of nonces for the creation time plus a locally configured freshness time period, 
            e.g., five minutes.
            The reception of a message with a known nonce within the freshness period is treated as a replay attach and should be rejected.
            
            Standards RECOMMEND that the password, password hash or derived password only be passed when either transport level security
            such as TLS or the token itself is being encrypted.
          </xs:documentation>
        </xs:annotation>
        <!-- constraint: only allowed is tokenType is username and operation is sign or verify -->
      </xs:enumeration>
      <xs:enumeration value="KeyDerivation">
        <xs:annotation>
          <xs:documentation>
            Username token: The password associated with the username is used to derive a shared (symmetric) secret key.
            This procesdure is used when keys must be derived fom passwords for interoperability.
            When key derivation is selected, the password must not be included in the username token being sent.
            The receiver must be able to use its knowledge of the username to determine the password to derive the same key.
            
            When used for signing or verification (MAC operation), the key length must always be 160 bit.
            When used for encryption and decryption, the encryption algorithm key must not exceed 160 bits. 
            A sufficient number of the higher order bits should be used, e.g., first 128 bits for AES-128.
            
            The key derivation algorithm concatenate the the password and salt value and then repeatly apply a SHA-1 hash a
            user specified number of times. The specific algorithms used is PBKDF1 described in Rfc 2898.
            The salt is a 128 bit where the high order 8- bits is 01 if the key will be used in a Message Authentication Code 
            (MAC) ==&gt; sign or verify and 02 if the key will be used as a symmetric key for encryption or decryption. 
            The lower 120 bits should be a random value.
          </xs:documentation>
        </xs:annotation>
        <!-- constraint: only allowed if tokenType is username -->
      </xs:enumeration>
      <xs:enumeration value="KeyName">
        <xs:annotation>
          <xs:documentation>
            A character string that the signer or encrypter uses to uniquely identify the key to the recipent.
          </xs:documentation>
          <xs:appinfo>
            If tokenType is x509 then the subject name of the certificate is assumed.
            If tokenType is username then username is assumed.
            If tokenType is symmetric then keyname is assumed.
          </xs:appinfo>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="KeyIdentifier">
        <xs:annotation>
          <xs:documentation>
            A character string that the signer or encrypter uses to uniquely identify the key to the recipent.
          </xs:documentation>
        </xs:annotation>
        <!-- constraint: only allowed if tokenType is symmetric -->
      </xs:enumeration>
      <xs:enumeration value="SamlAssertionReference">
        <xs:annotation>
          <xs:documentation>
            The assertionID values from the SAML assertion is to be package within the SecurityTokenReference.
            The operational code will:
            1) find the specified SAML assertion
            2) find a confirmation method using some form of holder-of-key.
            3) use the associated KeyInfo
          </xs:documentation>
        </xs:annotation>
        <!-- constraint: 1) ONLY ALLOWED for sign and verify operations 
                            Note: Defer to future supporting use in encrypton and decryption.
                         2) ONLY ALLOWED if (tokenType == (x509 OR symmetric). 
                            Note: Should be able to support username. Defer to future.
        -->
      </xs:enumeration>
      <xs:enumeration value="useExistingBST">
        <xs:annotation>
          <xs:documentation>
            Use an existing Binary Security Token from the incoming document.
            The token ust be a based64 encode security token, e.g., X509v3 certificate, CA Path, PKCS7 bag, Kerberos token, etc.
          </xs:documentation>
        </xs:annotation>
        <!-- constraint: 1) ONLY ALLOWED if ((tokenType == (x509 [OR kerberos])) AND (operation == (sign OR encrypt))) 
                         2) operational code must check that existing BST is of the correct type
        -->
      </xs:enumeration>
      <xs:enumeration value="DerivedKeyTokenWithX509EncryptedKey">
        <xs:annotation>
          <xs:documentation>
            A WS-SecureConvensation DerivedKeyToken should be generated. The secret referenced by the DerivedKeyToken should be excrypted within
            an EncryptedKey element using some form of PKI X.509 key transport method (asymmetric secret): RSA-OAEP or RSA-v1.5
          </xs:documentation>
          <xs:appinfo>
            1) Generate random secret. Configurable number of bytes. Default: 32.
            2) Generate configurable number of byte random nonce. Default: 32.
            3) Generate a derived key using psha1 extension function. For encryption operation, length based upon bulk data encryption method, 
               e.g., aes-128: 16 bytes. For signature operation, size of HMAC digest algorithm, e.g., hmac-sha1: 20 bytes.
            4) Use derived key in operation.
            5) If signature or encryption operation then generate DerivedKeyToken element in WS-Security header.
            6) If signature or encryption operation then generate EncryptedKey element in WS-Security header holding generated secret in WS-Security 
               header using specified key encryption method.
          </xs:appinfo>
        </xs:annotation>
        <!-- constraint: ONLY ALLOWED if (tokenType == x509) -->
      </xs:enumeration>
      <xs:enumeration value="DerivedKeyTokenWithEncryptedKeySha1">
        <xs:annotation>
          <xs:documentation>
            <xs:documentation>
            A WS-SecureConvensation DerivedKeyToken should be generated. This DerivedKeyToken will contain the base64(sha1(secret sent)).
          </xs:documentation>
            <xs:appinfo>
            1) Generate configurable number of byte random nonce. Default: 32.
            2) Generate a derived key using psha1 extension function. For encryption operation, length based upon bulk data encryption method, 
               e.g., aes-128: 16 bytes. For signature operation, size of HMAC digest algorithm, e.g., hmac-sha1: 20 bytes.
            3) Use derived key in signature/verify operation.
            4) If signature operation then generate DerivedKeyToken in WS-Security header.
          </xs:appinfo>
          </xs:documentation>
        </xs:annotation>
        <!-- constraint: ONLY ALLOWED if ((tokenType == x509) AND ((operation == sign) OR (operation == verify)) -->
      </xs:enumeration>
      <!-- Currently do not support these forms
      <xs:enumeration value="KeyValue">
        <xs:annotation>
          <xs:documentation>
            The actual value of a single public key of validating a signature, decrypting data or agreeing on a key
           </xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="RetrievalMethod">
        <xs:annotation>
          <xs:documentation>Reference to KeyInfo data that is stored at another location</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      -->
    </xs:restriction>
  </xs:simpleType>
  <xs:complexType name="DerivedKeyTokenCreationInfo">
    <xs:annotation>
      <xs:documentation>Contains all information required to create a WS-SecureConversation DerivedKeyToken</xs:documentation>
    </xs:annotation>
    <xs:sequence>
      <xs:element name="derivedKeyLength" default="32">
        <xs:annotation>
          <xs:documentation>Length (in bytes) of the derived key.</xs:documentation>
        </xs:annotation>
        <xs:simpleType>
          <xs:restriction base="xs:unsignedInt">
            <xs:minInclusive value="16"/>
            <xs:maxInclusive value="256"/>
          </xs:restriction>
        </xs:simpleType>
      </xs:element>
      <xs:element name="label" type="xs:string" minOccurs="0">
        <xs:annotation>
          <xs:documentation>A user supplied strig that is utilized when generating the derived key: P_SHA1 (secret, label + nonce)</xs:documentation>
        </xs:annotation>
      </xs:element>
      <xs:element name="nonceLength" default="32">
        <xs:annotation>
          <xs:documentation>Length (in bytes) of the nonce.</xs:documentation>
        </xs:annotation>
        <xs:simpleType>
          <xs:restriction base="xs:unsignedInt">
            <xs:minInclusive value="16"/>
            <xs:maxInclusive value="256"/>
          </xs:restriction>
        </xs:simpleType>
      </xs:element>
      <xs:element name="derivedKeyKeyEncryptionGenerationMethod" type="wssec:KeyEncryptionGenerationMethodType" minOccurs="0">
        <xs:annotation>
          <xs:documentation>
            Identifies the Key Encryption Method that will be used to encrypt the symmetric secret being sent by the client/producer entity
            to the server/consumer entity.
          </xs:documentation>
        </xs:annotation>
        <!-- constraint: 1) ONLY PRESENT when usage(operation type) == sign.
                         2) NOT PRESENT when usage(operation type) == encrypt.
        -->
      </xs:element>
      <xs:element name="derivedKeyKeyInfo" type="wssec:KeyInfoType">
        <!-- constraint: ONLY ALLOWED if ((token type == x509) AND (operation == encrypt) AND 
                                          (types of KeyInfo == (certifcate OR subject name OR SKI OR issuer/serial-number OR SHA1 thumbprint)
                                         ) OR
                                         ((token type == x509) AND (operation == sign) AND 
                                          (types of KeyInfo == (certifcate OR subject name OR SKI OR issuer/serial-number OR 
                                                                SHA1 thumbprint [OR use existing BST OR SamlAssertionReference])
                                         )
                         Note: We will defer support of use existing BST or SamlAssertionReference for WS-Secure Convensation derived 
                               key token at this time.
        -->
      </xs:element>
    </xs:sequence>
  </xs:complexType>
  <xs:complexType name="EncryptedKeySha1CreationInfo">
    <xs:annotation>
      <xs:documentation>
        When multiple DerivedKeyTokens are being utilized by multiple signature operations being verified in the incoming message, there is the
        need to be able to identify for a signature on the response to know which DerivedKeyToken to utilized.
        This element allows an application to identify which incoming DerivedKeyToken/signature this new signature is assocaited.
        If no incoming signature/DerivedKeyToken is identified, then the first DerivedKeyToken associated with a signature will be used.
      </xs:documentation>
    </xs:annotation>
    <xs:choice>
      <xs:element name="useSignatureId">
        <xs:annotation>
          <xs:documentation>
            Identifies which signature related DerivedKeyToken element to use by signature Id.
            We will allow an application to utilize a pcre regular expresstion to identifiy a match.
            
            The Id is an optional attribute and Microsoft tools do not always populate it.
            Also, when it does populate it Microsoft will only use _integer, i.e., very order generation processing dependent.
          </xs:documentation>
        </xs:annotation>
        <xs:simpleType>
          <xs:restriction base="xs:string">
            <xs:minLength value="1"/>
          </xs:restriction>
        </xs:simpleType>
      </xs:element>
      <xs:element name="useDerivedKeyTokenId">
        <xs:annotation>
          <xs:documentation>
            Identifies which signature related DerivedKeyToken element to use by DerivedKeyToken Id.
            We will allow an application to utilize a pcre regular expresstion to identifiy a match.
            
            Microsoft will only use _integer when it populates this attribute, i.e., very order generation processing dependent.
          </xs:documentation>
        </xs:annotation>
        <xs:simpleType>
          <xs:restriction base="xs:string">
            <xs:minLength value="1"/>
          </xs:restriction>
        </xs:simpleType>
      </xs:element>
      <xs:element name="useOrderPosition">
        <xs:annotation>
          <xs:documentation>
            Identifies which signature related DerivedKeyToken element to use by its positional ordering within the incoming message, 
            e.g., first DerivedKeyToken element.
          </xs:documentation>
        </xs:annotation>
        <xs:simpleType>
          <xs:restriction base="xs:unsignedInt">
            <xs:minInclusive value="1"/>
            <xs:maxInclusive value="16"/>
          </xs:restriction>
        </xs:simpleType>
      </xs:element>
    </xs:choice>
  </xs:complexType>
  <xs:complexType name="HeaderLocation">
    <xs:annotation>
      <xs:documentation>
        Identifies where in the incoming message the signature or encryption header is to be found.
      </xs:documentation>
    </xs:annotation>
    <xs:sequence>
      <xs:element name="namespaces" type="wssec:Namespaces" minOccurs="0"/>
      <xs:element name="xpath" type="wssec:XPathExpression"/>
    </xs:sequence>
  </xs:complexType>
  <xs:complexType name="TargetElements">
    <xs:annotation>
      <xs:documentation>
        Identifies what part of the SOAP message are to be processed by the associated security operation
      </xs:documentation>
    </xs:annotation>
    <xs:sequence>
      <xs:element name="namespaces" type="wssec:Namespaces" minOccurs="0"/>
      <xs:element name="xpath" type="wssec:XPathExpression" maxOccurs="unbounded"/>
    </xs:sequence>
  </xs:complexType>
  <xs:complexType name="XPathExpression">
    <xs:annotation>
      <xs:documentation>XPath expression identifying data to be processed(signed or encrypted)/utilized(identifing existing BST)</xs:documentation>
    </xs:annotation>
    <xs:simpleContent>
      <xs:extension base="wssec:NonEmptyString">
        <xs:attribute name="includingTags" type="xs:boolean" use="optional" default="true">
          <xs:annotation>
            <xs:documentation>
              For signature generation and encryption, it specifies that the actual tags of the specified element are 
              to be part of the specified operation. 
                
              For signature verification and decryption, it specifies that the actual tags have been included as part of
              the specified operation.
            </xs:documentation>
          </xs:annotation>
          <!-- constraint: the includingTags attribute is only meaningful/viewable when associated with TargetElements,
                           i.e., visible in policy editor.
                           It is meaningless when associated with HeaderLocation, i.e., it should not be visible in policy editor.
          -->
        </xs:attribute>
        <xs:attribute name="transformAlgorithm" use="optional" default="canonicalization">
          <xs:simpleType>
            <xs:restriction base="xs:string">
              <xs:enumeration value="canonicalization">
                <xs:annotation>
                  <xs:documentation>Inclusive or exclusive wwo comments</xs:documentation>
                </xs:annotation>
              </xs:enumeration>
              <xs:enumeration value="STR-Transform">
                <xs:annotation>
                  <xs:documentation>Security Token Reference (STR) Transform</xs:documentation>
                </xs:annotation>
              </xs:enumeration>
              <!-- deferred (forever I hope) 
                   Note: 1) base64_decoding: we already do as part of attachment processing, i.e. do not need here.
                         2) XPath: would require an optional subtables for defining the XPath expression and associated prefixes.
                         3) XSLT: I do not even want to thnk about.
              <xs:enumeration value="XPath-filtering">
                <xs:annotation><xs:documentation>XPath</xs:documentation></xs:annotation>
              </xs:enumeration>
              <xs:enumeration value="base64-decoding">
                <xs:annotation><xs:documentation>MIME</xs:documentation></xs:annotation>
              </xs:enumeration>
              <xs:enumeration value="XSLT">
                <xs:annotation><xs:documentation>XPath</xs:documentation></xs:annotation>
              </xs:enumeration>
              -->
            </xs:restriction>
          </xs:simpleType>
        </xs:attribute>
      </xs:extension>
    </xs:simpleContent>
  </xs:complexType>
  <xs:simpleType name="NonEmptyString">
    <xs:restriction base="xs:string">
      <xs:minLength value="1"/>
      <!-- constraint: only present when tokenType is username or x509 -->
    </xs:restriction>
  </xs:simpleType>
  <xs:complexType name="Namespaces">
    <xs:sequence minOccurs="0" maxOccurs="unbounded">
      <xs:element name="namespace">
        <xs:complexType>
          <xs:attribute name="prefix" type="xs:NCName"/>
          <xs:attribute name="uri" type="xs:anyURI"/>
        </xs:complexType>
      </xs:element>
    </xs:sequence>
  </xs:complexType>
  <xs:complexType name="TargetAttachments">
    <xs:annotation>
      <xs:documentation>Identifies what attachments of the SOAP messagge are to be processed by the associated security operation</xs:documentation>
    </xs:annotation>
    <xs:sequence>
      <!-- constraint: if "all" attribute is specified, then no other "Attachment" elements can be specified. -->
      <!-- constraint: if "cid" attribute is psecified, then multiple "Attachment" elements with "cid" attribute may specified -->
      <xs:element name="attachment" type="wssec:Attachment" maxOccurs="unbounded"/>
    </xs:sequence>
  </xs:complexType>
  <xs:complexType name="Attachment">
    <xs:attribute name="all" type="xs:boolean" use="optional" default="false">
      <xs:annotation>
        <xs:documentation>Identifies that all attachments are to be processed</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="cid" use="optional">
      <xs:annotation>
        <xs:documentation>Identifies a specific attachment via content identifier, cid, associated with this attachment</xs:documentation>
      </xs:annotation>
      <xs:simpleType>
        <xs:restriction base="xs:anyURI">
          <xs:minLength value="1"/>
        </xs:restriction>
      </xs:simpleType>
    </xs:attribute>
    <xs:attribute name="scope" use="required">
      <xs:annotation>
        <xs:documentation>What part of the specified attachment is to be processed</xs:documentation>
      </xs:annotation>
      <xs:simpleType>
        <xs:restriction base="xs:string">
          <xs:enumeration value="content-only"/>
          <xs:enumeration value="full-attachment"/>
        </xs:restriction>
      </xs:simpleType>
    </xs:attribute>
    <!-- constraint: either the "cid" or "all" attribute must be specified, but NOT both. -->
  </xs:complexType>
  <xs:simpleType name="TokenType">
    <xs:annotation>
      <xs:documentation>Type security token being processed</xs:documentation>
    </xs:annotation>
    <xs:restriction base="xs:string">
      <xs:enumeration value="x509">
        <xs:annotation>
          <xs:documentation>Public Key Infrastructure (PKI), X.509 certificates and private key tokens</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="username">
        <xs:annotation>
          <xs:documentation>Username/password token</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="symmetric">
        <xs:annotation>
          <xs:documentation>Symmetric secret token. This is used when application is utilizing a shared secret.</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="saml">
        <xs:annotation>
          <xs:documentation>Security Assertion Markup Language (SAML)</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="kerberos">
        <xs:annotation>
          <xs:documentation>Kerberos token</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <!-- the following are future types
              <xs:enumeration value="rel">
                <xs:annotation>
                  <xs:documentation>Rights expression Language (REL) token</xs:documentation>
                </xs:annotation>
              </xs:enumeration>
      -->
    </xs:restriction>
  </xs:simpleType>
  <xs:simpleType name="Usage">
    <xs:restriction base="xs:string">
      <xs:enumeration value="ignore">
        <xs:annotation>
          <xs:documentation>No default usage defined. Usage defined by explicit element used in policy, e.g., JWS verify.</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="sign">
        <xs:annotation>
          <xs:documentation>Use security policy for WS-Security signature generation only</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="verify">
        <xs:annotation>
          <xs:documentation>Use security policy for WS-Security signature verification only</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="encrypt">
        <xs:annotation>
          <xs:documentation>Use security policy for WS-Security encrypting only</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="decrypt">
        <xs:annotation>
          <xs:documentation>Use security policy for WS-Security decrypting only</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="createSecurityToken">
        <xs:annotation>
          <xs:documentation>Use security policy to create standalone WS-Security Token: either Kerberos or SAML Assertion.</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
    </xs:restriction>
  </xs:simpleType>
  <xs:complexType name="SignatureAcceptMethods">
    <xs:all>
      <!-- constraint: 1) if (tokenType == x509) then dsaWithSha1, rsaWithSha[xxx], rsaWithRipemd160, and rsaWithMD5 methods allowed.
                       2) if (tokenType == (username OR symmetric)) 
                          then hmacWithShaXxx, hmacWithRipemd160 and hmacWithMd5 methods allowed.
      -->
      <xs:element name="dsaWithSha1" type="wssec:EmptyType" minOccurs="0">
        <xs:annotation>
          <xs:documentation>Signature method using assymmetric DSA key with SHA1 digest.</xs:documentation>
        </xs:annotation>
      </xs:element>
      <xs:element name="rsaWithSha1" type="wssec:EmptyType" minOccurs="0">
        <xs:annotation>
          <xs:documentation>Signature method using assymmetric RSA key with SHA1 digest.</xs:documentation>
        </xs:annotation>
      </xs:element>
      <xs:element name="rsaWithSha256" type="wssec:EmptyType" minOccurs="0">
        <xs:annotation>
          <xs:documentation>Signature method using assymmetric RSA key with SHA-256 digest.</xs:documentation>
        </xs:annotation>
      </xs:element>
      <xs:element name="rsaWithSha384" type="wssec:EmptyType" minOccurs="0">
        <xs:annotation>
          <xs:documentation>Signature method using assymmetric RSA key with SHA-384 digest.</xs:documentation>
        </xs:annotation>
      </xs:element>
      <xs:element name="rsaWithSha512" type="wssec:EmptyType" minOccurs="0">
        <xs:annotation>
          <xs:documentation>Signature method using assymmetric RSA key with SHA-512 digest.</xs:documentation>
        </xs:annotation>
      </xs:element>
      <xs:element name="rsaWithMd5" type="wssec:EmptyType" minOccurs="0">
        <xs:annotation>
          <xs:documentation>Signature method using assymmetric RSA key with MD5 digest.</xs:documentation>
        </xs:annotation>
      </xs:element>
      <xs:element name="rsaWithRipemd160" type="wssec:EmptyType" minOccurs="0">
        <xs:annotation>
          <xs:documentation>Signature method using assymmetric RSA key with RIPEMD-160 digest.</xs:documentation>
        </xs:annotation>
      </xs:element>
      <xs:element name="hmacWithSha1" type="wssec:EmptyType" minOccurs="0">
        <xs:annotation>
          <xs:documentation>Signature method (HMAC) using symmetric key with SHA1 digest.</xs:documentation>
        </xs:annotation>
      </xs:element>
      <xs:element name="hmacWithSha256" type="wssec:EmptyType" minOccurs="0">
        <xs:annotation>
          <xs:documentation>Signature method (HMAC) using symmetric key with SHA-256 digest.</xs:documentation>
        </xs:annotation>
      </xs:element>
      <xs:element name="hmacWithSha384" type="wssec:EmptyType" minOccurs="0">
        <xs:annotation>
          <xs:documentation>Signature method (HMAC) using symmetric key with SHA-384 digest.</xs:documentation>
        </xs:annotation>
      </xs:element>
      <xs:element name="hmacWithSha512" type="wssec:EmptyType" minOccurs="0">
        <xs:annotation>
          <xs:documentation>Signature method (HMAC) using symmetric key with SHA-512 digest.</xs:documentation>
        </xs:annotation>
      </xs:element>
      <xs:element name="hmacWithMd5" type="wssec:EmptyType" minOccurs="0">
        <xs:annotation>
          <xs:documentation>Signature method (HMAC) using symmetric key with MD5 digest. Not recommented</xs:documentation>
        </xs:annotation>
      </xs:element>
      <xs:element name="hmacWithRipemd160" type="wssec:EmptyType" minOccurs="0">
        <xs:annotation>
          <xs:documentation>Signature method (HMAC) using symmetric key with RIPEMD-160 digest.</xs:documentation>
        </xs:annotation>
      </xs:element>
    </xs:all>
    <xs:attribute name="minimumHmacOutputLenght" use="optional">
      <xs:annotation>
        <xs:documentation>
          Allows developer to restrict range of HMAC signatures output lenghts.
          This prevents an attacker from changing signature HMACOutputLenght to a smaller value to weaken signature value.
        </xs:documentation>
      </xs:annotation>
      <!-- constraint: must be multiple of 8 bits -->
      <!-- constraint: signature method must be hmacWithXXX -->
      <!-- constraint: Maxinclusive value is really limited to type of digest method used in signature method: Sha1, Sha256, etc. -->
      <!-- constraint: Service Designer should default value to type of digest method and always output this attribute -->
      <xs:simpleType>
        <xs:restriction base="xs:unsignedInt">
          <xs:minInclusive value="8"/>
          <xs:maxInclusive value="512"/>
        </xs:restriction>
      </xs:simpleType>
    </xs:attribute>
  </xs:complexType>
  <xs:simpleType name="SignatureGenerationMethod">
    <xs:restriction base="xs:string">
      <xs:enumeration value="rsaWithSha1">
        <xs:annotation>
          <xs:documentation>Signature method using assymmetric RSA key with SHA1 digest.</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="rsaWithSha256">
        <xs:annotation>
          <xs:documentation>Signature method using assymmetric RSA key with SHA-256 digest.</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="rsaWithSha384">
        <xs:annotation>
          <xs:documentation>Signature method using assymmetric RSA key with SHA-384 digest.</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="rsaWithSha512">
        <xs:annotation>
          <xs:documentation>Signature method using assymmetric RSA key with SHA-512 digest.</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="rsaWithMd5">
        <xs:annotation>
          <xs:documentation>Signature method using assymmetric RSA key with MD5 digest.</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="rsaWithRipemd160">
        <xs:annotation>
          <xs:documentation>Signature method using assymmetric RSA key with RIPEMD-160 digest.</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="hmacWithSha1">
        <xs:annotation>
          <xs:documentation>Signature method (HMAC) using symmetric key with SHA1 digest.</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="hmacWithSha256">
        <xs:annotation>
          <xs:documentation>Signature method (HMAC) using symmetric key with SHA-256 digest.</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="hmacWithSha384">
        <xs:annotation>
          <xs:documentation>Signature method (HMAC) using symmetric key with SHA-384 digest.</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="hmacWithSha512">
        <xs:annotation>
          <xs:documentation>Signature method (HMAC) using symmetric key with SHA-512 digest.</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="dsaWithSha1">
        <xs:annotation>
          <xs:documentation>Signature method using assymmetric DSA key with SHA1 digest.</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="hmacWithMd5">
        <xs:annotation>
          <xs:documentation>Signature method (HMAC) using symmetric key with MD5 digest. Not recommented</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="hmacWithRipemd160">
        <xs:annotation>
          <xs:documentation>Signature method (HMAC) using symmetric key with RIPEMD-160 digest.</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
    </xs:restriction>
    <!-- constraint: 1) if ((tokenType == x509) AND 
                            (keyInfo != (DerivedKeyTokenWithX509EncryptedKey OR DerivedKeyTokenWithEncryptedKeySha1))
                           ) 
                        then dsaWithSha1, rsaWithSha[xxx] and rsaWithMD5 and rsaWithRipemd160 methods allowed.
                     2) if ((tokenType == x509) AND 
                            (keyInfo == (DerivedKeyTokenWithX509EncryptedKey OR DerivedKeyTokenWithEncryptedKeySha1))
                           ) 
                        then hmacWithSha[Xxx] and hmacWithMd5 and hmacWithRipemd160 methods allowed
                     3) if (tokenType == (username or symmetric based))
                        then hmacWithSha[Xxx] and hmacWithMd5 and hmacWithRipemd160 methods allowed 
    -->
  </xs:simpleType>
  <xs:complexType name="DigestAcceptMethods">
    <xs:all>
      <xs:element name="sha1" type="wssec:EmptyType" minOccurs="0">
        <xs:annotation>
          <xs:documentation>SHA1 (160 bit) digest method. Recommended method</xs:documentation>
        </xs:annotation>
      </xs:element>
      <xs:element name="sha224" type="wssec:EmptyType" minOccurs="0">
        <xs:annotation>
          <xs:documentation>
            SHA-224 bit digest method. Stronger but slower method.
            Basically the same SHA-256 with different initial value and truncated SHA-256 result.
          </xs:documentation>
        </xs:annotation>
      </xs:element>
      <xs:element name="sha256" type="wssec:EmptyType" minOccurs="0">
        <xs:annotation>
          <xs:documentation>SHA-256 bit digest method. Stronger but slower method</xs:documentation>
        </xs:annotation>
      </xs:element>
      <xs:element name="sha384" type="wssec:EmptyType" minOccurs="0">
        <xs:annotation>
          <xs:documentation>
            SHA-384 bit digest method. Strongest but slowed method.
            Basically the same SHA-512 with different initial value and truncated SHA-512 result.
          </xs:documentation>
        </xs:annotation>
      </xs:element>
      <xs:element name="sha512" type="wssec:EmptyType" minOccurs="0">
        <xs:annotation>
          <xs:documentation>SHA-512 bit digest method. Strongest but slowest method</xs:documentation>
        </xs:annotation>
      </xs:element>
      <xs:element name="md5" type="wssec:EmptyType" minOccurs="0">
        <xs:annotation>
          <xs:documentation>MD5 hash method. Popular, but no longer recommended</xs:documentation>
        </xs:annotation>
      </xs:element>
      <xs:element name="ripemd160" type="wssec:EmptyType" minOccurs="0">
        <xs:annotation>
          <xs:documentation>RIPEMD-160 hash method. Equivalent to SHA-1.</xs:documentation>
        </xs:annotation>
      </xs:element>
    </xs:all>
  </xs:complexType>
  <xs:simpleType name="DigestGenerationMethod">
    <xs:restriction base="xs:string">
      <xs:enumeration value="sha1">
        <xs:annotation>
          <xs:documentation>SHA1 (160 bit) digest method. Recommended method</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="sha224">
        <xs:annotation>
          <xs:documentation>
            SHA-224 bit digest method. Stronger but slower method.
            Basically same as SHA-256 with different initial value and truncated SHA-256 result.
          </xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="sha256">
        <xs:annotation>
          <xs:documentation>SHA-256 bit digest method. Stronger but slower method</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="sha384">
        <xs:annotation>
          <xs:documentation>
            SHA-384 bit digest method. Strongest but slowed method.
            Basically same as SHA-512 with different initial value and truncated SHA-512 result.
          </xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="sha512">
        <xs:annotation>
          <xs:documentation>SHA-512 bit digest method. Strongest but slowest method</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="md5">
        <xs:annotation>
          <xs:documentation>MD5 hash method. Popular, but no longer recommended because of effective collision attacks now possible.</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="ripemd160">
        <xs:annotation>
          <xs:documentation>RIPEMD-160 hash method. Equivalent to SHA-1.</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
    </xs:restriction>
  </xs:simpleType>
  <xs:complexType name="CanonicalAcceptMethods">
    <xs:all>
      <!-- default on only recommended methods -->
      <xs:element name="C14N_exclusive" type="wssec:EmptyType" minOccurs="0">
        <xs:annotation>
          <xs:documentation>C14N Exclusive canonicalization method. Comments removed. Recommended method</xs:documentation>
        </xs:annotation>
      </xs:element>
      <!-- Will be added in future release. See Exclusive XML Canonicalization, Version 1.0, W3C Recommendation 18 July 2002. (http://www.w3.org/TR/xml-exc-c14n/)
              <xs:element name="C14N_exclusiveWithComments" minOccurs="0">
                <xs:annotation>
                  <xs:documentation>C14N Exclusive canonicalization method. Comments retained. Not Recommended.</xs:documentation>
                </xs:annotation>
              </xs:element>
      -->
      <xs:element name="C14N_inclusive" type="wssec:EmptyType" minOccurs="0">
        <xs:annotation>
          <xs:documentation>C14N Inclusive canonicalization method. Comments removed. Not recommended.</xs:documentation>
        </xs:annotation>
      </xs:element>
      <xs:element name="C14N_inclusiveWithComments" type="wssec:EmptyType" minOccurs="0">
        <xs:annotation>
          <xs:documentation>C14N Inclusive canonicalization method. Comments retained. Not recommended.</xs:documentation>
        </xs:annotation>
      </xs:element>
    </xs:all>
  </xs:complexType>
  <xs:simpleType name="CanonicalGenerationMethod">
    <xs:restriction base="xs:string">
      <xs:enumeration value="C14N_exclusive">
        <xs:annotation>
          <xs:documentation>C14N Exclusive canonicalization method. Comments removed. Recommended method</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="C14N_inclusive">
        <xs:annotation>
          <xs:documentation>C14N Inclusive canonicalization method. Comments removed. Not recommended</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="C14N_inclusiveWithComments">
        <xs:annotation>
          <xs:documentation>C14N Inclusive canonicalization method. Comments retained. Not recommended</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <!-- Will be added in future release. See Exclusive XML Canonicalization, Version 1.0, W3C Recommendation 18 July 2002. (http://www.w3.org/TR/xml-exc-c14n/)
              <xs:enumeration value="C14N_exclusiveWithComments">
                <xs:annotation>
                  <xs:documentation>C14N Exclusive canonicalization method. Comments retained. Not recommended.</xs:documentation>
                </xs:annotation>
              </xs:enumeration>
      -->
    </xs:restriction>
  </xs:simpleType>
  <xs:complexType name="DataEncryptionAcceptMethods">
    <xs:all>
      <xs:element name="des3" type="wssec:EmptyType" minOccurs="0">
        <xs:annotation>
          <xs:documentation>
            Block encryption method based upon Triple DES using cipher-block chaining (CBC) mode of operation. 
          </xs:documentation>
        </xs:annotation>
      </xs:element>
      <xs:element name="aes128" type="wssec:EmptyType" minOccurs="0">
        <xs:annotation>
          <xs:documentation>
            Block encryption method based upon AES 128 bit key using cipher-block chaining (CBC) mode of operation. 
          </xs:documentation>
        </xs:annotation>
      </xs:element>
      <xs:element name="aes192" type="wssec:EmptyType" minOccurs="0">
        <xs:annotation>
          <xs:documentation>
            Block encryption method based upon AES 192 bit key using cipher-block chaining (CBC) mode of operation. 
          </xs:documentation>
        </xs:annotation>
      </xs:element>
      <xs:element name="aes256" type="wssec:EmptyType" minOccurs="0">
        <xs:annotation>
          <xs:documentation>
            Block encryption method based upon AES 256 bit key using cipher-block chaining (CBC) mode of operation. 
          </xs:documentation>
        </xs:annotation>
      </xs:element>
      <xs:element name="aes128Gcm" type="wssec:EmptyType" minOccurs="0">
        <xs:annotation>
          <xs:documentation>
            Block encryption method based upon AES 128 bit key using Galois Counter Mode (GCM). 
            Combines counter mode of encryption with the new Galois mode of authentication.
          </xs:documentation>
        </xs:annotation>
      </xs:element>
      <xs:element name="aes192Gcm" type="wssec:EmptyType" minOccurs="0">
        <xs:annotation>
          <xs:documentation>
            Block encryption method based upon AES 192 bit key using Galois Counter Mode (GCM). 
            Combines counter mode of encryption with the new Galois mode of authentication.
          </xs:documentation>
        </xs:annotation>
      </xs:element>
      <xs:element name="aes256Gcm" type="wssec:EmptyType" minOccurs="0">
        <xs:annotation>
          <xs:documentation>
            Block encryption method based upon AES 256 bit key using Galois Counter Mode (GCM). 
            Combines counter mode of encryption with the new Galois mode of authentication.
          </xs:documentation>
        </xs:annotation>
      </xs:element>
      <xs:element name="arc4" type="wssec:EmptyType" minOccurs="0">
        <xs:annotation>
          <xs:documentation>
            Stream encryption method based upon ARC4 with application defined key length.
            Not recommended for usage!
          </xs:documentation>
        </xs:annotation>
      </xs:element>
    </xs:all>
    <!-- constraint: 1) ALLOWED if ((tokenType == username) AND (keyInfo == keyDerivation) AND 
                                    (DataEncryptionAcceptMethods == (aes128 OR aes128Gcm OR arc4))
                                   )
                     2) ERROR "Specified cipher requires key greater than 160-bit while maximum derived key is 160-bits"
                        if ((tokenType == username) AND (keyInfo == keyDerivation) AND 
                            (DataEncryptionAcceptMethods == (des3 OR aes192 OR aes256 OR aes192Gcm OR aes256Gcm))
                           )
                     3) WARNING "password length must match key length of algorithm selected"
                        if ((tokenType == username) AND (keyInfo == (PasswordText OR PasswordDigest))
    -->
  </xs:complexType>
  <xs:simpleType name="DataEncryptionGenerationMethod">
    <xs:restriction base="xs:string">
      <xs:enumeration value="des3">
        <xs:annotation>
          <xs:documentation>
            Block encryption method based upon DES3 with 192 bit key using cipher-block chaining (CBC) mode of operation. 
          </xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="aes128">
        <xs:annotation>
          <xs:documentation>
            Block encryption method based upon AES 128 bit key using cipher-block chaining (CBC) mode of operation. 
          </xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="aes192">
        <xs:annotation>
          <xs:documentation>
            Block encryption method based upon AES 192 bit key using cipher-block chaining (CBC) mode of operation. 
          </xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="aes256">
        <xs:annotation>
          <xs:documentation>
            Block encryption method based upon AES 256 bit key using cipher-block chaining (CBC) mode of operation. 
          </xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="aes128Gcm">
        <xs:annotation>
          <xs:documentation>
            Block encryption method based upon AES 128 bit key using Galois Counter Mode (GCM) mode of operation.
            Secure from all known form of attacks.
          </xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="aes192Gcm">
        <xs:annotation>
          <xs:documentation>
            Block encryption method based upon AES 192 bit key using Galois Counter Mode (GCM) mode of operation.
            Secure from all known form of attacks.
          </xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="aes256Gcm">
        <xs:annotation>
          <xs:documentation>
            Block encryption method based upon AES 256 bit key using Galois Counter Mode (GCM) mode of operation. 
            Secure from all known form of attacks.
          </xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="arc4">
        <xs:annotation>
          <xs:documentation>
              Stream encryption method based upon DES3 with application defined key length. Not recommended!
          </xs:documentation>
        </xs:annotation>
      </xs:enumeration>
    </xs:restriction>
    <!-- constraint: 1) ALLOWED if ((tokenType == username) AND (keyInfo == keyDerivation) AND
                                    (DataEncryptionGenerationMethod = (aes128 OR ARC4 OR aes128Gcm))
                                   )
                     2) ERROR if ((tokenType == username) AND (keyInfo == keyDerivation) AND
                                  (DataEncryptionGenerationMethod = (des3 OR aes192 OR aes256 OR aes192Gsm OR aes256Gcm))
                                 )
                     3) WARNING "password length must match key length of algorithm selected"
                        If ((tokenType == username) AND (keyInfo == (PasswordText OR PasswordDigest))) 
    -->
  </xs:simpleType>
  <xs:complexType name="KeyEncryptionAcceptMethods">
    <xs:all>
      <!-- constraint: if tokenType == x509 based then "rsaV1.5" and "rsaOaep" methods allowed -->
      <!-- constraint: if tokenType == username based then no form of key encryption algorithm supported. -->
      <!-- constraint: if tokenType == symmetric based then "des3Kw" and "aesXxxKw" methods allowed -->
      <xs:element name="rsaV1.5" type="wssec:EmptyType" minOccurs="0">
        <xs:annotation>
          <xs:documentation>Key transport encryption method based upon RSA v1.5. Used for encrypting symmetric key</xs:documentation>
        </xs:annotation>
      </xs:element>
      <xs:element name="rsaOaep" type="wssec:EmptyType" minOccurs="0">
        <xs:annotation>
          <xs:documentation>Key transport encryption method based upon RSA-OAEP key. Used for encrypting symmetric key</xs:documentation>
        </xs:annotation>
      </xs:element>
      <xs:element name="des3Kw" type="wssec:EmptyType" minOccurs="0">
        <xs:annotation>
          <xs:documentation>Symmetric key wrap encryption method based upon DES3 with 192 bit key. Used for encrypting symmetric keys</xs:documentation>
        </xs:annotation>
      </xs:element>
      <xs:element name="aes128Kw" type="wssec:EmptyType" minOccurs="0">
        <xs:annotation>
          <xs:documentation>Symmetric key wrap encryption method based upon AES with 128 bit key. Used for encrypting symmetric keys</xs:documentation>
        </xs:annotation>
      </xs:element>
      <xs:element name="aes192Kw" type="wssec:EmptyType" minOccurs="0">
        <xs:annotation>
          <xs:documentation>Symmetric key wrap encryption method based upon AES with 192 bit key. Used for encrypting symmetric keys</xs:documentation>
        </xs:annotation>
      </xs:element>
      <xs:element name="aes256Kw" type="wssec:EmptyType" minOccurs="0">
        <xs:annotation>
          <xs:documentation>Symmetric key wrap encryption method based upon AES with 256 bit key. Used for encrypting symmetric keys</xs:documentation>
        </xs:annotation>
      </xs:element>
    </xs:all>
  </xs:complexType>
  <xs:complexType name="KeyEncryptionGenerationMethodType">
    <xs:annotation>
      <xs:documentation>What encryption methods will we use when encrypting</xs:documentation>
      <xs:appinfo>
        If tokenType == x509 based then default to "rsaOaep" methods
        If tokenType == symmetric based then default to "aes256Kw" method.
      </xs:appinfo>
    </xs:annotation>
    <xs:attribute name="method" type="wssec:KeyEncryptionGenerationMethod" use="optional">
      <!-- constraint: SHOULD be present when tokenType is x509 or symmetric -->
      <!-- constraint: MUST be absent when tokenType is username because that implies key derivation method being used to generate the 
                       symmetric key being used 
      -->
    </xs:attribute>
    <xs:attribute name="rsaOaepDigestMethod" type="wssec:DigestGenerationMethod" use="optional" default="sha1">
      <!-- constraint: This attribute may only be present if the "method" attribute is equal to "rsaOaep" -->
    </xs:attribute>
    <xs:attribute name="generateRsaOaepString" type="xs:boolean" use="optional">
      <xs:annotation>
        <xs:documentation>
          Application specified that an optional random RSA-OAEP string is to be generated and utilized. Default is a null string.
          Used to add additional randomness by an application. This is normally only utilized when RSA-OAEP is being used to
          encrypt a small amount of non-random data, i.e., not a randomly generated symmetric key.
           
          This optional random string will be package within the encryption header.
        </xs:documentation>
      </xs:annotation>
      <!-- constraint: This attribute should only be present if the "method" attribute is equal to "rsaOaep" -->
    </xs:attribute>
  </xs:complexType>
  <xs:simpleType name="KeyEncryptionGenerationMethod">
    <xs:restriction base="xs:string">
      <xs:enumeration value="rsaV1.5">
        <xs:annotation>
          <xs:documentation>Key transport encryption method based upon RSA v1.5. Used for encrypting symmetric key</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="rsaOaep">
        <xs:annotation>
          <xs:documentation>Key transport encryption method based upon RSA-OAEP key. Used for encrypting symmetric key</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="des3Kw">
        <xs:annotation>
          <xs:documentation>Symmetric key wrap encryption method based upon DES3 with 192 bit key. Used for encrypting symmetric keys</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="aes128Kw">
        <xs:annotation>
          <xs:documentation>Symmetric key wrap encryption method based upon AES with 128 bit key. Used for encrypting symmetric keys</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="aes192Kw">
        <xs:annotation>
          <xs:documentation>Symmetric key wrap encryption method based upon AES with 192 bit key. Used for encrypting symmetric keys</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="aes256Kw">
        <xs:annotation>
          <xs:documentation>Symmetric key wrap encryption method based upon AES with 256 bit key. Used for encrypting symmetric keys</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
    </xs:restriction>
    <!-- constraint: if tokenType == x509 based then "rsaV1.5" and "rsaOaep" methods allowed -->
    <!-- constraint: if tokenType == symmetric based then des3kw, aes128kw, aes192Kw and aes256Kw allowed. -->
  </xs:simpleType>
  <xs:simpleType name="ResolveFrom">
    <xs:annotation>
      <xs:documentation>Where should the security token be resolve from.</xs:documentation>
    </xs:annotation>
    <xs:restriction base="xs:string">
      <xs:enumeration value="static">
        <xs:annotation>
          <xs:documentation>security token must be resolved from target security config file.</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="incoming-message">
        <xs:annotation>
          <xs:documentation>security token must be resolved from the incoming SOAP message.</xs:documentation>
        </xs:annotation>
        <!-- For all the different types of tokens: X509, username or symmetric, there is a primitive and derived formats.
             For X509, the primitive type are X509 certificate and public key value. Derived types are subject DN, SKIs, 
             thumbprints, issuer-serial number, etc.
             For username, the primitive type is PasswordText format. Derived types are PasswordDigest and key derivation formats.
             For symmetric, the primitive type is KeyValue (do not support). Derived types are KeyName and KeyIdentifier.
        -->
        <!-- constraint:
               switch (use) {
               case sign:
               case encrypt:
                   incoming-message not allowed;
                   break;
               case verify:
                   switch (TokenType) {
                   case X509:
                       incoming-message allowed because sender could be using KeyInfor == X509 certificate;
                       if sender uses any other type of KeyInfo then request processing will fail;
                       break ;
                   case username:
                       incoming-message allowed because sender could be using KeyInfor == PasswordText;
                       if sender uses any other type of KeyInfo then request processing will fail;
                       break ;
                   case symmetric:
                       incoming-message not allowed ;
                   }
                   break;
               case decrypt:
                   switch (TokenType) {
                   case X509:
                       incoming-message not allowed because we have to retrieve private key that is not in incoming message;
                       break ;
                   case username:
                       incoming-message not allowed because only key derivation format ==> password not present in incoming message;
                       break ;
                   case symmetric:
                       incoming-message not allowed because only KeyName or KeyIdentifier allowed ==> no secret in incoming message;
                   }
                   break;
               }
        -->
      </xs:enumeration>
      <xs:enumeration value="dynamic">
        <xs:annotation>
          <xs:documentation>security token must be resolved from local keystore or external name resolution.</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <!-- not supported in current release -->
    </xs:restriction>
  </xs:simpleType>
  <xs:simpleType name="HmacOutputLength">
    <xs:annotation>
      <xs:documentation>
        Output length of HMAC signature allowed. 
        This attribute is only valid for HMAC based signature methods.
        It must be a multiple of 8 and less than or equal to the maximum output length of the digest type:
        MD5: 128 bits, SHA1: 160 bits, SHA256: 256 bits, SHA384: 384 bits, SHA512: 512 bits.
        
        If an output length is to small, it is possible for an attacker to make a finite brute force attack. 
      </xs:documentation>
      <!-- constraint: must be multiple of 8 and less than or equal to maximum output length of digestGenerationMethod specified. -->
    </xs:annotation>
    <xs:restriction base="xs:unsignedShort">
      <xs:minInclusive value="16"/>
      <xs:maxInclusive value="512"/>
    </xs:restriction>
  </xs:simpleType>
  <xs:simpleType name="Arc4KeySize">
    <xs:annotation>
      <xs:documentation>
        Key size in bits of associated ARC4 stream encryption 
        This attribute is only valid for ARC4 based encryption methods.
        It must be a multiple of 8. 
      </xs:documentation>
    </xs:annotation>
    <xs:restriction base="xs:unsignedShort">
      <xs:minInclusive value="40"/>
      <xs:maxInclusive value="2048"/>
    </xs:restriction>
  </xs:simpleType>
  <xs:complexType name="CreateUsernameToken">
    <xs:annotation>
      <xs:documentation>Create a WS-Security security token.</xs:documentation>
    </xs:annotation>
    <xs:sequence>
      <xs:element name="keyFormat">
        <xs:complexType>
          <xs:choice>
            <xs:element name="passwordText" type="wssec:EmptyType" nillable="true">
              <xs:annotation>
                <xs:documentation>
                  Password is in plain text. If confidentiality is require then either separate WS-Security encryption
                  of username security token, or transport layer security, e.g., SSL/TLS.
                </xs:documentation>
              </xs:annotation>
            </xs:element>
            <xs:element name="passwordDigest" type="wssec:EmptyType" nillable="true">
              <xs:annotation>
                <xs:documentation>
                   Password embedded into digest value based upon: SHA1([nonce |] [creationTime |] password) 
                </xs:documentation>
              </xs:annotation>
            </xs:element>
            <xs:element name="keyDerivation">
              <xs:annotation>
                <xs:documentation>Only username in token plus information need to derive key using password</xs:documentation>
              </xs:annotation>
              <xs:complexType>
                <xs:all>
                  <xs:element name="numberOfIterations" default="1000">
                    <xs:annotation>
                      <xs:documentation>Higher number increases cost to attacker.</xs:documentation>
                    </xs:annotation>
                    <xs:simpleType>
                      <xs:restriction base="xs:short">
                        <xs:minInclusive value="1"/>
                        <xs:maxExclusive value="20000"/>
                      </xs:restriction>
                    </xs:simpleType>
                  </xs:element>
                </xs:all>
              </xs:complexType>
            </xs:element>
            <xs:element name="none" type="wssec:EmptyType" nillable="true">
              <xs:annotation>
                <xs:documentation>
                  Indicates that no password element is to be populated in the username token being created.
                  A username token without a password element is very unusual. This type of token is normally only
                  utilized as part of the generation of a WS-Trust request where it is used to identify the intented
                  requester in a OnBehalfOf element or for the source in the client authentication method.
                </xs:documentation>
              </xs:annotation>
            </xs:element>
          </xs:choice>
        </xs:complexType>
      </xs:element>
      <xs:element name="usernamePasswordSource" type="wssec:UsernameSecurityToken"/>
      <xs:element name="wsuIdPrefix" type="wssec:IdPrefix" default="str_" minOccurs="0">
        <xs:annotation>
          <xs:documentation>
            We create security token with a unique wsu:Id which that consists of a prefix-uuid.
            Applications can change the prefix to make it simplier to find a specific reference when multiple security
            tokens are present. A simple XPath expression using a start with or contains this prefix can be used to find the 
            desired security token.
          </xs:documentation>
        </xs:annotation>
      </xs:element>
    </xs:sequence>
    <xs:attribute name="generateNonce" type="xs:boolean" default="true"/>
    <xs:attribute name="generateCreationTime" type="xs:boolean" default="true"/>
  </xs:complexType>
  <xs:complexType name="UsernameSecurityToken">
    <xs:annotation>
      <xs:documentation/>
    </xs:annotation>
    <xs:sequence>
      <xs:choice>
        <xs:element name="security-config-package">
          <xs:annotation>
            <xs:documentation>
              Using username security object defined in application related security config package.
              This allows application to hardcore the username token to be created.
            </xs:documentation>
          </xs:annotation>
          <!-- contraint: name specified must match abstract handle defined in associated security package.
                          Also the type of the security object in the security package and within the Ws-Security policy must match
          -->
          <xs:simpleType>
            <xs:restriction base="xs:NMTOKEN">
              <xs:minLength value="1"/>
              <xs:maxLength value="160"/>
            </xs:restriction>
          </xs:simpleType>
        </xs:element>
        <xs:element name="usernamePasswordFromWorkflow" type="wssec:EmptyType">
          <!-- constraint: 1) If (keyformat == (passwordText | passwordDigest | keyDerivation) then service designer must prompt 
                              developer to identify both:
                              a) username, and 
                              b) passwood 
                              from current workflow variables when this WS-Security policy is bound to a workflow action. 
                           2) If (keyformat == none) then service designer must prompt developer to identify only:
                              a) username
                              from current workflow variables when this WS-Security policy is bound to a workflow action. 
          -->
          <!-- Associated action builder is required to bind these identified variables to the extension functions requirng them as input. -->
        </xs:element>
        <xs:element name="keystore" type="wssec:KeystoreSearchType">
          <xs:annotation>
            <xs:documentation>
              Use keystore to map from workflow supplied source identity to .
            </xs:documentation>
          </xs:annotation>
          <!-- constraint: service designer must prompt developer to identify:
                           1) source identity string 
                           from current workflow variable when this WS-Security policy is bound to a workflow action. 
          -->
          <!-- Associated action builder is required to bind these identified variables to the extension functions requirng them as input. -->
          <!-- constraint: NOT ALLOWED if ((keyformat == none) AND (keystore search type == username)) -->
        </xs:element>
        <xs:element name="ldap" type="wssec:LdapSearchRequest">
          <!-- constraint: NOT ALLOWED/PRESENT if (keyformat == none) -->
        </xs:element>
        <xs:element name="localSqlDatabase" type="wssec:LocalSqlDatabase"/>
      </xs:choice>
    </xs:sequence>
  </xs:complexType>
  <xs:complexType name="CreateKerberosToken">
    <xs:annotation>
      <xs:documentation>Create standalone Kerberos token</xs:documentation>
    </xs:annotation>
    <xs:sequence>
      <xs:choice minOccurs="0">
        <xs:annotation>
          <xs:documentation>This choice element used to supply client information to go into Kerberos token.</xs:documentation>
        </xs:annotation>
        <!-- contraint: NOT PRESENT if (requestType == S4UToProxy) -->
        <xs:element name="fromKeytab">
          <xs:complexType>
            <xs:sequence>
              <xs:element name="clientPrincipal" type="wssec:KerberosPrincipalType">
                <xs:annotation>
                  <xs:documentation>
                    Kerberos Client Principal: Identify the entity for whom the Kerberos ticket is being obtained.
                    Usually either a user or a host.
                  </xs:documentation>
                </xs:annotation>
                <!-- constraint: the realm component of the clientPrincipal and serverPrincipal must be the same. 
                                 Note: all principal names are composted of three part: primary/instance@realm.
                                       where the instance component is optional. 
                -->
              </xs:element>
              <xs:element name="clientKeytab">
                <xs:annotation>
                  <xs:documentation>
                    This Kerberos Keytab file contains the keys needed to decrypt a Kerberos ticket returned by a Kerberos Key Distribution 
                    Center (KDC) for the client.
                  </xs:documentation>
                </xs:annotation>
                <!-- contraint: name specified must match abstract handle defined in associated security package.
                                Also the type of the security object in the security package and within the Ws-Security policy must match
                -->
                <xs:simpleType>
                  <xs:restriction base="xs:NMTOKEN">
                    <xs:minLength value="1"/>
                    <xs:maxLength value="160"/>
                  </xs:restriction>
                </xs:simpleType>
              </xs:element>
            </xs:sequence>
          </xs:complexType>
        </xs:element>
        <xs:element name="principleRealmFromWorkflow" type="wssec:EmptyType">
          <!-- constraint: 1) Service Designer Action Builder MUST prompt application developer when policy is bound to action.
                              Note: string containing both the principal name and realm.
                           2) ONLY ALLOWED if (requestType == S4UToSelf)
          -->
        </xs:element>
        <xs:element name="certificateFromSecurityConfig">
          <xs:annotation>
            <xs:documentation>Using X509 certifcate security object defined in application related security config package</xs:documentation>
          </xs:annotation>
          <!-- contraint: 1) name specified must match abstract handle defined in associated security package.
                             Also the type of the security object in the security package and within the Ws-Security policy must match
                          2) ONLY ALLOWED if (requestType == S4UToSelf)
          -->
          <xs:simpleType>
            <xs:restriction base="xs:NMTOKEN">
              <xs:minLength value="1"/>
              <xs:maxLength value="160"/>
            </xs:restriction>
          </xs:simpleType>
        </xs:element>
        <xs:element name="certificateFromWorkflow" type="wssec:EmptyType">
          <xs:annotation>
            <xs:documentation>
              Application is supplying and X.509 certifcate from their workflow.
              Certificate could be: 1) a PEM encoded
                                    2) base64 encode DER certificate
                                    3) base64 encoded PKCS12 bag containing certificate
            </xs:documentation>
          </xs:annotation>
          <!-- constraint: 1) Service Designer Action Builder MUST prompt application developer when policy is bound to action 
                           2) ONLY ALLOWED if (requestType == S4UToSelf)
          -->
        </xs:element>
      </xs:choice>
      <xs:element name="serverPrincipal" type="wssec:KerberosPrincipalType" minOccurs="0">
        <xs:annotation>
          <xs:documentation>
            Kerberos Server Principal: Identify the entity from whom a service is being requested.
          </xs:documentation>
          <xs:appinfo>
            If (requestType == S4UToSelf) then this infomration is defined as part of the keytab security config object.
          </xs:appinfo>
        </xs:annotation>
        <!-- constraint: MUST be POPULATED if (requestType == (SimpleKerberosToken OR S4UToProxy)) -->
      </xs:element>
      <xs:element name="requestType" default="SimpleKerberosToken" minOccurs="0">
        <xs:annotation>
          <xs:documentation>Identifies what type of Kerberos Token request is to be generated.</xs:documentation>
        </xs:annotation>
        <xs:simpleType>
          <xs:restriction base="xs:string">
            <xs:enumeration value="SimpleKerberosToken">
              <xs:annotation>
                <xs:documentation>Normal Kerberos token usage: meets offical standard definition.</xs:documentation>
              </xs:annotation>
            </xs:enumeration>
            <xs:enumeration value="S4UToSelf">
              <xs:annotation>
                <xs:documentation>MicroSoft S4U request for identifying SELF.</xs:documentation>
              </xs:annotation>
            </xs:enumeration>
            <xs:enumeration value="S4UToProxy">
              <xs:annotation>
                <xs:documentation>MicroSoft S4U request for identifying Proxy usage.</xs:documentation>
                <!-- constraint: Service Designer Action Builder MUST prompt for S4U self service ticket from 
                                 application developer when policy is bound to an action.
                                 String for prompt and name/value pair should be: Self_Service_Ticket
                -->
                <xs:appinfo>
                  We will be getting the client principle name and realm from the S4U Self service ticket to
                  be package into the S4U Proxy KDC request.
                </xs:appinfo>
              </xs:annotation>
            </xs:enumeration>
          </xs:restriction>
        </xs:simpleType>
      </xs:element>
      <xs:element name="forwardableTicket" type="xs:boolean" default="false" minOccurs="0">
        <!-- constraint: ONLY PRESENT if (requestType == S4UToSelf) -->
      </xs:element>
      <xs:element name="kerberosTokenType" type="wssec:KerberosTokenType" default="GSS-API_Kerberosv5_AP_REQ-1.1"/>
      <xs:element name="spnegoEncapsulate" type="xs:boolean" default="true" minOccurs="0">
        <!-- constraint: 1) ONLY PRESENT if (REST-Security create Kerberos policy) 
                         2) ERROR "When SPNEGO encapsualtion being applied then Kerberos Token Type must be some form "
                                  "of GSS-API_Kerberosv5_AP_REQ"
                            if ((spengoEncapsulate == true) &&
                                ((kerberosTokenType == Kerberosv5_AP_REQ-1.1) OR 
                                 (kerberosTokenType == Kerberosv5_AP_REQ1510-1.1) OR
                                 (kerberosTokenType == Kerberosv5_AP_REQ4120-1.1) OR
                                 (kerberosTokenType == Kerberosv5_AP_REQ-1.0)
                                )
                               )
        -->
      </xs:element>
      <xs:element name="maximumWaitTime" default="300" minOccurs="0">
        <xs:annotation>
          <xs:documentation>
            Maximum lifetime of that the generated Kerberos ticket should have.
            Was originally intended to be the Maximum length of time that we should wait for a response from KDC.
          </xs:documentation>
          <xs:appinfo>unit: seconds</xs:appinfo>
        </xs:annotation>
        <xs:simpleType>
          <xs:restriction base="xs:unsignedInt">
            <xs:minInclusive value="2"/>
            <xs:maxInclusive value="7200"/>
          </xs:restriction>
        </xs:simpleType>
      </xs:element>
      <xs:element name="wsuIdPrefix" type="wssec:IdPrefix" default="str_" minOccurs="0">
        <xs:annotation>
          <xs:documentation>
            We create security token with a unique wsu:Id which that consists of a prefix-uuid.
            Applications can change the prefix to make it simplier to find a specific reference when multiple security
            tokens are present. A simple XPath expression using a startwith or contains can be used to find the 
            desired security token.
          </xs:documentation>
        </xs:annotation>
      </xs:element>
      <xs:element name="serverUrl" type="xs:anyURI" minOccurs="0">
        <xs:annotation>
          <xs:documentation>
            Allows WS-Security Policy writer to bind Kerberos KDC IA to a specific backend server.
            This is very useful when automatically using the same AAA policy in multiple places so that they are all bound to
            same Kerberos KDC IA.
          </xs:documentation>
          <xs:appinfo>
            The server URL consists of the following logical sub-entities:
            1) IP-address/host name of the Kerberos KDC.
            2) port number of the Kerberos KDC, default: 88.
          </xs:appinfo>
        </xs:annotation>
      </xs:element>
      <!-- constraint:  
            Following constraints based upon the assumption that the client and server must always be part of the same realm.
            In general, this appears to be a valid assumption. 
            However, it is possible if we support some form of transited processing for this to change in the future.
            Not clear who will be able to check the following constraints.
            1) if client fromKeytab then the realm of the client principal name and server principal name should be the same.
            2) if client fromWorkflow then the realm embedded within the postFix string and the server principal name should be the same.
      -->
    </xs:sequence>
  </xs:complexType>
  <xs:simpleType name="KerberosTokenType">
    <xs:annotation>
      <xs:documentation>Type of Kerberos Token to be generated.</xs:documentation>
    </xs:annotation>
    <xs:restriction base="xs:string">
      <xs:enumeration value="GSS-API_Kerberosv5_AP_REQ-1.1">
        <xs:annotation>
          <xs:documentation>
            WS-Security Kerberos Token Version 1.1: A GSS-API Kerberos V5 mechanism token containing an KRB_AP_REQ message as 
            defined in RFC-1964 [1964], Sec. 1.1 and its successor RFC-4121 [4121], Sec. 4.1. This ValueType is used when the 
            ticket is an AP Request (ST + Authenticator).
            Made this the default because the draft version of the WS-Security Kerberos Profile makes this recommended to improve inter-op.
          </xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="Kerberosv5_AP_REQ-1.1">
        <xs:annotation>
          <xs:documentation>
            WS-Security Kerberos Token Version 1.1: Kerberos v5 AP-REQ. This ValueType is used when the ticket is an AP Request.
          </xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="GSS-API_Kerberosv5_AP_REQ1510-1.1">
        <xs:annotation>
          <xs:documentation>
            WS-Security Kerberos Token Version 1.1: A GSS-API Kerberos V5 mechanism token containing an KRB_AP_REQ message as defined 
            in RFC-1964, Sec. 1.1 and its successor RFC-4121, Sec. 4.1. This ValueType is used when the ticket is an AP Request (
            ST + Authenticator) per RFC1510.
            Is not a validation error if unknown type of authorization options present.
            Transited-policy-checked and ok-as-delegate ticket flags not valid.
          </xs:documentation>
        </xs:annotation>
        <!-- constraint: Should not be supported at this time because Java Third party library and backend KDC does not support 1510 semantics, i.e., ok_as_delagate and transited_policy_check -->
      </xs:enumeration>
      <xs:enumeration value="Kerberosv5_AP_REQ1510-1.1">
        <xs:annotation>
          <xs:documentation>
            WS-Security Kerberos Token Version 1.1: Kerberos v5 AP-REQ as defined in RFC1510. This ValueType is used when the 
            ticket is an AP Request per RFC1510. 
            Is not a validation error if unknown type of authorization options present.
            Transited-policy-checked and ok-as-delegate ticket flags not valid.
          </xs:documentation>
        </xs:annotation>
        <!-- constraint: Should not be supported at this time because Java Third party library and backend KDC does not support 1510 semantics, i.e., ok_as_delagate and transited_policy_check -->
      </xs:enumeration>
      <xs:enumeration value="GSS-API_Kerberosv5_AP_REQ4120-1.1">
        <xs:annotation>
          <xs:documentation>
            WS-Security Kerberos Token Version 1.1: A GSS-API Kerberos V5 mechanism token containing an KRB_AP_REQ message as defined 
            in RFC-1964, Sec. 1.1 and its successor RFC-4121, Sec. 4.1. This ValueType is used when the ticket is an AP Request 
            (ST + Authenticator) per RFC4120.
            Is not a validation error if unknown type of authorization options present.
          </xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="Kerberosv5_AP_REQ4120-1.1">
        <xs:annotation>
          <xs:documentation>
            WS-Security Kerberos Token Version 1.1: Kerberos v5 AP-REQ as defined in RFC4120. This ValueType is used when the ticket 
            is an AP Request per RFC4120.
            Is an validation error if unknown type of authorization options present.
          </xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="Kerberosv5_AP_REQ-1.0">
        <xs:annotation>
          <xs:documentation>
            WS-Security Kerberos Token Version 1.0: Kerberos v5 AP-REQ. This ValueType is used when the ticket is an AP Request.
            Note: its ValueType is http://www.docs.oasis-open.org/wss/2004/07/oasis-000000-wss-kerberos-token-profile-1.0#Kerberosv5_AP_REQ
            which is different then what V1.1 uses.
          </xs:documentation>
        </xs:annotation>
        <!-- constraint: Should not be supported at this time because Java Third party library and backend KDC does not support v.0 semantics -->
      </xs:enumeration>
    </xs:restriction>
  </xs:simpleType>
  <xs:simpleType name="KerberosPrincipalType">
    <xs:restriction base="xs:string">
      <xs:pattern value="[a-zA-Z0-9_@/\.]*"/>
    </xs:restriction>
  </xs:simpleType>
  <xs:complexType name="PackageBST">
    <xs:annotation>
      <xs:documentation>Package an existing token into a Binary Security Token (BST)</xs:documentation>
    </xs:annotation>
    <xs:sequence>
      <xs:element name="bstType">
        <xs:simpleType>
          <xs:union memberTypes="wssec:KerberosTokenType">
            <xs:simpleType>
              <xs:restriction base="xs:string">
                <xs:enumeration value="X509v3">
                  <xs:annotation>
                    <xs:documentation>
                      X.509 v3 certificate: 
                      URI: http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-x509-token-profile-1.0#X509v3
                    </xs:documentation>
                  </xs:annotation>
                </xs:enumeration>
                <!-- deferred
                <xs:enumeration value="X509PKIPathv1">
                  <xs:annotation>
                    <xs:documentation>
                      X.509v3 Certificate Path
                      URI: http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-x509-token-profile-1.0#X509PKIPathv1
                    </xs:documentation>
                  </xs:annotation>
                </xs:enumeration>
                <xs:enumeration value="PKCS7">
                  <xs:annotation>
                    <xs:documentation>
                      PKCS7 bag of X.509v3 certificates
                      URI: http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-x509-token-profile-1.0#PKCS7
                    </xs:documentation>
                  </xs:annotation>
                </xs:enumeration>
                <xs:enumeration value="LTPA">
                  <xs:annotation>
                    <xs:documentation>
                      Lightweight Third-Party Authentication (LTPA)
                      An authentication technology used in IBM WebSphere and Lotus Domino products. 
                      With the use of LTPA, it is possible for a web user to re-use their login across physical servers.
                      When the user has been authenticated, their browser will have received a session cookie that is only available 
                      for one browsing session. This cookie contains the LTPA token.
                    </xs:documentation>
                  </xs:annotation>
                </xs:enumeration>
                -->
              </xs:restriction>
            </xs:simpleType>
          </xs:union>
        </xs:simpleType>
      </xs:element>
      <xs:choice>
        <xs:element name="security-config-package">
          <xs:annotation>
            <xs:documentation>
              Using PKI security object (X.509 certificate or CA Path) defined in application related security config package.
              This allows application to hardcore the binary security token to be created.
            </xs:documentation>
          </xs:annotation>
          <!-- contraint: 
                1) if (bstType == X509v3) then name specified must match abstract handle defined in associated security package for 
                   a X.509 certificate object.
                2) if (bstType == X509PKIPathv1) then name specified must match abstract handle defined in associated security package for 
                   a Certificate Authority (CA) Path object.
                3) NOT ALLOWED/PRESENT if (bstType != (X509v3 | X509PKIPathv1))
          -->
          <xs:simpleType>
            <xs:restriction base="xs:NMTOKEN">
              <xs:minLength value="1"/>
              <xs:maxLength value="160"/>
            </xs:restriction>
          </xs:simpleType>
        </xs:element>
        <xs:element name="bstFromWorkflow" type="wssec:EmptyType">
          <!-- constraint: Service Designer action builder must prompt developer for based64 encoded security token -->
          <!-- Associated action builder is required to bind these identified variables to the extension functions requirng them as input. -->
        </xs:element>
        <xs:element name="bstFromVerifyOperation" type="wssec:EmptyType">
          <xs:annotation>
            <xs:documentation>X.509 certificate from preceding successful signature verification operation.</xs:documentation>
            <xs:appinfo>
              Service Designer action builder must prompt application developer to identity the WS-Security policy whose should be 
              exporting their resolved X.509 certificate (PKC) when this policy is bound to an action.
            </xs:appinfo>
          </xs:annotation>
          <!-- constraint: ONLY ALLOWED/PRESENT if (bstType == (X509v3 [| any Kerberos type]))
          -->
        </xs:element>
        <xs:element name="keystore" type="wssec:KeystoreSearchType">
          <xs:annotation>
            <xs:documentation>
              Use keystore to map from workflow supplied source identity to X509 v3 certificate.
            </xs:documentation>
          </xs:annotation>
          <!-- constraint: service designer must prompt developer to identify:
                           1) source identity string 
                           from current workflow variable when this WS-Security policy is bound to a workflow action. 
          -->
          <!-- Associated action builder is required to bind these identified variables to the extension functions requirng them as input. -->
          <!-- constraint: ONLY ALLOWED/PRESENT if ((bstType == X509v3) AND (keystoreSearchtype != full certificate)) -->
        </xs:element>
        <xs:element name="ldap" type="wssec:LdapSearchRequest">
          <!-- constraint: ONLY ALLOWED/PRESENT if (bstType == (X509v3 | X509PKIPathv1 | PKCS7)) -->
        </xs:element>
      </xs:choice>
    </xs:sequence>
  </xs:complexType>
  <xs:complexType name="CreateSamlAssertion">
    <xs:annotation>
      <xs:documentation>Defined everyting required for us to generate a SAML Assertion.</xs:documentation>
    </xs:annotation>
    <xs:sequence>
      <xs:element name="assertionInfo" type="wssec:SourceAssertionInfo"/>
      <xs:element name="signatureInfo" minOccurs="0">
        <xs:annotation>
          <xs:documentation>
            If present then contains information required to generate enveloped signature over entire SAML assertion.
            SAML standard only supported signature using X.509 certificate ro public key. Therefore, most of the normal signature
            parametrization is not needed/not present here.
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:sequence>
            <xs:element name="signatureGenerationMethod" type="wssec:SamlSignatureGenerationMethod" default="rsaWithSha1">
              <xs:annotation>
                <xs:documentation>What signature method will be use when generating a SAML assertion signature</xs:documentation>
              </xs:annotation>
            </xs:element>
            <xs:element name="digestGenerationMethod" type="wssec:DigestGenerationMethod" default="sha1">
              <xs:annotation>
                <xs:documentation>What digest method will we use when generating a SAML assertion signature</xs:documentation>
              </xs:annotation>
            </xs:element>
            <xs:element name="canonicalGenerationMethod" type="wssec:SamlCanonicalGenerationMethod" default="C14N_exclusive">
              <xs:annotation>
                <xs:documentation>What canonicalization method will we use when generating a SAML assertion signature</xs:documentation>
              </xs:annotation>
            </xs:element>
            <xs:element name="samlKeyInfo" type="wssec:SamlKeyInfo" minOccurs="0">
              <xs:annotation>
                <xs:documentation>Identifies the type of KeyInfo subelements that should be generated.</xs:documentation>
                <xs:appinfo>If not populated then should default to only certificate being populated.</xs:appinfo>
              </xs:annotation>
            </xs:element>
            <xs:element name="keyPair" type="wssec:SecurityToken">
              <xs:annotation>
                <xs:documentation>
                  Name of an asymmetricKeyPair element. Resolution based upon value of associated "use" attribute.
                  This asymmetricKeyPair element identifies either a RSA or DSA public/private key pair. The public key is usually package 
                  within an X.509 certificate. The private key and associated certificate can be package in the same file or in separate files.
                  Depending upon the type of PKI encoding being used, the full Certificate Authority path from the leaf certificate upto the root
                  Certification Authority can also be included within the actual file. When this occurs, the following caPAth element is not 
                  required to be specified.
                  
                  This element is used to populate the near-end private key, near-end certificate [and CA Path] for signature generation and decryption.
                  For signature generation, the near-end private key is used in the actual cryptographic operation. 
                  For signature generation, the near-end certificate and caPath may be package into the keyinfo of the actual message being send 
                  because we will assume keyInfo format=Certificate. 
                  For signature generation, any CA Path certificates that are present in the specified x509KeyPair will not be utilized in this release.
                  Only explicitly defined caPath certificates will be supported.
                </xs:documentation>
              </xs:annotation>
              <!-- constraint: 
                    1) Only ALLOW security token resolution mechanism == security-config-package
                    2) NOT PRESENT security token resolution mechanism == (keystore || ldap || localSqlDatabase || securityTokenFromWorkflow)
                       Note: we could support with some work securityTokenFromWorkflow. Other mechanisms would be a lot more work.
              -->
            </xs:element>
            <xs:element name="caPath" type="wssec:SecurityToken" minOccurs="0">
              <xs:annotation>
                <xs:documentation>
                  Name of a caPath element. Resolution based upon value of associated "use" attribute.
                  This element identifies a list of untrusted Certificate Authorities.
                  It can be specified in two possible formats (See "Web Services Security X.509 Certificate Token Profile 1.1 OASIS Standard
                  Specification, 1 February 2006" for details.
                  1) one or more PEM format Certificate Authorities certificates concatenated in the same physical file. The order of certificates is 
                  such that the subject of the first certificate is the issuer of the second certificate, etc. Additionally, the certificate path 
                  excludes the end-entity certficate. This format is implied by a BinarySecurityToken with its attribute ValueType"#X509PKIPathv1".
                  See ITU-T Rec.X.509 (2000)/Cor.1 (10/2001 E) for details.
                  2) PKCS7 bag. This format is implied by a BinarySecurityToken with its attribute ValueType="#PKCS7".
                  
                  In signature generation, this caPath should be physically packaged within the actual message being sent.
                  
                  In signature verification, the caPath is utilized in checkTrust to supply missing immediate Certificate Authorities certificates
                  between the far-end certificate and a CA certificate within the trustedCaGroup of CA certificates. The source of the CA Path 
                  certifcates is identified via the associated "use" attribute.
                </xs:documentation>
              </xs:annotation>
              <!-- constraint: 
                    1) Only ALLOW security token resolution mechanism == security-config-package
                    2) NOT PRESENT security token resolution mechanism == (keystore || ldap || localSqlDatabase || securityTokenFromWorkflow)
                       Note: we could support with some work securityTokenFromWorkflow. Other mechanisms would be a lot more work.
              -->
            </xs:element>
          </xs:sequence>
        </xs:complexType>
      </xs:element>
      <xs:element name="encryptionInfo" minOccurs="0">
        <xs:annotation>
          <xs:documentation>
            Contains the following type of information:
            1) Acceptable methods, etc.
            2) Identifies the X.509 key pair or symmetric secret to be utilized.
            
            All SAML encrypted entities: EncryptedID, EncryptedAssertion and EncryptedAttribute, consist of an EncryptedData 
            element and an optional EncryptedKey element.
            When an EncryptedKey element is used, the KeyInfo element within EncryptedData SHOULD reference the
            EncryptedKey element using a RetrievalMethod element of Type http://www.w3.org/2001/04/xmlenc#EncryptedKey.
            When the encrypted element is being multicast to multiple recipients, and the key used to encrypt the message must
            be in turn encrypted individually and independently for each of the multiple recipients, the CarriedKeyName element 
            SHOULD be used to assign a common name to each of the EncryptedKey elements so that a KeyName can be
            used from within the EncryptedData elements KeyInfo element.            
            
            Note: the operational code will automatically map different targetElements to the appropriate type SAML encryption
            entity: EncryptedID, EncryptedAssertion, EncryptedAttribute based upon a application specified flag associated with
            the associated explicit entity: NameID/BaseID, Attribute or Assertion.
          </xs:documentation>
        </xs:annotation>
        <!-- contraint: only available when SAML Version is 2.0 -->
        <xs:complexType>
          <xs:sequence>
            <xs:element name="generateDataEncryptionMethod">
              <xs:simpleType>
                <xs:restriction base="xs:string">
                  <xs:enumeration value="aes128"/>
                  <xs:enumeration value="aes192"/>
                  <xs:enumeration value="aes256"/>
                  <xs:enumeration value="aes128Gcm"/>
                  <xs:enumeration value="aes192Gcm"/>
                  <xs:enumeration value="aes256Gcm"/>
                  <xs:enumeration value="des3"/>
                  <xs:enumeration value="arc4"/>
                </xs:restriction>
              </xs:simpleType>
            </xs:element>
            <xs:element name="encryptKeyInfo" type="wssec:EncryptSamlKeyInfoType"/>
          </xs:sequence>
        </xs:complexType>
      </xs:element>
      <xs:element name="outputBindingInfo" type="wssec:OutputBindingInfo" minOccurs="0">
        <!-- constraint: 1) REQUIRED if (bindingType == REST) 
                         2) if (bindingType == SOAP) then outputBindingInfo exportDestination MUST be to-WS-Security-header
        -->
      </xs:element>
    </xs:sequence>
  </xs:complexType>
  <xs:complexType name="SamlKeyInfo">
    <xs:all>
      <xs:annotation>
        <xs:appinfo>Default certificate to be enabled.</xs:appinfo>
        <xs:documentation>
          Certificate is the most secure form of KeyINfo because there is no confusion about what is the correct certificate to
          be used for validating the signature and performing chain-of-trust processing.
          After Certificate in decreasing robustness are:
          1) thumbprintSha1: this form captures information from the full certificate. However, in future SHA1 will not be secure from 
             collusion attacks as was done with MD5.
          2) subjectname: Less secure because some user by mistake have multiple certificates using the same name causing problem
             mapping attribute to actual certificate.
          3) keyname: old form of using certificate subject name that has a number of known inter-working issues.
          4) ski: Less secure because SHA1 is only over public key value. A number of conditions have caused users to create 
             certificates with the same values.
          5) rsaKeyValue: A multiple value form of subject key identifier, SKI, that does not support simple resolution/mapping to 
             actual certifciate for chain-of-trust processing.
        </xs:documentation>
      </xs:annotation>
      <xs:element name="certificate" type="wssec:EmptyType" minOccurs="0">
        <!-- constraint: WARNING "Not populating SAML assertion signature with full certificate will require special setup on
                                  consuming system to map certificate attribute to certificate for chain-of-trust processing"
                         if (certificate is NOT enabled)
        -->
      </xs:element>
      <xs:element name="subjectName" type="wssec:EmptyType" minOccurs="0"/>
      <xs:element name="ski" type="wssec:EmptyType" minOccurs="0"/>
      <xs:element name="thumbprintSha1" type="wssec:EmptyType" minOccurs="0"/>
      <xs:element name="rsaKeyValue" type="wssec:EmptyType" minOccurs="0"/>
      <xs:element name="keyName" type="wssec:EmptyType" minOccurs="0"/>
      <!-- constraint: One or more SamlKeyInfo must be enabled. -->
    </xs:all>
  </xs:complexType>
  <xs:complexType name="OutputBindingInfo">
    <xs:annotation>
      <xs:documentation>
        Contains information required to save the token, i.e., SAML assertion, being created. Different binding mechanisms
        may require different encoding mechanism/procedures.
      </xs:documentation>
      <xs:appinfo>Currently only required for REST bindings.</xs:appinfo>
    </xs:annotation>
    <xs:sequence minOccurs="0">
      <xs:annotation>
        <xs:appinfo>
          A SAML assertion that is package within a SAML Query response is normally Deflated and then Base64 encoded.
          The Base 64 encoding is required because the compression mechanism can cause binary values to be generated.
          Additionally, the base64 encoding will remove linefeeds and whitespaces that can cause problems when they
          appear with the HTTP header.
          See Bindings for the OASIS Security Assertion Markup Language (SAML) V2.0 OASIS Standard, 15 March 2005
          for processing details.
        </xs:appinfo>
      </xs:annotation>
      <xs:element name="exportDestination" default="to-WS-Security-header">
        <xs:annotation>
          <xs:documentation>This element identifies where the SAML Assertion to be generated is located.</xs:documentation>
          <xs:appinfo>Am defaulting this element so that existing AAA policies will NOT require any retrofit.</xs:appinfo>
        </xs:annotation>
        <xs:simpleType>
          <xs:restriction base="xs:string">
            <xs:enumeration value="to-WS-Security-header">
              <xs:annotation>
                <xs:documentation>
                  SAML assertion being generated will be saved in WS-Security header within the SOAP header of the 
                  revised input document
                </xs:documentation>
              </xs:annotation>
              <!-- constraint: ONLY ALLOWED if (bindingType == SOAP) -->
            </xs:enumeration>
            <xs:enumeration value="to-HTTP-Authorization-saml2-bearer">
              <xs:annotation>
                <xs:documentation>
                  A base64(inflate(SAML assertion)) will be written to a workflow variable that is accessible to the appliation via
                  get-security-metadata action.
                  The SAML assertion will be deflated and base64 encoded and then packaged within a string looking like:
                    saml2-bearer &lt;base64(deflated(build-saml-query-response(saml-assertion)))&gt; 
                  This will be package within a HTTP Authorization field.
                  This is an Intel Expressway proprietary encoding. The SAML assertion should be a bearer assertion.
                </xs:documentation>
              </xs:annotation>
              <!-- constraint: ONLY ALLOWED if (bindingType == REST) -->
            </xs:enumeration>
            <xs:enumeration value="to-HTTP-Authorization-saml2-hok-ssl">
              <xs:annotation>
                <xs:documentation>
                  A base64(inflate(SAML assertion)) will be written to a workflow variable that is accessible to the appliation via
                  get-security-metadata action.
                  The SAML assertion will be deflated and base64 encoded and then packaged within a string looking like:
                    saml2-hok-ssl &lt;base64(deflated(build-saml-query-response(saml-assertion)))&gt; 
                  This will be package within a HTTP Authorization field.
                  The SAML assertion should be a holder-of-key assertion whose credential will be valided via the authenticated
                  peer certificate from the associated SSL/TLS session.
                </xs:documentation>
              </xs:annotation>
              <!-- constraint: ONLY ALLOWED if (bindingType == REST) -->
            </xs:enumeration>
            <xs:enumeration value="to-workflow">
              <xs:annotation>
                <xs:documentation>General mechanism to allow application to save SAML assertion from anywhere.</xs:documentation>
                <xs:appinfo>
                  The exported SAML assertion will be deflated and base64 encoded depending upon the 
                  application settings to the deflate and base64Encode elements.
                  If both elements are false that a string encoding with NL of the SAML assertion will
                  generated.
                </xs:appinfo>
              </xs:annotation>
              <!-- constraint: ONLY ALLOWED if (bindingType == REST) -->
            </xs:enumeration>
            <xs:enumeration value="to-SAML-response">
              <xs:annotation>
                <xs:documentation>
                  A base64(SAML assertion) that has been embedded within a SAML response structure will be written to a workflow
                  variable that is accessible to the appliation via get-security-metadata action:
                      base64(deflated(XML-enveloped-signature(build-saml-query-response(saml-assertion)))).
                  The SAML assertion may be optionally deflated based upon associated policy setting.
                </xs:documentation>
                <xs:appinfo>
                  The exported SAML assertion will be base64 encoded. It will only be deflated if the application developer sets 
                  the application settings to deflate.
                </xs:appinfo>
              </xs:annotation>
              <!-- constraint: ONLY ALLOWED if (bindingType == REST) -->
            </xs:enumeration>
          </xs:restriction>
        </xs:simpleType>
      </xs:element>
      <xs:element name="deflate" type="xs:boolean" default="true" minOccurs="0">
        <xs:annotation>
          <xs:documentation> 
            Indicates if the resulting token (entire SAML assertion) is to be deflated, i.e, compressed according to RFC1951.
          </xs:documentation>
        </xs:annotation>
        <!-- constraint: 
             1) ONLY PRESENT if (exportDestination == (to-HTTP-Authorization-saml2-bearer OR to-HTTP-Authorization-saml2-hok-ssl OR
                                                       to-workflow OR to-SAML-response
                                                      )
                                )
             2) MUST be SET TRUE if (exportDestination == (to-HTTP-Authorization-saml2-bearer OR
                                                           to-HTTP-Authorization-saml2-hok-ssl
                                                          )
                                    )
             3) NOT PRESENT/ALLOWED if (exportDestination == to-WS-Security-header)
             4) Defaults to disable if (exportDestination == to-SAML-response)
        -->
      </xs:element>
      <xs:element name="base64Encode" type="xs:boolean" default="true" minOccurs="0">
        <xs:annotation>
          <xs:documentation> 
            Indicates if the resulting token (entire SAML Assertion) is to be base64 encoded according to RFC 2045.
          </xs:documentation>
          <!-- constraint: 
               1) ONLY PRESENT if (exportDestination == (to-HTTP-Authorization-saml2-bearer OR to-HTTP-Authorization-saml2-hok-ssl OR
                                                         to-workflow
                                                        )
                                  )
               2) MUST be SET TRUE if (exportDestination == (to-HTTP-Authorization-saml2-bearer OR
                                                             to-HTTP-Authorization-saml2-hok-ssl OR
                                                             to-SAML-response
                                                            )
                                      )
               3) NOT PRESENT/ALLOWED if (exportDestination == to-WS-Security-header)
               4) MUST be SET to TRUE if (deflate == true) 
          -->
        </xs:annotation>
      </xs:element>
      <xs:element name="QueryResponse" type="wssec:QueryResponseTypeForInternalCreateSamlAssertion" minOccurs="0">
        <!-- constraint: ONLY PRESENT if (exportDestination == (to-HTTP-Authorization-saml2-bearer OR
                                                                 to-HTTP-Authorization-saml2-hok-ssl OR
                                                                 to-SAML-response
                                                                )
                                          )
        -->
      </xs:element>
    </xs:sequence>
  </xs:complexType>
  <xs:complexType name="QueryResponseTypeForInternalCreateSamlAssertion">
    <xs:annotation>
      <xs:documentation>
        Information that is needed to encapsulate a SAML Assertion that was produced by us, e.g., map identity create SAML assertion. 
      </xs:documentation>
      <xs:appinfo>
        Note: the SAML Attribute query response can not be used directly here because this usage calls for a SAML Authentication query 
        response packaging ==&gt; we have to repackage the returned SAML assertion into a different SAML query response structure.
      </xs:appinfo>
    </xs:annotation>
    <xs:complexContent>
      <xs:extension base="wssec:QueryResponseBaseType">
        <xs:sequence>
          <xs:element name="responseIssuer" type="xs:boolean" default="false" minOccurs="0">
            <xs:annotation>
              <xs:documentation>Identifies the entity that generated the response message.</xs:documentation>
              <xs:appinfo>If enabled then use same issuer identified in the create SAML assertion</xs:appinfo>
            </xs:annotation>
          </xs:element>
          <xs:element name="InResponseTo" type="wssec:SamlNCName" minOccurs="0"/>
          <xs:element name="envelopedSignature" type="wssec:XmlX509EnvelopedSignatureType" minOccurs="0">
            <!-- constraint: ONLY ALLOWED if (exportDestination == to_Saml_response) -->
          </xs:element>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:complexType name="QueryResponseBaseType">
    <xs:annotation>
      <xs:documentation>Information needed for the generating a SAML Query Response</xs:documentation>
    </xs:annotation>
    <xs:sequence>
      <xs:element name="Destination" type="wssec:SamlUri" minOccurs="0">
        <xs:annotation>
          <xs:documentation>
            A URI reference indicating the address to which this response is being sent. This is useful to prevent malicious 
            forwarding of requests to unintended recipients, a protection that is required by some protocol bindings. If it is 
            present, the actual recipient MUST check that the URI reference identifies the location at which the message was 
            received. If it does not, the response MUST be discarded. Some protocol bindings may require the use of this attribute.
          </xs:documentation>
          <xs:appinfo>
            This information gets package within an attribute that is part of samlp:Response elements.
          </xs:appinfo>
        </xs:annotation>
      </xs:element>
      <xs:element name="Consent" default="urn:oasis:names:tc:SAML:2.0:consent:unspecified" minOccurs="0">
        <xs:annotation>
          <xs:documentation>
            Indicates whether or not (and under what conditions) consent has been obtained from a principal in the sending of this request.
            If no Consent value is provided, the identifier urn:oasis:names:tc:SAML:2.0:consent:unspecified is in effect.
          </xs:documentation>
        </xs:annotation>
        <xs:simpleType>
          <xs:restriction base="xs:string">
            <xs:enumeration value="urn:oasis:names:tc:SAML:2.0:consent:unspecified">
              <xs:annotation>
                <xs:documentation>No claim as to principal consent is being made.</xs:documentation>
              </xs:annotation>
            </xs:enumeration>
            <xs:enumeration value="urn:oasis:names:tc:SAML:2.0:consent:obtained">
              <xs:annotation>
                <xs:documentation>Indicates that a principals consent has been obtained by the issuer of the message.</xs:documentation>
              </xs:annotation>
            </xs:enumeration>
            <xs:enumeration value="urn:oasis:names:tc:SAML:2.0:consent:prior">
              <xs:annotation>
                <xs:documentation>
                  Indicates that a principals consent has been obtained by the issuer of the message at some point prior to the action 
                  that initiated the message.
                </xs:documentation>
              </xs:annotation>
            </xs:enumeration>
            <xs:enumeration value="urn:oasis:names:tc:SAML:2.0:consent:current-implicit">
              <xs:annotation>
                <xs:documentation>
                  Indicates that a principals consent has been implicitly obtained by the issuer of the message during the action that 
                  initiated the message, as part of a broader indication of consent. Implicit consent is typically more proximal to the 
                  action in time and presentation than prior consent, such as part of a session of activities.
                </xs:documentation>
              </xs:annotation>
            </xs:enumeration>
            <xs:enumeration value="urn:oasis:names:tc:SAML:2.0:consent:current-explicit">
              <xs:annotation>
                <xs:documentation>
                  Indicates that a principals consent has been explicitly obtained by the issuer of the message during the action that 
                  initiated the message.
                </xs:documentation>
              </xs:annotation>
            </xs:enumeration>
            <xs:enumeration value="urn:oasis:names:tc:SAML:2.0:consent:unavailable">
              <xs:annotation>
                <xs:documentation>Indicates that the issuer of the message did not obtain consent.</xs:documentation>
              </xs:annotation>
            </xs:enumeration>
            <xs:enumeration value="urn:oasis:names:tc:SAML:2.0:consent:inapplicable">
              <xs:annotation>
                <xs:documentation>
                  Indicates that the issuer of the message does not believe that they need to obtain or report consent.
                </xs:documentation>
              </xs:annotation>
            </xs:enumeration>
          </xs:restriction>
        </xs:simpleType>
      </xs:element>
    </xs:sequence>
  </xs:complexType>
  <xs:complexType name="XmlX509EnvelopedSignatureType">
    <xs:annotation>
      <xs:documentation>XML X509 Enveloped Signature used to sign SAML response.</xs:documentation>
    </xs:annotation>
    <xs:sequence>
      <xs:element name="envelopedSignatureGenerationMethod" type="wssec:SamlSignatureGenerationMethod" default="rsaWithSha1">
        <xs:annotation>
          <xs:documentation>What signature method will be use when generating the enveloped signature.</xs:documentation>
        </xs:annotation>
      </xs:element>
      <xs:element name="envelopedSignatureCanonicalGenerationMethod" type="wssec:CanonicalGenerationMethod" default="C14N_exclusive">
        <xs:annotation>
          <xs:documentation>What canonicalization method will we use when generating the enveloped signature SignInfo.</xs:documentation>
        </xs:annotation>
      </xs:element>
      <xs:element name="envelopedDigestGenerationMethod" type="wssec:DigestGenerationMethod" default="sha1">
        <xs:annotation>
          <xs:documentation>What digest method will we use over the enveloped data.</xs:documentation>
        </xs:annotation>
      </xs:element>
      <xs:element name="envelopedCanonicalGenerationMethod" type="wssec:CanonicalGenerationMethod" default="C14N_exclusive">
        <xs:annotation>
          <xs:documentation>What canonicalization method will we use over the enveloped data references.</xs:documentation>
        </xs:annotation>
      </xs:element>
      <xs:element name="samlRestriction" type="xs:boolean" default="false">
        <xs:annotation>
          <xs:documentation>
            Indicates if strict SAML restrictions are to be enforced on this embedded enveloped signature. XML signature 
            standards recommend that data references utilize xpointer() mechanism. However, some SAML organization believe 
            that a NULL string should be utilied.
          </xs:documentation>
        </xs:annotation>
      </xs:element>
      <xs:element name="keyPair">
        <xs:annotation>
          <xs:documentation>
            Name of an asymmetricKeyPair element. Resolution based upon value of associated "use" attribute.
            This asymmetricKeyPair element identifies either a RSA or DSA public/private key pair. The public key is 
            usually package within an X.509 certificate. The private key and associated certificate can be package in 
            the same file or in separate files.
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:choice>
            <xs:element name="security-config-package" type="wssec:SecurityConfigPackageType"/>
          </xs:choice>
        </xs:complexType>
      </xs:element>
    </xs:sequence>
  </xs:complexType>
  <xs:complexType name="EncryptSamlKeyInfoType">
    <xs:choice>
      <xs:element name="symmetric">
        <xs:complexType>
          <xs:sequence>
            <xs:element name="keyRecipientPair" type="wssec:KeyRecipientPair" maxOccurs="unbounded"/>
          </xs:sequence>
        </xs:complexType>
        <!-- constraint: only static symmetric key from assocaited security config package allowed -->
      </xs:element>
      <xs:element name="x509">
        <xs:complexType>
          <xs:sequence>
            <xs:element name="generateKeyTransportMethod">
              <xs:complexType>
                <xs:attribute name="method" use="required">
                  <xs:simpleType>
                    <xs:restriction base="xs:string">
                      <xs:enumeration value="rsa-v1.5"/>
                      <xs:enumeration value="rsa-oaep"/>
                    </xs:restriction>
                  </xs:simpleType>
                </xs:attribute>
                <xs:attribute name="RsaOaepDigestMethod" type="wssec:DigestGenerationMethod" use="optional" default="sha1">
                  <!-- constraint: only allowed when generateKeyTransportMethod == rsa-oaep -->
                </xs:attribute>
                <xs:attribute name="RsaOaepGenerateRandomString" type="xs:boolean" use="optional" default="false">
                  <!-- constraint: only allowed when generateKeyTransportMethod == rsa-oaep -->
                </xs:attribute>
              </xs:complexType>
            </xs:element>
            <xs:element name="keyRecipientPair" type="wssec:KeyRecipientPair" maxOccurs="unbounded"/>
          </xs:sequence>
        </xs:complexType>
      </xs:element>
    </xs:choice>
  </xs:complexType>
  <xs:complexType name="KeyRecipientPair">
    <xs:sequence>
      <xs:annotation>
        <xs:documentation>SAML assertion could be encrypting same SAML assertion for multiple consumers</xs:documentation>
      </xs:annotation>
      <xs:element name="recipientKey" type="wssec:SecurityToken"/>
      <xs:element name="recipient" type="wssec:SamlUri" minOccurs="0">
        <xs:annotation>
          <xs:documentation>Identified the target recepicent for this encryption</xs:documentation>
        </xs:annotation>
        <!-- constraint: MUST be specified when multiple keys (certificate/symmetric) are specified -->
        <!-- constraint: WARNING is specified when only one key (certificate/symmetric) is specified and recepicent is populated -->
      </xs:element>
    </xs:sequence>
  </xs:complexType>
  <xs:complexType name="SourceAssertionInfo">
    <xs:annotation>
      <xs:documentation>
        Identifies the different SAML Assertion elements and attributes that the application wants generated along 
        with any application specific information that is needed to populate their value. 
        We will automatically populate the following entity based upon the SAML version.
        elements: AssertionID, AssertIDReference, AuthenticationStatement.
        attributes: major version, minor version, AuthenticationInstant, AuthnStatement AuthnInstant.
      </xs:documentation>
    </xs:annotation>
    <xs:sequence>
      <xs:choice>
        <xs:element name="v1dotxInfo" type="wssec:V1dotXSourceInfo"/>
        <xs:element name="v2dot0Info" type="wssec:V2dot0SourceInfo"/>
      </xs:choice>
      <xs:element name="assertionNamespaces" type="wssec:Namespaces" minOccurs="0">
        <xs:annotation>
          <xs:documentation>
            Application developers can specify that zero or more optional namespaces can be added to the SAML assertion being created,
            e.g., 
  xmlns:x500="urn:oasis:names:tc:SAML:2.0:profiles:attribute:X500". This allows the application to simplify what they would 
            need to specify any AttributeValue, SAML extension point, etc. that may require namespace prefixes to be set-up to be well-formed.
            
            By default, we will automatically always populate the prefix saml to the associated version of SAML specified, 
            e.g., 
  xmlns:saml="urn:oasis:names:tc:SAML:2.0:assertion" or 
  xmlns:saml="urn:oasis:names:tc:SAML:1.0:assertion"
          </xs:documentation>
          <xs:appinfo>
            Note: 
  xmlns:saml="urn:oasis:names:tc:SAML:1.0:assertion" should be used for both SAML v1.0 and SAML v1.1.
            
            If the application selects to add additional SAML assertion namespaces, I would pre-populate the table with the following 
            namespaces because they are so frequently used. 
            1) 
  xmlns:xs="http://www.w3.org/2001/XMLSchema"
            2) 
  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
          </xs:appinfo>
        </xs:annotation>
        <!-- constraint: SAML namespace must agree with SAML version selected -->
      </xs:element>
    </xs:sequence>
  </xs:complexType>
  <xs:complexType name="V1dotXSourceInfo">
    <xs:annotation>
      <xs:documentation>SAML Version 1.0 and 1.1 Information need to populate SAML Assertion to be generated.</xs:documentation>
    </xs:annotation>
    <xs:sequence>
      <xs:element name="generalAssertionInfo" type="wssec:GeneralAssertionInfo"/>
      <xs:element name="Conditions" type="wssec:ConditionsInfo-1dotx" minOccurs="0"/>
      <xs:element name="Advice" type="wssec:Advice-1dotx" minOccurs="0"/>
      <xs:element name="SubjectStatement" type="wssec:SubjectStatementInfo" minOccurs="0" maxOccurs="unbounded"/>
      <xs:element name="AuthenticationStatement" type="wssec:AuthenticationStatementInfo" minOccurs="0" maxOccurs="unbounded"/>
      <xs:element name="AuthorizationDecisionStatement" type="wssec:AuthorizationDecisionStatementInfo" minOccurs="0" maxOccurs="unbounded"/>
      <xs:element name="AttributeStatement" type="wssec:AttributeStatementV1dotx" minOccurs="0" maxOccurs="unbounded"/>
      <xs:element name="QueryResponse" minOccurs="0">
        <xs:annotation>
          <xs:documentation>Information needed for the generating a SAML Query Response</xs:documentation>
          <xs:appinfo>
            This information should never be displayed within Service Designer WS-Security policy editor.
            It is only intended for usage with internal extension functions that should only be utilized
            by IDP implementations, e.g., BAE broker, that needs to generate a SAML Query response.
            SD WS-Security policy editor is only required to be able to read in a policy with this element and be
            able to edit it within a text editor and to save the results.
          </xs:appinfo>
        </xs:annotation>
        <xs:complexType>
          <xs:sequence>
            <xs:element name="QueryResponseRecipient" type="wssec:SamlUri" minOccurs="0">
              <xs:annotation>
                <xs:documentation>
                  A URI reference indicating the address to which this response is being sent. This is useful to prevent malicious 
                  forwarding of requests to unintended recipients, a protection that is required by some protocol bindings. If it is 
                  present, the actual recipient MUST check that the URI reference identifies the location at which the message was 
                  received. If it does not, the response MUST be discarded. Some protocol bindings may require the use of this attribute.
                </xs:documentation>
                <xs:appinfo>
                  This information gets package within an attribute that is part of samlp:Response elements.
                </xs:appinfo>
              </xs:annotation>
            </xs:element>
          </xs:sequence>
        </xs:complexType>
      </xs:element>
    </xs:sequence>
  </xs:complexType>
  <xs:complexType name="V2dot0SourceInfo">
    <xs:annotation>
      <xs:documentation>SAML Version 2.0 Information need to populate SAML Assertion to be generated.</xs:documentation>
    </xs:annotation>
    <xs:sequence>
      <xs:element name="generalAssertionInfo" type="wssec:GeneralAssertionInfo-2dot0"/>
      <xs:element name="Subject" type="wssec:SubjectInfo" minOccurs="0"/>
      <xs:element name="Conditions" type="wssec:ConditionsInfo-2dot0" minOccurs="0"/>
      <xs:element name="Advice" type="wssec:Advice-2dot0" minOccurs="0"/>
      <xs:element name="AuthnStatement" type="wssec:AuthnStatementInfo" minOccurs="0" maxOccurs="unbounded"/>
      <xs:element name="AuthzDecisionStatement" type="wssec:AuthzDecisionStatementInfo" minOccurs="0" maxOccurs="unbounded"/>
      <xs:element name="AttributeStatement" type="wssec:AttributeStatementV2dot0" minOccurs="0" maxOccurs="unbounded"/>
      <xs:element name="QueryResponse" minOccurs="0">
        <xs:annotation>
          <xs:documentation>Information needed for the generating a SAML Query Response</xs:documentation>
          <xs:appinfo>
            This information should never be displayed within Service Designer WS-Security policy editor.
            It is only intended for usage with internal extension functions that should only be utilized
            by IDP implementations, e.g., BAE broker, that needs to generate a SAML Query response.
            SD WS-Security policy editor is only required to be able to read in a policy with this element and be
            able to edit it within a text editor and to save the results.
          </xs:appinfo>
        </xs:annotation>
        <xs:complexType>
          <xs:sequence>
            <xs:element name="Destination" type="wssec:SamlUri" minOccurs="0">
              <xs:annotation>
                <xs:documentation>
                  A URI reference indicating the address to which this response is being sent. This is useful to prevent malicious 
                  forwarding of requests to unintended recipients, a protection that is required by some protocol bindings. If it is 
                  present, the actual recipient MUST check that the URI reference identifies the location at which the message was 
                  received. If it does not, the response MUST be discarded. Some protocol bindings may require the use of this attribute.
                </xs:documentation>
                <xs:appinfo>
                  This information gets package within an attribute that is part of samlp:Response elements.
                </xs:appinfo>
              </xs:annotation>
            </xs:element>
            <xs:element name="Consent" default="urn:oasis:names:tc:SAML:2.0:consent:unspecified" minOccurs="0">
              <xs:annotation>
                <xs:documentation>
                  Indicates whether or not (and under what conditions) consent has been obtained from a principal in the sending of this request.
                  If no Consent value is provided, the identifier urn:oasis:names:tc:SAML:2.0:consent:unspecified is in effect.
                </xs:documentation>
              </xs:annotation>
              <xs:simpleType>
                <xs:restriction base="xs:string">
                  <xs:enumeration value="urn:oasis:names:tc:SAML:2.0:consent:unspecified">
                    <xs:annotation>
                      <xs:documentation>No claim as to principal consent is being made.</xs:documentation>
                    </xs:annotation>
                  </xs:enumeration>
                  <xs:enumeration value="urn:oasis:names:tc:SAML:2.0:consent:obtained">
                    <xs:annotation>
                      <xs:documentation>Indicates that a principals consent has been obtained by the issuer of the message.</xs:documentation>
                    </xs:annotation>
                  </xs:enumeration>
                  <xs:enumeration value="urn:oasis:names:tc:SAML:2.0:consent:prior">
                    <xs:annotation>
                      <xs:documentation>
                        Indicates that a principals consent has been obtained by the issuer of the message at some point prior to the action 
                        that initiated the message.
                      </xs:documentation>
                    </xs:annotation>
                  </xs:enumeration>
                  <xs:enumeration value="urn:oasis:names:tc:SAML:2.0:consent:current-implicit">
                    <xs:annotation>
                      <xs:documentation>
                        Indicates that a principals consent has been implicitly obtained by the issuer of the message during the action that 
                        initiated the message, as part of a broader indication of consent. Implicit consent is typically more proximal to the 
                        action in time and presentation than prior consent, such as part of a session of activities.
                      </xs:documentation>
                    </xs:annotation>
                  </xs:enumeration>
                  <xs:enumeration value="urn:oasis:names:tc:SAML:2.0:consent:current-explicit">
                    <xs:annotation>
                      <xs:documentation>
                        Indicates that a principals consent has been explicitly obtained by the issuer of the message during the action that 
                        initiated the message.
                      </xs:documentation>
                    </xs:annotation>
                  </xs:enumeration>
                  <xs:enumeration value="urn:oasis:names:tc:SAML:2.0:consent:unavailable">
                    <xs:annotation>
                      <xs:documentation>Indicates that the issuer of the message did not obtain consent.</xs:documentation>
                    </xs:annotation>
                  </xs:enumeration>
                  <xs:enumeration value="urn:oasis:names:tc:SAML:2.0:consent:inapplicable">
                    <xs:annotation>
                      <xs:documentation>
                        Indicates that the issuer of the message does not believe that they need to obtain or report consent.
                      </xs:documentation>
                    </xs:annotation>
                  </xs:enumeration>
                </xs:restriction>
              </xs:simpleType>
            </xs:element>
            <xs:element name="responseIssuer" type="xs:boolean" default="false">
              <xs:annotation>
                <xs:documentation>Identifies the entity that generated the response message.</xs:documentation>
                <xs:appinfo>If enabled then use same issuer identified in the create SAML assertion</xs:appinfo>
              </xs:annotation>
            </xs:element>
          </xs:sequence>
        </xs:complexType>
      </xs:element>
    </xs:sequence>
  </xs:complexType>
  <xs:complexType name="GeneralAssertionInfo">
    <xs:sequence>
      <xs:element name="Issuer" type="wssec:SamlString"/>
      <xs:element name="skew" default="10" minOccurs="0">
        <xs:annotation>
          <xs:documentation>
            Time in seconds that SAML assertion generator and consuming system clock needs to support.
            NotBefore set to current time - skew.
            NotOnOrAfter set to current time + skew + maximum_expiration_time.
          </xs:documentation>
        </xs:annotation>
        <xs:simpleType>
          <xs:restriction base="xs:unsignedInt">
            <xs:maxInclusive value="360">
              <xs:annotation>
                <xs:documentation>maximum allowed value is 6 minute = 360 seconds</xs:documentation>
              </xs:annotation>
            </xs:maxInclusive>
          </xs:restriction>
        </xs:simpleType>
      </xs:element>
      <xs:element name="maxExpirationTime" type="wssec:ExpirationDeltaType" minOccurs="0">
        <xs:annotation>
          <xs:documentation>
            Time in seconds that SAML assertion issuer allows for consumer to use assertion.
            NotOnOrAfter set to current time + skew + maximum_expiration_time.
          </xs:documentation>
        </xs:annotation>
      </xs:element>
      <xs:element name="Statement" type="wssec:SamlAppExtPt" minOccurs="0" maxOccurs="unbounded"/>
    </xs:sequence>
  </xs:complexType>
  <xs:complexType name="GeneralAssertionInfo-2dot0">
    <xs:complexContent>
      <xs:extension base="wssec:GeneralAssertionInfo">
        <xs:sequence>
          <xs:element name="IssuerNameQualifierAttribute" type="wssec:SamlString" minOccurs="0">
            <xs:annotation>
              <xs:documentation>
                The security or administrative domain that qualifies the name. This attribute provides a means
                to federate names from disparate user stores without collision.
              </xs:documentation>
            </xs:annotation>
          </xs:element>
          <xs:element name="IssuerSPNameQualifierAttribute" type="wssec:SamlString" minOccurs="0">
            <xs:annotation>
              <xs:documentation>
                Further qualifies a name with the name of a service provider or affiliation of providers. 
                This attribute provides an additional means to federate names on the basis of the relying party 
                or parties.
              </xs:documentation>
            </xs:annotation>
          </xs:element>
          <xs:element name="IssuerFormatAttribute" type="wssec:NameIdFormatType" minOccurs="0">
            <xs:annotation>
              <xs:documentation>
                A URI reference representing the classification of string-based identifier information.
              </xs:documentation>
            </xs:annotation>
          </xs:element>
          <xs:element name="SPProvidedID" type="wssec:SamlString" minOccurs="0">
            <xs:annotation>
              <xs:documentation>
                A name identifier established by a service provider or affiliation of providers for the entity, 
                if different from the primary name identifier given in the content of the element. This attribute
                provides a means of integrating the use of SAML with existing identifiers already in use by a
                service provider.
              </xs:documentation>
            </xs:annotation>
          </xs:element>
          <xs:element name="encryptAssertion" type="xs:boolean" default="false" minOccurs="0">
            <xs:annotation>
              <xs:documentation>Indicates that entire Assertion is to be encrypted</xs:documentation>
            </xs:annotation>
            <!-- constraint: if encryptAssertion is TRUE then the encryptAttribute and encyptID must be FALSE -->
          </xs:element>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:complexType name="SubjectStatementInfo">
    <xs:annotation>
      <xs:documentation>
        SubjectStatement_element -&gt; Subject_element information in SAML 1.0 and 1.1
      </xs:documentation>
    </xs:annotation>
    <xs:sequence>
      <xs:element name="Subject-NameIdentifier-NameQualifier-Attribute" type="wssec:SamlString" minOccurs="0">
        <!-- constraint: Only allowed is Subject-NameIdentifier is populated -->
      </xs:element>
      <xs:element name="Subject-NameIdentifier-Format-Attribute" type="wssec:NameIdFormatType" minOccurs="0">
        <!-- constraint: Only allowed is Subject-NameIdentifier is populated -->
      </xs:element>
      <xs:element name="Subject-NameIdentifier" type="wssec:SamlString" minOccurs="0">
        <!-- constraint: if SubjectConfirmation ConfirmationMethod is not present then Subject-NameIdentifier must be defined -->
      </xs:element>
      <xs:element name="Subject-SubjectConfirmation" type="wssec:V1-SubjectConfirmationType" minOccurs="0">
        <!-- constraint: if Subject-NameIdentifier is not populated then Subject-SubjectConfirmation MUST be populated -->
      </xs:element>
    </xs:sequence>
  </xs:complexType>
  <xs:complexType name="V1-SubjectConfirmationType">
    <xs:sequence>
      <xs:element name="ConfirmationMethod" type="wssec:ConfirmationMethodType" maxOccurs="unbounded">
        <!-- constraint: 
              1) If any holder-of-key confirmation method selected then the SAML assertion must be signed.
              2) While we should expect that the SAML version should restrict the actual value, it is possible
                 for a user to use value from a different release. At most, we should generate a warning message 
                 when a developer selects a value from a different SAML version.
        -->
      </xs:element>
      <xs:element name="confirmationKeyInfo" type="wssec:HolderOfKeyKeyInfo" minOccurs="0">
        <!-- constraint: 1) only Present when SubjectConfirmationType Method is some form of holder-of-key
                         2) MUST be populated if SubjectConfirmationType Method is some form of holder-of-key
        -->
      </xs:element>
      <!-- deferred elements
      <xs:element name="ConfirmationData" type="wssec:SamlAppExtPt" minOccurs="0" maxOccurs="unbounded"/>
      -->
    </xs:sequence>
  </xs:complexType>
  <xs:complexType name="SubjectInfo">
    <xs:annotation>
      <xs:documentation>
        Subject_element information in SAML 2.0.
        When a SubjectConfirmation element is being defined, we should automatically generate the following SubjectConfirmationData entities:
        1) NotBefore attribute: current time - skew
        2) NotOnOrAfter attribute: current time +skew + maximum_expiration-time
      </xs:documentation>
    </xs:annotation>
    <xs:choice>
      <xs:sequence>
        <xs:choice>
          <xs:sequence>
            <xs:element name="NameID-NameQualifier-Attribute" type="wssec:SamlString" minOccurs="0"/>
            <xs:element name="NameID-SPNameQualifier-Attribute" type="wssec:SamlString" minOccurs="0">
              <!-- constraint: only allowed when NameID-SPProvidedID-Attribute is populated -->
            </xs:element>
            <xs:element name="NameID-Format-Attribute" type="wssec:SamlNameIdFormat" minOccurs="0"/>
            <xs:element name="NameID-SPProvidedID-Attribute" type="wssec:SamlString" minOccurs="0"/>
            <xs:element name="NameID" type="wssec:NameBaseIdType"/>
          </xs:sequence>
          <xs:sequence>
            <xs:element name="BaseID-NameQualifier-Attribute" type="wssec:SamlString" minOccurs="0"/>
            <xs:element name="BaseID-SPNameQualifier-Attribute" type="wssec:SamlString" minOccurs="0"/>
            <xs:element name="BaseID" type="wssec:NameBaseIdType"/>
          </xs:sequence>
        </xs:choice>
        <xs:element name="SubjectConfirmation" type="wssec:SubjectConfirmationType" minOccurs="0" maxOccurs="unbounded"/>
      </xs:sequence>
      <xs:element name="SubjectConfirmation" type="wssec:SubjectConfirmationType" maxOccurs="unbounded"/>
    </xs:choice>
  </xs:complexType>
  <xs:complexType name="SubjectConfirmationType">
    <xs:sequence>
      <xs:element name="Method" type="wssec:ConfirmationMethodType">
        <xs:annotation>
          <xs:documentation>
            For SAML 2.0, ConfirmationMethod is embedded within Subject_element - SubjectConfirmation_element. 
            ConfirmationMethod is mapped to Method_attribute.
          </xs:documentation>
        </xs:annotation>
        <!-- constraint: 
              1) If any holder-of-key confirmation method selected then the SAML assertion must be signed.
              2) While we should expect that the SAML version should restrict the actual value, it is possible
                 for a user to use value from a different release. At most, we should generate a warning message 
                 when a developer selects a value from a different SAML version.
        -->
      </xs:element>
      <xs:choice>
        <xs:sequence minOccurs="0">
          <xs:element name="NameID-NameQualifier-Attribute" type="wssec:SamlString" minOccurs="0">
            <!-- constraint: only ALLOWED to be populated if associated NameID is populated -->
          </xs:element>
          <xs:element name="NameID-SPNameQualifier-Attribute" type="wssec:SamlString" minOccurs="0">
            <!-- constraint: only ALLOWED to be populated if associated NameID is populated -->
          </xs:element>
          <xs:element name="NameID-Format-Attribute" type="wssec:SamlNameIdFormat" minOccurs="0">
            <!-- constraint: only ALLOWED to be populated if associated NameID is populated -->
          </xs:element>
          <xs:element name="NameID-SPProvidedID-Attribute" type="wssec:SamlString" minOccurs="0">
            <!-- constraint: only ALLOWED to be populated if associated NameID is populated -->
          </xs:element>
          <xs:element name="NameID" type="wssec:NameBaseIdType"/>
        </xs:sequence>
        <xs:sequence minOccurs="0">
          <xs:element name="BaseID-NameQualifier-Attribute" type="wssec:SamlString" minOccurs="0">
            <!-- constraint: only ALLOWED to be populated if associated BaseID is populated -->
          </xs:element>
          <xs:element name="BaseID-SPNameQualifier-Attribute" type="wssec:SamlString" minOccurs="0">
            <!-- constraint: only ALLOWED to be populated if associated BaseID is populated -->
          </xs:element>
          <xs:element name="BaseID" type="wssec:NameBaseIdType"/>
        </xs:sequence>
      </xs:choice>
      <xs:element name="confirmationKeyInfo" type="wssec:HolderOfKeyKeyInfo" minOccurs="0">
        <!-- constraint: 1) only Present when SubjectConfirmationType Method is some form of holder-of-key
                         2) MUST be populated if SubjectConfirmationType Method is some form of holder-of-key
        -->
      </xs:element>
      <xs:element name="SubjectConfirmationData-Recipent-Attribute" type="wssec:SamlUri" minOccurs="0"/>
      <xs:element name="SubjectConfirmationData-InResponseTo-Attribute" type="wssec:SamlNCName" minOccurs="0"/>
      <xs:element name="SubjectConfirmationData-Address-Attribute" type="wssec:SamlString" minOccurs="0"/>
    </xs:sequence>
  </xs:complexType>
  <xs:complexType name="AuthenticationStatementInfo">
    <xs:annotation>
      <xs:appinfo>
        AuthenticationInstant should automatically be created whenever AuthenticationStatement being generated.
        AuthenticationInstant = current time
      </xs:appinfo>
    </xs:annotation>
    <xs:sequence>
      <xs:element name="AuthenticationMethod-Attribute" type="wssec:AuthenticationMethodType" default="urn:oasis:names:tc:SAML:1.0:am:password"/>
      <xs:element name="Subject-NameIdentifier-NameQualifier-Attribute" type="wssec:SamlString" minOccurs="0">
        <!-- constraint: if SubjectConfirmation ConfirmationMethod is not present then Subject-NameIdentifier must be defined -->
      </xs:element>
      <xs:element name="Subject-NameIdentifier-Format-Attribute" type="wssec:NameIdFormatType" default="urn:oasis:names:tc:SAML:1.1:nameid-format:unspecified" minOccurs="0">
        <!-- constraint: if SubjectConfirmation ConfirmationMethod is not present then Subject-NameIdentifier must be defined -->
      </xs:element>
      <xs:element name="Subject-NameIdentifier" type="wssec:SamlString" minOccurs="0"/>
      <xs:element name="Subject-SubjectConfirmation" type="wssec:V1-SubjectConfirmationType" minOccurs="0">
        <!-- constraint: if Subject-NameIdentifier is not populated then Subject-SubjectConfirmation MUST be populated -->
      </xs:element>
      <xs:element name="SubjectLocality-IPAddress-Attribute" type="wssec:SamlString" minOccurs="0"/>
      <xs:element name="SubjectLocality-DNSAddress-Attribute" type="wssec:SamlString" minOccurs="0"/>
      <!-- deferred
      <xs:element name="AuthorityBinding-AuthorityKind-Attribute" type="xs:QName"/>
      <xs:element name="AuthorityBinding-Location-Attribute" type="wssec:SamlUri"/>
      <xs:element name="AuthorityBinding-Binding-Attribute" type="wssec:SamlUri"/>
      <xs:element name="Subject-SubjectConfirmation-SubjectConfirmationData" type="wssec:SamlAppExtPt"/>
      -->
    </xs:sequence>
  </xs:complexType>
  <xs:complexType name="AuthnStatementInfo">
    <xs:annotation>
      <xs:documentation>
        SAML V2.0 AuthnStatement.
     </xs:documentation>
      <xs:appinfo>
        We will automatically populate the following SAML v2.0 AuthnStatement entities:
        1) SessionNotOnOrAfter attribute: Current time + skew + maximum_expiration_time
        2) AuthnInstant attribute: current time.
     </xs:appinfo>
    </xs:annotation>
    <xs:sequence>
      <xs:element name="SubjectLocality-Address-Attribute" type="wssec:SamlString" minOccurs="0"/>
      <xs:element name="SubjectLocality-DNSName-Attribute" type="wssec:SamlString" minOccurs="0"/>
      <xs:element name="AuthnContext-AuthenticatingAuthority" type="wssec:SamlUri" minOccurs="0" maxOccurs="unbounded"/>
      <xs:element name="AuthnContext-AuthnContextClassRef" type="wssec:AuthenticationMethodType" minOccurs="0"/>
      <xs:choice>
        <xs:element name="AuthnContext-AuthnContextClassDecl" type="wssec:SamlAppExtPt" minOccurs="0"/>
        <xs:element name="AuthnContext-AuthnContextClassDeclRef" type="wssec:SamlUri" minOccurs="0"/>
      </xs:choice>
      <!-- constraint: 1) (AuthnContext-AuthnContextClassRef OR AuthnContext-AuthnContextClassDecl OR AuthnContext-AuthnContextClassDeclRef) MUST be populated.
                       2) (AuthnContext-AuthnContextClassDecl AND AuthnContext-AuthnContextClassDeclRef) can NOT both be populated.
      -->
    </xs:sequence>
  </xs:complexType>
  <xs:complexType name="AuthorizationDecisionStatementInfo">
    <xs:sequence>
      <xs:element name="Resource-Attribute" type="wssec:SamlUri">
        <xs:annotation>
          <xs:documentation>
            A URI reference identifying the resource to which access authorization is sought. It is permitted for
            this attribute to have the value of the empty URI reference (""), and the meaning is defined in IETF RFC 2396.
          </xs:documentation>
        </xs:annotation>
      </xs:element>
      <xs:element name="Decision-Attribute" type="wssec:DecisionType">
        <xs:annotation>
          <xs:documentation>Status of an authorization decision statement.</xs:documentation>
        </xs:annotation>
      </xs:element>
      <xs:element name="Subject-NameIdentifier-NameQualifier-Attribute" type="wssec:SamlString" minOccurs="0">
        <!-- constraint: if SubjectConfirmation ConfirmationMethod is not present then Subject-NameIdentifier must be defined -->
      </xs:element>
      <xs:element name="Subject-NameIdentifier-Format-Attribute" type="wssec:NameIdFormatType" minOccurs="0">
        <!-- constraint: if SubjectConfirmation ConfirmationMethod is not present then Subject-NameIdentifier must be defined -->
      </xs:element>
      <xs:element name="Subject-NameIdentifier" type="wssec:SamlString" minOccurs="0"/>
      <!-- deferred
      <xs:element name="Subject-SubjectConfirmation-SubjectConfirmationData" type="wssec:SamlAppExtPt" minOccurs="0">
        <xs:annotation>
          <xs:documentation>Extension point</xs:documentation>
        </xs:annotation>
      </xs:element>
      -->
      <xs:element name="Subject-SubjectConfirmation" type="wssec:V1-SubjectConfirmationType" minOccurs="0">
        <!-- constraint: if Subject-NameIdentifier is not populated then Subject-SubjectConfirmation MUST be populated -->
      </xs:element>
      <xs:element name="Action" type="wssec:ActionType" maxOccurs="unbounded"/>
      <!-- deferred
      <xs:element name="Evidence-AssertionIDReference" type="wssec:SamlUri" minOccurs="0" maxOccurs="unbounded"/>
      <xs:element name="Evidence-Assertion" type="wssec:SamlAppExtPt" minOccurs="0" maxOccurs="unbounded"/>
      -->
    </xs:sequence>
  </xs:complexType>
  <xs:complexType name="AuthzDecisionStatementInfo">
    <xs:sequence>
      <xs:element name="Resource-Attribute" type="wssec:SamlUri"/>
      <xs:element name="Decision-Attribute" type="wssec:DecisionType"/>
      <xs:element name="Action" type="wssec:ActionType" maxOccurs="unbounded"/>
      <!-- deferred
      <xs:element name="Evidence-AssertionIDRef" type="wssec:SamlNCName" minOccurs="0" maxOccurs="unbounded"/>
      <xs:element name="Evidence-AssertionURIRef" type="wssec:SamlUri" minOccurs="0" maxOccurs="unbounded"/>
      <xs:element name="Evidence-Assertion" type="wssec:SamlAppExtPt" minOccurs="0" maxOccurs="unbounded"/>
      -->
    </xs:sequence>
  </xs:complexType>
  <xs:complexType name="ActionType">
    <xs:sequence>
      <xs:element name="Action-NameSpace-Attribute" type="wssec:SamlUri" minOccurs="0"/>
      <xs:element name="value" type="wssec:SamlString">
        <xs:annotation>
          <xs:documentation>This is the value of the Action element instance</xs:documentation>
        </xs:annotation>
      </xs:element>
    </xs:sequence>
  </xs:complexType>
  <xs:complexType name="Advice-1dotx">
    <xs:sequence>
      <xs:element name="AssertionIDReference" type="wssec:SamlNCName" minOccurs="0" maxOccurs="unbounded"/>
      <xs:element name="Assertion" type="wssec:SamlAppExtPt" minOccurs="0" maxOccurs="unbounded"/>
      <!-- deferred
      <xs:element name="AnyAttributes" type="wssec:SamlAppExtPt" minOccurs="0" maxOccurs="unbounded"/>
      -->
    </xs:sequence>
  </xs:complexType>
  <xs:complexType name="Advice-2dot0">
    <xs:sequence>
      <xs:element name="AssertionIDRef" type="wssec:SamlNCName" minOccurs="0" maxOccurs="unbounded"/>
      <xs:element name="AssertionURIRef" type="wssec:SamlUri" minOccurs="0" maxOccurs="unbounded"/>
      <xs:element name="Assertion" minOccurs="0" maxOccurs="unbounded">
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="wssec:SamlAppExtPt">
              <xs:sequence>
                <xs:element name="encryptAssertion" type="xs:boolean" default="false" minOccurs="0">
                  <xs:annotation>
                    <xs:documentation>Indicates if associated Assertion is to be encrypted</xs:documentation>
                  </xs:annotation>
                </xs:element>
              </xs:sequence>
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>
      <!-- deferred
      <xs:element name="AnyAttributes" type="wssec:SamlAppExtPt" minOccurs="0" maxOccurs="unbounded"/>
      -->
    </xs:sequence>
  </xs:complexType>
  <xs:complexType name="ConditionsInfo-1dotx">
    <xs:sequence>
      <xs:element name="AudienceRestrictionCondition-Audience" type="wssec:SamlUri" minOccurs="0" maxOccurs="unbounded"/>
      <xs:element name="DoNotCacheCondition" type="wssec:EmptyType" nillable="true" minOccurs="0"/>
      <!-- deferred
      <xs:element name="Condition" type="wssec:SamlAppExtPt" minOccurs="0" maxOccurs="unbounded">
        <xs:annotation>
          <xs:documentation>
            Extension Point.
            Application may add multiple Condition elements with their own semantics here as long as it is valid XML.
          </xs:documentation>
        </xs:annotation>
      </xs:element>
      -->
    </xs:sequence>
  </xs:complexType>
  <xs:complexType name="ConditionsInfo-2dot0">
    <xs:sequence>
      <xs:element name="AudienceRestriction-Audience" type="wssec:SamlUri" minOccurs="0" maxOccurs="unbounded">
        <xs:annotation>
          <xs:documentation>Specifies that the assertion is addressed to a particular audience.</xs:documentation>
        </xs:annotation>
      </xs:element>
      <xs:element name="OneTimeUse" type="wssec:EmptyType" nillable="true" minOccurs="0">
        <xs:annotation>
          <xs:documentation>Assertion SHOULD be used immediately and MUST NOT be retained for future use.</xs:documentation>
        </xs:annotation>
      </xs:element>
      <!-- deferred
      <xs:element name="ProxyRestriction-Audience" type="wssec:SamlUri"/>
      <xs:element name="ProxyRestriction-Count" type="xs:nonNegativeInteger">
        <xs:annotation>
          <xs:documentation>Attribute. No clear on its semantics.</xs:documentation>
        </xs:annotation>
      </xs:element>
      <xs:element name="Condition" type="wssec:SamlAppExtPt">
        <xs:annotation>
          <xs:documentation>
            Extension Point.
            Application may add multiple Condition elements with their own semantics here as long as it is valid XML.
          </xs:documentation>
        </xs:annotation>
      </xs:element>
      -->
    </xs:sequence>
  </xs:complexType>
  <xs:complexType name="AttributeStatementV1dotx">
    <xs:sequence>
      <xs:element name="Subject-NameIdentifier-NameQualifier-Attribute" type="wssec:SamlString" minOccurs="0">
        <!-- constraint: if SubjectConfirmation ConfirmationMethod is not present then Subject-NameIdentifier must be defined -->
      </xs:element>
      <xs:element name="Subject-NameIdentifier-Format-Attribute" type="wssec:NameIdFormatType" minOccurs="0">
        <!-- constraint: if SubjectConfirmation ConfirmationMethod is not present then Subject-NameIdentifier must be defined -->
      </xs:element>
      <xs:element name="Subject-NameIdentifier" type="wssec:SamlString" minOccurs="0"/>
      <xs:element name="Subject-SubjectConfirmation" type="wssec:V1-SubjectConfirmationType" minOccurs="0">
        <!-- constraint: if Subject-NameIdentifier is not populated then Subject-SubjectConfirmation MUST be populated -->
      </xs:element>
      <xs:element name="Attribute" minOccurs="0" maxOccurs="unbounded">
        <xs:annotation>
          <xs:documentation>
            Allows application developer to specify how a SAML Attribute element should be generated from its individual pieces.
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:sequence>
            <xs:element name="AttributeName" type="wssec:SamlString"/>
            <xs:element name="AttributeNamespace" type="wssec:SamlAttributeNamespaceUri"/>
            <xs:element name="AttributeValue" type="wssec:SamlAppExtPt" maxOccurs="unbounded"/>
          </xs:sequence>
        </xs:complexType>
      </xs:element>
      <xs:element name="AttributesFromWorkflow" type="wssec:AttributesFromWorkflowType" minOccurs="0">
        <xs:annotation>
          <xs:documentation>
            Allows application developer to build one or more SAML Attribute elements in their workflow and have them package within the
            SAML Attribute assertion being generated.
            Application is totally responsible for ensuring that the SAML Attribute elements being supplied are valid within the SAML 
            assertion being generated, e.g., all prefixes are defined.
          </xs:documentation>
        </xs:annotation>
      </xs:element>
      <!-- constraint: REQUIRED either ((one or more Attribute elements) OR (AttributesFromWorkflow element)) must be populated -->
    </xs:sequence>
  </xs:complexType>
  <xs:complexType name="AttributeStatementV2dot0">
    <xs:sequence>
      <xs:element name="Attribute" minOccurs="0" maxOccurs="unbounded">
        <xs:annotation>
          <xs:documentation>
            Allows application developer to specify how a SAML Attribute element should be generated from its individual pieces.
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:sequence>
            <xs:element name="Name-attribute" type="wssec:SamlString"/>
            <xs:element name="NameFormat-attribute" type="wssec:NameFormatType" minOccurs="0"/>
            <xs:element name="FriendlyName-attribute" type="wssec:SamlString" minOccurs="0"/>
            <!-- deferred until someone shows actual need for this
            <xs:element name="AnyAttribute" type="wssec:SamlString" minOccurs="0" maxOccurs="unbounded">
              <xs:annotation>
                <xs:documentation>Standard allows application to supply any attribute name/value here.</xs:documentation>
              </xs:annotation>
            </xs:element>
            -->
            <xs:element name="AttributeValue" type="wssec:SamlAppExtPt" minOccurs="0" maxOccurs="unbounded"/>
            <xs:element name="encryptAttribute" type="xs:boolean" default="false" minOccurs="0">
              <xs:annotation>
                <xs:documentation>Indicates if associated Attribute is to be encrypted</xs:documentation>
              </xs:annotation>
              <!-- constraint: if encryptAttribute is TRUE then the encyptAssertion must be FALSE -->
            </xs:element>
          </xs:sequence>
        </xs:complexType>
      </xs:element>
      <xs:element name="AttributesFromWorkflow" type="wssec:AttributesFromWorkflowType" minOccurs="0">
        <xs:annotation>
          <xs:documentation>
            Allows application developer to build one or more SAML Attribute elements in their workflow and have them package within the
            SAML Attribute assertion being generated.
            Application is totally responsible for ensuring that the SAML Attribute elements being supplied are valid within the SAML 
            assertion being generated, e.g., all prefixes are defined.
          </xs:documentation>
        </xs:annotation>
      </xs:element>
      <!-- constraint: REQUIRED either ((one or more Attribute elements) OR (AttributesFromWorkflow element)) must be populated -->
    </xs:sequence>
  </xs:complexType>
  <xs:simpleType name="ConfirmationMethodType">
    <xs:restriction base="xs:anyURI">
      <xs:enumeration value="urn:oasis:names:tc:SAML:1.0:cm:sender-vouches">
        <xs:annotation>
          <xs:documentation>
            Indicates that no other information is available about the context of use of the assertion. The relying party SHOULD utilize 
            other means to determine if it should process the assertion further, subject to optional constraints on confirmation using 
            the attributes that MAY be present in the SubjectConfirmationData element.
          </xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="urn:oasis:names:tc:SAML:1.1:cm:sender-vouches">
        <xs:annotation>
          <xs:documentation>
            Indicates that no other information is available about the context of use of the assertion. The relying party SHOULD utilize 
            other means to determine if it should process the assertion further, subject to optional constraints on confirmation using 
            the attributes that MAY be present in the SubjectConfirmationData element.
          </xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="urn:oasis:names:tc:SAML:2.0:cm:sender-vouches">
        <xs:annotation>
          <xs:documentation>
            Indicates that no other information is available about the context of use of the assertion. The relying party SHOULD utilize 
            other means to determine if it should process the assertion further, subject to optional constraints on confirmation using 
            the attributes that MAY be present in the SubjectConfirmationData element.
          </xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="urn:oasis:names:tc:SAML:1.0:cm:bearer">
        <xs:annotation>
          <xs:documentation>
            The subject of the assertion is the bearer of the assertion, subject to optional constraints on confirmation using the attributes 
            that MAY be present in the SubjectConfirmationData element.
          </xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="urn:oasis:names:tc:SAML:1.1:cm:bearer">
        <xs:annotation>
          <xs:documentation>
            The subject of the assertion is the bearer of the assertion, subject to optional constraints on confirmation using the attributes 
            that MAY be present in the SubjectConfirmationData element.
          </xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="urn:oasis:names:tc:SAML:2.0:cm:bearer">
        <xs:annotation>
          <xs:documentation>
            The subject of the assertion is the bearer of the assertion, subject to optional constraints on confirmation using the attributes 
            that MAY be present in the SubjectConfirmationData element.
          </xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="urn:oasis:names:tc:SAML:1.0:cm:artifact">
        <xs:annotation>
          <xs:documentation>
              Artifact Resolution protocol for dereferencing a SAML artifact into a corresponding protocol message.
          </xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="urn:oasis:names:tc:SAML:1.1:cm:artifact">
        <xs:annotation>
          <xs:documentation>
            Artifact Resolution protocol for dereferencing a SAML artifact into a corresponding protocol message.
          </xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="urn:oasis:names:tc:SAML:2.0:cm:artifact">
        <xs:annotation>
          <xs:documentation>
            Artifact Resolution protocol for dereferencing a SAML artifact into a corresponding protocol message.
          </xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="urn:oasis:names:tc:SAML:1.0:cm:holder-of-key">
        <xs:annotation>
          <xs:documentation>
            The holder of a specified key is considered to be the subject of the assertion by the asserting party.
            When this is used one or more associated KeyInfo elements MUST be defined.
          </xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="urn:oasis:names:tc:SAML:1.1:cm:holder-of-key">
        <xs:annotation>
          <xs:documentation>
            The holder of a specified key is considered to be the subject of the assertion by the asserting party.
            When this is used one or more associated KeyInfo elements MUST be defined.
          </xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="urn:oasis:names:tc:SAML:2.0:cm:holder-of-key">
        <xs:annotation>
          <xs:documentation>
            The holder of a specified key is considered to be the subject of the assertion by the asserting party.
            When this is used one or more associated KeyInfo elements MUST be defined.
          </xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <!-- deferred  
      <xs:enumeration value="urn:mace:shibboleth:SAML:1.0:cm:nonbrowser">
        <xs:annotation>
          <xs:documentation>
            The subject of the assertion is the party that presented a SAML artifact, which the relying party used to obtain the assertion from
            the party that created the artifact.
          </xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      -->
    </xs:restriction>
  </xs:simpleType>
  <xs:complexType name="HolderOfKeyKeyInfo">
    <xs:sequence>
      <xs:element name="holderOfKeyKeyInfoType" type="wssec:HolderOfKeyKeyInfoType" maxOccurs="unbounded">
        <xs:annotation>
          <xs:appinfo>Would implement with vector of flags with X509Certificate defaulted on.</xs:appinfo>
        </xs:annotation>
        <!-- constraint: When multiple holderOfKeyKeyInfoType elements are defined, only consistent elements can be defined.
                         1) ONLY elements with (X509Certificate OR X509SubjectName OR X509SKI or X509Thunmbprint OR
                                                X509RSAKeyValue OR X509DSAKeyValue OR X509IssuerSerialNumber OR KeyName
                                               ) AND 
                                               ((X509RSAKeyValue AND X509DSAKeyValue) can NOT both be specified)
                         2) ONLY elements with (KeyName OR KeyValue)
                         3) No other elements with (BinarySecret) 
        -->
      </xs:element>
      <xs:element name="clientCredentialSource" minOccurs="0">
        <xs:annotation>
          <xs:documentation>Identifies source of client credential to be used in holder-of-key checking</xs:documentation>
        </xs:annotation>
        <!-- constraint: 
             1) NOT PRESENT if (HolderOfKeyKeyInfoType == BinarySecret)
             2) MUST be POPULATED if (HolderOfKeyKeyInfoType == (X509Certifiate OR X509SubjectName OR X509SKI OR
                                                                 X509ThumbprintSha2 OR X509RSAKeyValue OR X509DSAKeyValue OR
                                                                 X509IssuerSerialNumber OR KeyName OR KeyValue
                                                                )
                                     )
                Note: boolean expression equivalent to (HolderOfKeyKeyInfoType != BinarySecret)
        -->
        <xs:simpleType>
          <xs:restriction base="xs:string">
            <xs:enumeration value="bstFromVerifyOperation">
              <xs:annotation>
                <xs:documentation>X.509 certificate resolved by preceding WS-Security Verify operation.</xs:documentation>
              </xs:annotation>
              <!-- constraint: only ALLOWED if (holderOfKeyKeyInfoType == (X509Certifiate OR X509SubjectName OR X509SKI OR
                                                                           X509ThumbprintSha2 OR X509RSAKeyValue OR KeyName OR
                                                                           X509DSAKeyValue OR X509IssuerSerialNumber)
                                               )
              -->
            </xs:enumeration>
            <xs:enumeration value="peerCertificateFromSsl">
              <xs:annotation>
                <xs:documentation>Peer certificate HTTP IS SSL/TLS session.</xs:documentation>
                <xs:appinfo>Certificate extracted directly for incoming request metadata.</xs:appinfo>
              </xs:annotation>
              <!-- constraint: only ALLOWED if (holderOfKeyKeyInfoType == (X509Certifiate OR X509SubjectName OR X509SKI OR
                                                                           X509ThumbprintSha2 OR X509RSAKeyValue OR KeyName OR
                                                                           X509DSAKeyValue OR X509IssuerSerialNumber)
                                               )
              -->
            </xs:enumeration>
            <xs:enumeration value="certificateFromWorkflow">
              <xs:annotation>
                <xs:documentation>
                  Authenticated X.509 certificate from Workflow. This normally utilized by application saving the peer 
                  certificate from HTTP IS SSL/TLS session. 
                  
                  This is necessary because a WS-Security verify action located on invoke request or response leg can not access 
                  metadata on incoming HTTP IS. Copying that to the invoke metadata could confuse/break HTTP IA using SSL/TLS.
                </xs:documentation>
              </xs:annotation>
              <!-- constraint: only ALLOWED if (holderOfKeyKeyInfoType == (X509Certifiate OR X509SubjectName OR X509SKI OR
                                                                           X509ThumbprintSha2 OR X509RSAKeyValue OR KeyName OR
                                                                           X509DSAKeyValue OR X509IssuerSerialNumber)
                                               )
              -->
            </xs:enumeration>
            <!-- deferred
            <xs:enumeration value="usernameFromWorkflow">
              <xs:annotation>
                <xs:documentation>Authenticated username from workflow.</xs:documentation>
                <xs:appinfo>Partial kludge because of difficulty getting authenticated username from preceding AAA action.</xs:appinfo>
              </xs:annotation>
            </xs:enumeration>
            <xs:enumeration value="symmetricKeyFromVerifyOperation">
              <xs:annotation>
                <xs:documentation>Username or Symmetric keyname resolved by preceding WS-Security Signature operation.</xs:documentation>
              </xs:annotation>
              constraint: only ALLOWED if (holderOfKeyKeyInfoType == (KeyName OR KeyValue))
            </xs:enumeration>
            -->
          </xs:restriction>
        </xs:simpleType>
        <!-- constraint: if multiple subject confirmation methods using holder-of-key are present then their clientCedentialSource must be the same. -->
      </xs:element>
      <xs:element name="importedClientCredential" type="xs:string" default="internal:importedClientCredential" minOccurs="0">
        <xs:annotation>
          <xs:documentation>
            This value uniquely identify this user supplied data instance.
            
            This value is used to identify to the developer what information needs to be resolved.
            This value is also used as the name string in the name/value pair on the extension function optional parameter.
          </xs:documentation>
          <xs:appinfo>
            When AAA policy with this element is bound to an action, action builder must prompt for the associated client credential.
            This client credential can come from one of the following sources:
            1) if (extectedHolderOfKeyKeyInfo is X509Certificate, X509SKI, X509SubjectName, X509IssuerSerialNumber, RSAKeyValue, DSAKeyValue or KeyName)
               then peer X509 certificate from HTTP IS metadata ALLOWED.
            2) Exported resolved security token from a preceding successfully processed WS-Security signature verification operation ALLOWED 
               a) If the operation was X509 token type, the exported data cache variable will be a base64 encoded DER certificate. 
               b) If the operation was username token type, the exported data cache variable will be the resolved username. (deferred to future release)
               c) If the operation was symmetric token type, the exported data cache variable will be the keyname. (deferred to future release)
            3) Extracted identity from a preceding successfuly processed AAA action ALLOWED (deferred to future release)
               If ((extectedHolderOfKeyKeyInfo is KeyName) AND 
                   (extract identity mechanism of the preceding AAA action is 
                    (usernameFromHttpBasicAuthentication OR usernameFromSecurityHeader OR derivedUsernameFromSecurityheader OR usernamePasswordFromWorkflow)
                   )
                  )
          </xs:appinfo>
        </xs:annotation>
        <!-- constraint: 
             1) ONLY PRESENT when subjectConfirmationMethod is some form of holder-of-key.
             2) NOT PRESENT if (HolderOfKeyKeyInfoType == BinarySecret)
             3) MUST be POPULATED if (HolderOfKeyKeyInfoType == (X509Certifiate OR X509SubjectName OR X509SKI OR
                                                                 X509ThumbprintSha2 OR X509RSAKeyValue OR X509DSAKeyValue OR
                                                                 X509IssuerSerialNumber OR KeyName OR KeyValue
                                                                )
                                     )
        -->
        <!-- contraint: Service Designer policy editor must ensure that each imported client credential has a unique value in each policy. 
                        Since I can not see how things could work if different multiple client credentials are allowed,  I am restrict us
                        to only have a single importedClientCredential being used in the multiple SubjectConfrimation elements.
                        This check really be needed.
        -->
      </xs:element>
    </xs:sequence>
    <xs:attribute name="type" use="required" fixed="string">
      <xs:annotation>
        <xs:appinfo>Not to be displayed. Must be populated by policy editor.</xs:appinfo>
      </xs:annotation>
      <xs:simpleType>
        <xs:restriction base="xs:string"/>
      </xs:simpleType>
    </xs:attribute>
  </xs:complexType>
  <xs:simpleType name="HolderOfKeyKeyInfoType">
    <xs:restriction base="xs:string">
      <xs:enumeration value="X509Certificate">
        <xs:annotation>
          <xs:documentation>
            The full client X509 Certificate used to authenticate the client to the Security Token Service (STS) should be package within the 
            incoming SAML assertion that is using a holder-of-key confirmation method.
            The certificate should normally be in based-64 DER format.
          </xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="X509SubjectName">
        <xs:annotation>
          <xs:documentation>
            The subject name of the client certificate used to authenticate the client to the Security Token Service (STS) should 
            be package within the incoming SAML assertion that is using a holder-of-key confirmation method.
          </xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="X509SKI">
        <xs:annotation>
          <xs:documentation>
            The subject key identifier (SKI) of the client certificate used to authenticate the client to the Security Token Service (STS) should 
            be package within the incoming SAML assertion that is using a holder-of-key confirmation method. It is an error if the client certificate
            does not contain the optional SKI attribute.
          </xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="ThumbprintSha1">
        <xs:annotation>
          <xs:documentation>
            X509Data: ThumbprintSHA1 from associated certificate.
            The ThumbrintSHA1 is derived from the certificate. 
            It is also referred to s the SHA-1 Fingerprint in most browsers and X.509 PKI systems and our local keystore query mechanism.
          </xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="RSAKeyValue">
        <xs:annotation>
          <xs:documentation>
            For X509 RSA certificate, the public key of the client certificate used to authenticate the client to the Security Token Service (STS) should 
            be package within the incoming SAML assertion that is using a holder-of-key confirmation method.
            Only the modulus and exponent of the public key is packaged.
          </xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="DSAKeyValue">
        <xs:annotation>
          <xs:documentation>
            For X509 DSA certificate, the public key of the client certificate used to authenticate the client to the Security Token Service (STS) should 
            be package within the incoming SAML assertion that is using a holder-of-key confirmation method.
          </xs:documentation>
        </xs:annotation>
        <!-- deferred until some future release when it is actually needed by someone -->
      </xs:enumeration>
      <xs:enumeration value="BinarySecret">
        <xs:annotation>
          <xs:documentation>A raw symmetric key value.</xs:documentation>
          <xs:appinfo>
            We will automatically always generate a new random symmetric key for each SAML assertion being created.
            The symmetric key will be 32 bytes long, i.e., big enough for use with largest symmetric cipher, AES-256.
            Can be truncerated to work with any other encryption or signature symmetric algorithm.
          </xs:appinfo>
        </xs:annotation>
        <!-- constraint: NOT ALLOWED if (saml version == v1.0) -->
      </xs:enumeration>
      <xs:enumeration value="KeyName">
        <xs:annotation>
          <xs:documentation>
            The some information assocaited with the client certificate used to authenticate the client to the Security Token Service (STS) should 
            be package within the incoming SAML assertion that is using a holder-of-key confirmation method.
            
            This mechanism not recommended because the associated need for coordinated namespaces and certificate authorities. 
            Additionally, there is potential ambiguities about what type of token identifier is being package under KeyName.
            
            For example, some application package the X509 subject name, while others package the username ithin the KeyInfo KeyName element.
            Note: the X509 subject name, could be unambiguously packaged with a KeyInfo X509Data X509SubjectName element.
            There is no way to determine at AAA policy editor or action builder time that inconsistent token types have been specified, i.e., strictly
            runtime checking only.
          </xs:documentation>
          <xs:appinfo>
            For X509 token type, we will always extract the certificate subject name for the comparison.
          </xs:appinfo>
        </xs:annotation>
        <!-- deferred until some future release when it is actually needed by someone -->
      </xs:enumeration>
      <!-- deferred
      <xs:enumeration value="KeyValue">
        <xs:annotation>
          <xs:documentation>
            If X509 certificate token type is being supported then RSAKeyValue or DSAKeyValue enumeration values must be utilized. This eliminated any
            ambiguity about what type of key values is being passed.
            For symmetric key/username password, the actual key/password is packaged within the KeyValue. However, this entire KeyInfo element is encrypted 
            via either a RSA Key Transport or a DH Key Agreement algorithm. [Support for symmetric keys will be deferred to some future release.]
          </xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="X509IssuerSerialNumber">
        <xs:annotation>
          <xs:documentation>
            The issuer and serial number of the client certificate used to authenticate the client to the Security Token Service (STS) should 
            be package within the incoming SAML assertion that is using a holder-of-key confirmation method.
            Deferring because of issues about how we will encode the two separate peices of information as a single contiguous character string.
          </xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      -->
    </xs:restriction>
  </xs:simpleType>
  <xs:simpleType name="NameIdFormatType">
    <xs:restriction base="xs:anyURI">
      <xs:annotation>
        <xs:documentation>
          All of the following enumerations valid for SAML 2.0, including the 1.1 URIs in various standard documents.
          In particular, some places appear to want the 2.0 and some want the 1.1 and 1.0 unspecified URI. 
          The 1.1 is the default format value.
          As far as I can see, the application has to know what is required for their usage to correctly interwork. :(
        </xs:documentation>
      </xs:annotation>
      <xs:enumeration value="urn:oasis:names:tc:SAML:1.1:nameid-format:unspecified">
        <xs:annotation>
          <xs:documentation>The interpretation of the content of the element is left to individual implementations.</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="urn:oasis:names:tc:SAML:1.0:nameid-format:unspecified">
        <xs:annotation>
          <xs:documentation>The interpretation of the content of the element is left to individual implementations.</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="urn:oasis:names:tc:SAML:2.0:nameid-format:unspecified">
        <xs:annotation>
          <xs:documentation>The interpretation of the content of the element is left to individual implementations.</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="urn:oasis:names:tc:SAML:1.1:nameid-format:entity">
        <xs:annotation>
          <xs:documentation>
            Indicates that the content of the element is the identifier of an entity that provides SAML-based services (such as a SAML authority, 
            requester, or responder) or is a participant in SAML profiles (such as a service provider supporting the browser SSO profile). Such 
            an identifier can be used in the Issuer element to identify the issuer of a SAML request, response, or assertion, or within the NameID 
            element to make assertions about system entities that can issue SAML requests, responses, and assertions. It can also be used in 
            other elements and attributes whose purpose is to identify a system entity in various protocol exchanges.
            
            The syntax of such an identifier is a URI of not more than 1024 characters in length. It is RECOMMENDED that a system entity use a 
            URL containing its own domain name to identify itself.
          </xs:documentation>
          <!-- constraint: The NameQualifier, SPNameQualifier, and SPProvidedID attributes MUST be omitted. -->
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="urn:oasis:names:tc:SAML:2.0:nameid-format:entity">
        <xs:annotation>
          <xs:documentation>
            Indicates that the content of the element is the identifier of an entity that provides SAML-based services (such as a SAML authority, 
            requester, or responder) or is a participant in SAML profiles (such as a service provider supporting the browser SSO profile). Such 
            an identifier can be used in the Issuer element to identify the issuer of a SAML request, response, or assertion, or within the NameID 
            element to make assertions about system entities that can issue SAML requests, responses, and assertions. It can also be used in 
            other elements and attributes whose purpose is to identify a system entity in various protocol exchanges.
            
            The syntax of such an identifier is a URI of not more than 1024 characters in length. It is RECOMMENDED that a system entity use a 
            URL containing its own domain name to identify itself.
          </xs:documentation>
          <!-- constraint: The NameQualifier, SPNameQualifier, and SPProvidedID attributes MUST be omitted. -->
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="urn:oasis:names:tc:SAML:1.1:nameid-format:emailAddress">
        <xs:annotation>
          <xs:documentation>
            Indicates that the content of the element is in the form of an email address, specifically "addr-spec" as defined in IETF RFC 2822 
            Section 3.4.1. An addr-spec has the form local-part@domain. Note that an addr-spec has no phrase (such as a common name) before 
            it, has no comment (text surrounded in parentheses) after it, and is not surrounded by "@lt;" and "@gt;".
          </xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="urn:oasis:names:tc:SAML:1.1:nameid-format:X509SubjectName">
        <xs:annotation>
          <xs:documentation>
            Indicates that the content of the element is in the form specified for the contents of the ds:X509SubjectName element in the XML 
            Signature Recommendation [XMLSig]. Implementors should note that the XML Signature specification specifies encoding rules for 
            X.509 subject names that differ from the rules given in IETF RFC 2253
          </xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="urn:oasis:names:tc:SAML:1.1:nameid-format:WindowsDomainQualifiedName">
        <xs:annotation>
          <xs:documentation>
            Indicates that the content of the element is a Windows domain qualified name. A Windows domain qualified user name is a string 
            of the form "DomainName\UserName". The domain name and "\" separator MAY be omitted.
          </xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="urn:oasis:names:tc:SAML:2.0:nameid-format:persistent">
        <xs:annotation>
          <xs:documentation>
            Indicates that the content of the element is a persistent opaque identifier for a principal that is specific to an identity provider and a service 
            provider or affiliation of service providers. Persistent name identifiers generated by identity providers MUST be constructed using 
            pseudo-random values that have no discernible correspondence with the subject's actual identifier (for example, username). The intent is to
            create a non-public, pair-wise pseudonym to prevent the discovery of the subject's identity or activities. Persistent name identifier values 
            MUST NOT exceed a length of 256 characters.
            
            The element's NameQualifier attribute, if present, MUST contain the unique identifier of the identity provider that generated the identifier. It MAY
            be omitted if the value can be derived from the context of the message containing the element, such as the issuer of a protocol message or an
            assertion containing the identifier in its subject. Note that a different system entity might later issue its own protocol message or assertion
            containing the identifier; the NameQualifier attribute does not change in this case, but MUST continue to identify the entity that originally created
            the identifier (and MUST NOT be omitted in such a case).
            
            The element's SPNameQualifier attribute, if present, MUST contain the unique identifier of the service provider or affiliation of providers for whom
            the identifier was generated. It MAY be omitted if the element is contained in a message intended only for consumption directly by the service
            provider, and the value would be the unique identifier of that service provider.
            
            The element's SPProvidedID attribute MUST contain the alternative identifier of the principal most recently set by the service provider or affiliation, 
            if any. If no such identifier has been established, then the attribute MUST be omitted.
            
            Persistent identifiers are intended as a privacy protection mechanism; as such they MUST NOT be shared in clear text with providers other than 
            the providers that have established the shared identifier. Furthermore, they MUST NOT appear in log files or similar locations without appropriate 
            controls and protections. Deployments without such requirements are free to use other kinds of identifiers in their SAML exchanges, but MUST 
            NOT overload this format with persistent but non-opaque values Note also that while persistent identifiers are typically used to reflect an account 
            linking relationship between a pair of providers, a service provider is not obligated to recognize or make use of the long term nature of the persistent 
            identifier or establish such a link. Such a "one-sided" relationship is not discernibly different and does not affect the behavior of the 
            identity provider.
            For any processing rules specific to persistent identifiers in the protocols defined in this specification.
            
            Finally, note that the NameQualifier and SPNameQualifier attributes indicate directionality of creation, but not of use. If a persistent identifier is created 
            by a particular identity provider, the NameQualifier attribute value is permanently established at that time. If a service provider that receives such an 
            identifier takes on the role of an identity provider and issues its own assertion containing that identifier, the NameQualifier attribute value does not 
            change (and would of course not be omitted). It might alternatively choose to create its own persistent identifier to represent the principal and link the 
            two values. This is a deployment decision.
          </xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="urn:oasis:names:tc:SAML:2.0:nameid-format:transient">
        <xs:annotation>
          <xs:documentation>
            Indicates that the content of the element is an identifier with transient semantics and SHOULD be treated as an opaque and temporary value by 
            the relying party. Transient identifier values MUST be generated in accordance with the rules for SAML identifiers, and MUST NOT exceed a length
            of 256 characters.
            
            The NameQualifier and SPNameQualifier attributes MAY be used to signify that the identifier represents a transient and temporary pair-wise identifier. 
          </xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="urn:oasis:names:tc:SAML:2.0:nameid-format:encrypted">
        <xs:annotation>
          <xs:documentation>
            Indicates in an Authentication Request protocol request that a specific entity should be encrypted.
          </xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="urn:oasis:names:tc:SAML:2.0:nameid-format:kerberos">
        <xs:annotation>
          <xs:documentation>
            Indicates that the content of the element is in the form of a Kerberos principal name using the format name[/instance]@REALM. 
            The syntax, format and characters allowed for the name, instance, and realm are described in IETF RFC 1510.
          </xs:documentation>
        </xs:annotation>
      </xs:enumeration>
    </xs:restriction>
  </xs:simpleType>
  <xs:simpleType name="AuthenticationMethodType">
    <xs:restriction base="xs:anyURI">
      <xs:enumeration value="urn:oasis:names:tc:SAML:1.0:am:password">
        <xs:annotation>
          <xs:documentation>
            Priniciple is authenticated through use of a password to an authentication authority using password over an unprotected HTTP session.
          </xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="urn:oasis:names:tc:SAML:2.0:ac:classes:Password">
        <xs:annotation>
          <xs:documentation>
            Priniciple is authenticated through use of a password to an authentication authority using password over an unprotected HTTP session.
          </xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="urn:oasis:names:tc:SAML:1.0:am:unspecified">
        <xs:annotation>
          <xs:documentation>Authentication was performed by unspecified means.</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="urn:oasis:names:tc:SAML:1.1:am:unspecified">
        <xs:annotation>
          <xs:documentation>Authentication was performed by unspecified means.</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="urn:oasis:names:tc:SAML:2.0:ac:classes:unspecified">
        <xs:annotation>
          <xs:documentation>Authentication was performed by unspecified means.</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="urn:oasis:names:tc:SAML:1.0:am:X509-PKI">
        <xs:annotation>
          <xs:documentation>
            Priniciple is authenticated by means of a digital signature where the key was validated as part of the X.509 Public Key Infrastructure.
          </xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="urn:oasis:names:tc:SAML:2.0:ac:classes:X509">
        <xs:annotation>
          <xs:documentation>
            Priniciple is authenticated by means of a digital signature where the key was validated as part of the X.509 Public Key Infrastructure.
          </xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="urn:ietf:rfc:2246">
        <xs:annotation>
          <xs:documentation>Principle authenticate using successful SSL/TLS transport layer authentication.</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="urn:oasis:names:tc:SAML:2.0:ac:classes:TLSClient">
        <xs:annotation>
          <xs:documentation>
            Priniciple is authenticated by client certificate secured with SSL/TLS transport layer.
          </xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="urn:oasis:names:tc:SAML:2.0:ac:classes:PasswordProtectedTransport">
        <xs:annotation>
          <xs:documentation>
            Priniciple is authenticated through use of a password to an authentication authority using password over a protected HTTP session.
          </xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="urn:oasis:names:tc:SAML:2.0:ac:classes:InternetProtocol">
        <xs:annotation>
          <xs:documentation>Principle is authenticated though the use of a provided IP address.</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="urn:oasis:names:tc:SAML:2.0:ac:classes:SoftwarePKI">
        <xs:annotation>
          <xs:documentation>
            Priniciple uses an X.509 certificatestored in software to authenticate to the authentication authority.
          </xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="urn:oasis:names:tc:SAML:1.0:am:SPKI">
        <xs:annotation>
          <xs:documentation>
            Priniciple is authenticated by means of a digital signature where the key was validated as part of the SPKI Infrastructure.
          </xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="urn:oasis:names:tc:SAML:1.0:am:HardwareToken">
        <xs:annotation>
          <xs:documentation>Priniciple is authenticated by means of a hardware based token mechanism.</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="urn:oasis:names:tc:SAML:1.0:am:PGP">
        <xs:annotation>
          <xs:documentation>
            Priniciple is authenticated by means of a digital signature where the key was validated as part of the PGP Public Key Infrastructure.
          </xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="urn:ietf:rfc:2945">
        <xs:annotation>
          <xs:documentation>Principal authentication using Secure Remote Password (SRP) protocol.</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="urn:oasis:names:tc:SAML:1.0:am:XKMS">
        <xs:annotation>
          <xs:documentation>Authentication was performed by using XML Key Management Specification.</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="urn:oasis:names:tc:SAML:1.1:am:XKMS">
        <xs:annotation>
          <xs:documentation>Authentication was performed by using XML Key Management Specification.</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="urn:oasis:names:tc:SAML:2.0:ac:classes:InternetProtocolPassword">
        <xs:annotation>
          <xs:documentation>
            Principle is authenticated though the use of a provided IP address in addition to a username/password.
          </xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="urn:oasis:names:tc:SAML:2.0:ac:classes:Kerberos">
        <xs:annotation>
          <xs:documentation>
            Principle is authenticated though the use of a password to a local authentication authority to acquire a Kerberos ticket.
            The Kerberos ticket is then used for subsequent network authentication.
          </xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="urn:oasis:names:tc:SAML:2.0:ac:classes:XMLDSig">
        <xs:annotation>
          <xs:documentation>
            Priniciple is authenticated by means of a digital signature where the key was validated using XML Digital Signature specification.
          </xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="urn:oasis:names:tc:SAML:2.0:ac:classes:PGP">
        <xs:annotation>
          <xs:documentation>
            Priniciple is authenticated by means of a digital signature where the key was validated as part of the PGP Public Key Infrastructure.
          </xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="urn:oasis:names:tc:SAML:2.0:ac:classes:SPKI">
        <xs:annotation>
          <xs:documentation>
            Priniciple is authenticated by means of a digital signature where the key was validated as part of the SPKI Infrastructure.
          </xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="urn:oasis:names:tc:SAML:2.0:ac:classes:SecureRemotePassword">
        <xs:annotation>
          <xs:documentation>
            Priniciple is authenticated via Secure Remote Password as defined in RFC 2945.
          </xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="urn:oasis:names:tc:SAML:2.0:ac:classes:TimeSyncToken">
        <xs:annotation>
          <xs:documentation>
            Priniciple is authenticated through a time synchronization token.
          </xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <!-- deferred
      <xs:enumeration value="urn:oasis:names:tc:SAML:2.0:ac:classes:MobileOneFactorUnregistered">
        <xs:annotation>
          <xs:documentation>
            Reflects that no mobile customer registration procedure and that an authentication of the mobile device without requiring any
            explicit end-user interaction.Authenticates only the device and never the user. Is useful when services other than the mobile operator 
            wants to add a secure device authentication to their process.
          </xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="urn:oasis:names:tc:SAML:2.0:ac:classes:MobileTwoFactorUnregistered">
        <xs:annotation>
          <xs:documentation>
            Reflects that no mobile customer registration procedure and a two-factor based authentication, i.e., secure device and user PIN..
            Is useful when services other than the mobile operator wants to link their customer ID to a moble supplied two-factor authentication service.
          </xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="urn:oasis:names:tc:SAML:2.0:ac:classes:MobileOneFactorContract">
        <xs:annotation>
          <xs:documentation>
            Reflects mobile customer contract registration procedure and a single factor authentication, e.g., digital signing device with tamper resistent 
            memory for key storage, but not required PIN or biometrics.
          </xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="urn:oasis:names:tc:SAML:2.0:ac:classes:MobileTwoFactorContract">
        <xs:annotation>
          <xs:documentation>
            Reflects mobile customer contract registration procedure and a two-factor authentication, e.g., digital signing device with tamper resistent 
            memory for key storage and a PIN or biometrics.
          </xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="urn:oasis:names:tc:SAML:2.0:ac:classes:PreviousSession">
        <xs:annotation>
          <xs:documentation>
            Priniciple is authenticated at some point in the past using an authentication context supported by that authentication authority.
            Therefore, a significant time may have elapsed from the current request. Because of this large potential time, the mechanism used in
            the earlier authentication should not be used as part of this decision process for accessing the resource.
          </xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="urn:oasis:names:tc:SAML:2.0:ac:classes:Smartcard">
        <xs:annotation>
          <xs:documentation>
            Priniciple is authenticated by means of an authentication authority using a smart card.
          </xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="urn:oasis:names:tc:SAML:2.0:ac:classes:SmartcardPKI">
        <xs:annotation>
          <xs:documentation>
            Priniciple is authenticated by means of an authentication authority with two-factor authenticatin mechanism using a smart card with
            an enclosed private key or a PIN.
          </xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="urn:oasis:names:tc:SAML:2.0:ac:classes:Telephony">
        <xs:annotation>
          <xs:documentation>
            Priniciple is authenticated via the provisioning of a fixed line telehone number using telephony protocol such as ADSL.
          </xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="urn:oasis:names:tc:SAML:2.0:ac:classes:NomadTelephony">
        <xs:annotation>
          <xs:documentation>
            Priniciple is roaming and authenticated via the line number, a user suffix and a password element.
          </xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="urn:oasis:names:tc:SAML:2.0:ac:classes:PersonalTelephony">
        <xs:annotation>
          <xs:documentation>
            Priniciple is authenticated via the provisioning of a fixed line telehone number via fixed line telephone number and a user suffix 
            transmitted over a telephony protocol such as ADSL.
          </xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="urn:oasis:names:tc:SAML:2.0:ac:classes:AuthenticatedTelephony">
        <xs:annotation>
          <xs:documentation>
            Priniciple is authenticated via the line number, user suffix and a password element..
          </xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      -->
    </xs:restriction>
  </xs:simpleType>
  <xs:simpleType name="NameFormatType">
    <xs:restriction base="xs:anyURI">
      <xs:enumeration value="urn:oasis:names:tc:SAML:2.0:attrname-format:uri"/>
      <xs:enumeration value="urn:oasis:names:tc:SAML:2.0:attrname-format:unspecified"/>
      <xs:enumeration value="urn:oasis:names:tc:SAML:2.0:attrname-format:basic"/>
      <!-- may have the following screwed up because my french is not very good :)
      <xs:enumeration value="urn:interops:1.0:attr-policy:matchAny"/>
      <xs:enumeration value="urn:interops:1.0:attr-policy:onlyOne"/>
      -->
    </xs:restriction>
  </xs:simpleType>
  <xs:simpleType name="DecisionType">
    <xs:restriction base="xs:NMTOKEN">
      <xs:enumeration value="Permit"/>
      <xs:enumeration value="Deny"/>
      <xs:enumeration value="Indeterminate"/>
    </xs:restriction>
  </xs:simpleType>
  <xs:complexType name="SamlAppExtPt">
    <xs:annotation>
      <xs:documentation>
        Allows an application to specify a string either:
        1) a hardcored string that is know at policy defination time, or
        2) a BEPL variable associated an input parameter associated with the Ws-Security action.
      </xs:documentation>
    </xs:annotation>
    <xs:choice>
      <xs:element name="staticValue">
        <xs:simpleType>
          <xs:restriction base="xs:string">
            <xs:minLength value="1"/>
          </xs:restriction>
        </xs:simpleType>
      </xs:element>
      <xs:element name="inputFromWorkflow" type="xs:string">
        <xs:annotation>
          <xs:documentation>
            This value uniquely identify this user supplied data instance.
            
            This value is used to identify to the developer what information needs to be resolved.
            This value is also used as the name string in the name/value pair on the extension function optional parameter.
          </xs:documentation>
        </xs:annotation>
      </xs:element>
    </xs:choice>
    <xs:attribute name="type" use="required" fixed="anyType">
      <xs:annotation>
        <xs:appinfo>
          Not to be displayed. Must be populated by policy editor. 
          This should really be string now but that would cause retrofit issues.
        </xs:appinfo>
      </xs:annotation>
      <xs:simpleType>
        <xs:restriction base="xs:string"/>
      </xs:simpleType>
    </xs:attribute>
  </xs:complexType>
  <xs:complexType name="OriginalSamlAppExtPt">
    <xs:annotation>
      <xs:documentation>
        Allows an application to specify a well-formed XML fragment from either:
        1) a hardcored XML fragment that is know at policy defination time, or
        2) a BEPL variable associated an input parameter associated with the Ws-Security action.
      </xs:documentation>
    </xs:annotation>
    <xs:choice>
      <xs:element name="staticValue" type="wssec:Anything"/>
      <xs:element name="inputFromWorkflow" type="xs:string">
        <xs:annotation>
          <xs:documentation>
            This user supplied value uniquely identify this user supplied data instance.
            
            This value is used to identify to the developer what information needs to be resolved.
            This value is also used as the name string in the name/value pair on the extension function optional parameter.
          </xs:documentation>
        </xs:annotation>
      </xs:element>
    </xs:choice>
    <xs:attribute name="type" use="required" fixed="anyType">
      <xs:annotation>
        <xs:appinfo>Not to be displayed. Simplify operational code. Must be populated by policy editor.</xs:appinfo>
      </xs:annotation>
      <xs:simpleType>
        <xs:restriction base="xs:string"/>
      </xs:simpleType>
    </xs:attribute>
  </xs:complexType>
  <xs:complexType name="Anything">
    <xs:sequence>
      <xs:any namespace="##any" processContents="skip"/>
    </xs:sequence>
    <xs:anyAttribute namespace="##any" processContents="skip"/>
  </xs:complexType>
  <xs:complexType name="NameBaseIdType">
    <xs:complexContent>
      <xs:extension base="wssec:SamlString">
        <xs:sequence>
          <xs:element name="encryptID" type="xs:boolean" default="false" minOccurs="0">
            <xs:annotation>
              <xs:documentation>Indicates if associated NameID is to be encrypted.</xs:documentation>
            </xs:annotation>
            <!-- constraint: if encryptID is TRUE then encryptionInfo must be populated -->
            <!-- constraint: if encryptID is TRUE then the encyptAssertion must be FALSE -->
          </xs:element>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:complexType name="SamlNameIdFormat">
    <xs:annotation>
      <xs:documentation>
        Allows an application to specify a string either:
        1) a hardcored NameID format that is know at policy defination time, or
        2) a BEPL variable associated an input parameter associated with the Ws-Security action.
      </xs:documentation>
    </xs:annotation>
    <xs:choice>
      <xs:element name="staticValue" type="wssec:NameIdFormatType"/>
      <xs:element name="inputFromWorkflow" type="xs:string">
        <xs:annotation>
          <xs:documentation>
            This value uniquely identify this user supplied data instance.
            
            This value is used to identify to the developer what information needs to be resolved.
            This value is also used as the name string in the name/value pair on the extension function optional parameter.
          </xs:documentation>
        </xs:annotation>
      </xs:element>
    </xs:choice>
    <xs:attribute name="type" use="required" fixed="string">
      <xs:annotation>
        <xs:appinfo>Not to be displayed. Must be populated by policy editor.</xs:appinfo>
      </xs:annotation>
      <xs:simpleType>
        <xs:restriction base="xs:string"/>
      </xs:simpleType>
    </xs:attribute>
  </xs:complexType>
  <xs:complexType name="SamlString">
    <xs:annotation>
      <xs:documentation>
        Allows an application to specify a string either:
        1) a hardcored string that is know at policy defination time, or
        2) a BEPL variable associated an input parameter associated with the Ws-Security action.
      </xs:documentation>
    </xs:annotation>
    <xs:choice>
      <xs:element name="staticValue">
        <xs:simpleType>
          <xs:restriction base="xs:string">
            <xs:minLength value="1"/>
          </xs:restriction>
        </xs:simpleType>
      </xs:element>
      <xs:element name="inputFromWorkflow" type="xs:string">
        <xs:annotation>
          <xs:documentation>
            This value uniquely identify this user supplied data instance.
            
            This value is used to identify to the developer what information needs to be resolved.
            This value is also used as the name string in the name/value pair on the extension function optional parameter.
          </xs:documentation>
        </xs:annotation>
      </xs:element>
    </xs:choice>
    <xs:attribute name="type" use="required" fixed="string">
      <xs:annotation>
        <xs:appinfo>Not to be displayed. Must be populated by policy editor.</xs:appinfo>
      </xs:annotation>
      <xs:simpleType>
        <xs:restriction base="xs:string"/>
      </xs:simpleType>
    </xs:attribute>
  </xs:complexType>
  <xs:complexType name="SamlNCName">
    <xs:annotation>
      <xs:documentation>
        Allows an application to specify a NCName from either:
        1) a hardcored NCName that is know at policy defination time, or
        2) a BEPL variable associated an input parameter associated with the Ws-Security action.
      </xs:documentation>
    </xs:annotation>
    <xs:choice>
      <xs:element name="staticValue">
        <xs:simpleType>
          <xs:restriction base="xs:NCName">
            <xs:minLength value="1"/>
          </xs:restriction>
        </xs:simpleType>
      </xs:element>
      <xs:element name="inputFromWorkflow" type="xs:string">
        <xs:annotation>
          <xs:documentation>
            This value uniquely identify this user supplied data instance.
            
            This value is used to identify to the developer what information needs to be resolved.
            This value is also used as the name string in the name/value pair on the extension function optional parameter.
          </xs:documentation>
        </xs:annotation>
      </xs:element>
    </xs:choice>
    <xs:attribute name="type" use="required" fixed="NCName">
      <xs:annotation>
        <xs:appinfo>Not to be displayed. Must be populated by policy editor.</xs:appinfo>
      </xs:annotation>
      <xs:simpleType>
        <xs:restriction base="xs:string"/>
      </xs:simpleType>
    </xs:attribute>
  </xs:complexType>
  <xs:complexType name="SamlUri">
    <xs:annotation>
      <xs:documentation>
        Allows an application to specify  a URL from either:
        1) a hardcored string that is know at policy defination time, or
        2) a BEPL variable associated an input parameter associated with the Ws-Security action.
      </xs:documentation>
    </xs:annotation>
    <xs:choice>
      <xs:element name="staticValue">
        <xs:simpleType>
          <xs:restriction base="xs:anyURI">
            <xs:minLength value="1"/>
          </xs:restriction>
        </xs:simpleType>
      </xs:element>
      <xs:element name="inputFromWorkflow" type="xs:string">
        <xs:annotation>
          <xs:documentation>
            This value uniquely identify this user supplied data instance.
            
            This value is used to identify to the developer what information needs to be resolved.
            This value is also used as the name string in the name/value pair on the extension function optional parameter.
          </xs:documentation>
        </xs:annotation>
      </xs:element>
    </xs:choice>
    <xs:attribute name="type" use="required" fixed="anyURI">
      <xs:annotation>
        <xs:appinfo>Not to be displayed. Must be populated by policy editor.</xs:appinfo>
      </xs:annotation>
      <xs:simpleType>
        <xs:restriction base="xs:string"/>
      </xs:simpleType>
    </xs:attribute>
  </xs:complexType>
  <xs:complexType name="ExpirationDeltaType">
    <xs:annotation>
      <xs:documentation>
        Allows an application to specify  the expiration time (in seconds) from either:
        1) a hardcored string that is know at policy defination time, or
        2) a BEPL variable associated an input parameter associated with the Ws-Security action.
      </xs:documentation>
    </xs:annotation>
    <xs:choice>
      <xs:element name="staticValue" type="xs:unsignedInt" default="300"/>
      <xs:element name="inputFromWorkflow" type="xs:string">
        <xs:annotation>
          <xs:documentation>
            This value uniquely identify this user supplied data instance.
            
            This value is used to identify to the developer what information needs to be resolved.
            This value is also used as the name string in the name/value pair on the extension function optional parameter.
          </xs:documentation>
        </xs:annotation>
      </xs:element>
    </xs:choice>
    <xs:attribute name="type" use="required" fixed="unsignedInt">
      <xs:annotation>
        <xs:appinfo>Not to be displayed. Must be populated by policy editor.</xs:appinfo>
      </xs:annotation>
      <xs:simpleType>
        <xs:restriction base="xs:string"/>
      </xs:simpleType>
    </xs:attribute>
  </xs:complexType>
  <xs:complexType name="SamlAttributeNamespaceUri">
    <xs:annotation>
      <xs:documentation>
        Allows an application to specify  a URL from either:
        1) a hardcored string that is know at policy defination time, or
        2) a BEPL variable associated an input parameter associated with the Ws-Security action.
      </xs:documentation>
    </xs:annotation>
    <xs:choice>
      <xs:element name="staticValue">
        <xs:simpleType>
          <xs:restriction base="xs:anyURI">
            <xs:minLength value="1"/>
            <xs:pattern value="[^&#34;']*">
              <xs:annotation>
                <xs:appinfo>
                  This pattern expression is trying to protect the operational deploy code from trying to produce a malform
                  AttributeNamespace attribute value. It is normally a simple URI like: http://a/b/c/d and not something like
                  
  xmlns: sam="http://t/w/y/z".
                </xs:appinfo>
              </xs:annotation>
            </xs:pattern>
          </xs:restriction>
        </xs:simpleType>
      </xs:element>
      <xs:element name="inputFromWorkflow" type="xs:string">
        <xs:annotation>
          <xs:documentation>
            This value uniquely identify this user supplied data instance.
            
            This value is used to identify to the developer what information needs to be resolved.
            This value is also used as the name string in the name/value pair on the extension function optional parameter.
          </xs:documentation>
        </xs:annotation>
      </xs:element>
    </xs:choice>
    <xs:attribute name="type" use="required" fixed="anyURI">
      <xs:annotation>
        <xs:appinfo>Not to be displayed. Must be populated by policy editor.</xs:appinfo>
      </xs:annotation>
      <xs:simpleType>
        <xs:restriction base="xs:string"/>
      </xs:simpleType>
    </xs:attribute>
  </xs:complexType>
  <xs:complexType name="TokenFromWorkflowType">
    <xs:annotation>
      <xs:documentation>
        Allows an application to specify a BEPL variable  containing the token as a based 64 string to be specified as an 
        input parameter associated with the WS-Security action.
      </xs:documentation>
    </xs:annotation>
    <xs:choice>
      <xs:element name="inputFromWorkflow" type="xs:string">
        <xs:annotation>
          <xs:documentation>
            This value uniquely identify this user supplied data instance.
            
            This value is used to identify to the developer what information needs to be resolved.
            This value is also used as the name string in the name/value pair on the extension function optional parameter.
          </xs:documentation>
        </xs:annotation>
      </xs:element>
    </xs:choice>
    <xs:attribute name="type" use="required" fixed="string">
      <xs:annotation>
        <xs:appinfo>Not to be displayed. Must be populated by policy editor.</xs:appinfo>
      </xs:annotation>
      <xs:simpleType>
        <xs:restriction base="xs:string"/>
      </xs:simpleType>
    </xs:attribute>
  </xs:complexType>
  <xs:complexType name="SecurityObjectNameFromWorkflowType">
    <xs:annotation>
      <xs:documentation>
        Allows an application to specify a BEPL variable  containing a security object name as an 
        input parameter associated with the WS-Security action.
      </xs:documentation>
    </xs:annotation>
    <xs:choice>
      <xs:element name="inputFromWorkflow" type="xs:string">
        <xs:annotation>
          <xs:documentation>
            This value uniquely identify this user supplied data instance.
            
            This value is used to identify to the developer what information needs to be resolved.
            This value is also used as the name string in the name/value pair on the extension function optional parameter.
          </xs:documentation>
        </xs:annotation>
      </xs:element>
    </xs:choice>
    <xs:attribute name="type" use="required" fixed="string">
      <xs:annotation>
        <xs:appinfo>Not to be displayed. Must be populated by policy editor.</xs:appinfo>
      </xs:annotation>
      <xs:simpleType>
        <xs:restriction base="xs:string"/>
      </xs:simpleType>
    </xs:attribute>
    <!-- constraint: the token type must agree with the type of security object in the security config.
                     a) if (token type == X.509) then security object name must be for an Certificate security object.
                     b) if (tokentype == symmetric) then security object name must be for a SharedSecret security object whose 
                        (typeOfSharedSecret == symmetric-key).
    -->
  </xs:complexType>
  <xs:complexType name="AttributesFromWorkflowType">
    <xs:annotation>
      <xs:documentation>
        Allows an application to supply one or more Attribute elements from a BEPL variable as an input parameter
        when policy is bound to a AAA action.
        It is the application responsibility that a well-formed, valid set of one or more SAML Attribute elements have been defined.
      </xs:documentation>
    </xs:annotation>
    <xs:choice>
      <xs:element name="inputFromWorkflow" type="xs:string" default="prebuild-Attribute-elements">
        <xs:annotation>
          <xs:documentation>
            This value uniquely identify this user supplied data instance.
            
            This value is used to identify to the developer what information needs to be resolved.
            This value is also used as the name string in the name/value pair on the extension function optional parameter.
          </xs:documentation>
        </xs:annotation>
      </xs:element>
    </xs:choice>
    <xs:attribute name="type" use="required" fixed="string">
      <xs:annotation>
        <xs:appinfo>Not to be displayed. Must be populated by policy editor.</xs:appinfo>
      </xs:annotation>
    </xs:attribute>
  </xs:complexType>
  <xs:simpleType name="SamlSignatureGenerationMethod">
    <xs:annotation>
      <xs:documentation>
        What signature methods will we use when generating an enveloped X.509-based signature for the SAML assertion.
        Note: only legal algorithm is rsa-sha1. Stupid and dangerous in the long-term but this is the standard.
        Note: Adding other methods because Microsoft ADFS requires/supports other stronger signature methods.
      </xs:documentation>
    </xs:annotation>
    <xs:restriction base="xs:string">
      <xs:enumeration value="rsaWithSha1">
        <xs:annotation>
          <xs:documentation>Signature method using assymmetric RSA key with SHA1 digest.</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="rsaWithSha256">
        <xs:annotation>
          <xs:documentation>Signature method using assymmetric RSA key with SHA-256 digest.</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="rsaWithSha384">
        <xs:annotation>
          <xs:documentation>Signature method using assymmetric RSA key with SHA-384 digest.</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="rsaWithSha512">
        <xs:annotation>
          <xs:documentation>Signature method using assymmetric RSA key with SHA-512 digest.</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="rsaWithRipemd160">
        <xs:annotation>
          <xs:documentation>Signature method using assymmetric RSA key with RIPEMD-160 digest.</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="dsaWithSha1">
        <xs:annotation>
          <xs:documentation>Signature method using assymmetric DSA key with SHA1 digest.</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
    </xs:restriction>
  </xs:simpleType>
  <xs:simpleType name="SamlCanonicalGenerationMethod">
    <xs:annotation>
      <xs:documentation>Note: inclusive canonicalization not supported by SAML standard.</xs:documentation>
    </xs:annotation>
    <xs:restriction base="xs:string">
      <xs:enumeration value="C14N_exclusive">
        <xs:annotation>
          <xs:documentation>C14N Exclusive canonicalization method. Comments removed. Recommended method</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <!-- Will be added in future release. See Exclusive XML Canonicalization, Version 1.0, W3C Recommendation 18 July 2002.
           http://www.w3.org/TR/xml-exc-c14n/)
           <xs:enumeration value="C14N_exclusiveWithComments">
             <xs:annotation>
               <xs:documentation>C14N Exclusive canonicalization method. Comments retained. Not recommended.</xs:documentation>
             </xs:annotation>
           </xs:enumeration>
      -->
    </xs:restriction>
  </xs:simpleType>
  <xs:complexType name="JwsSign">
    <xs:annotation>
      <xs:documentation>JSON Web Signature (JWS): Signature Generation</xs:documentation>
    </xs:annotation>
    <xs:sequence>
      <xs:element name="keyType" type="wssec:JsonKeyType" default="symmetric"/>
      <xs:element name="signatureGenerationKeyInfoType" type="wssec:JsonKeyInfoType" default="keyId">
        <xs:annotation>
          <xs:documentation>Identifies what form of Key Information will be used in signature being generated.</xs:documentation>
        </xs:annotation>
      </xs:element>
      <xs:element name="signatureGenerationAlgorithm" type="wssec:JwsSignatureGenerationAlgType" default="HS512"/>
      <xs:element name="serializationGenerationMethod" type="wssec:JwsSerializationMethodType" default="CompactSerialization"/>
      <xs:element name="jsonSecurityToken" type="wssec:JsonSignSecurityToken"/>
    </xs:sequence>
  </xs:complexType>
  <xs:complexType name="JwsVerify">
    <xs:annotation>
      <xs:documentation>JSON Web Signature (JWS): Signature Verficiation</xs:documentation>
    </xs:annotation>
    <xs:sequence>
      <xs:element name="keyType" type="wssec:JsonKeyType" default="symmetric"/>
      <xs:element name="signatureAcceptKeyInfoType" type="wssec:JsonKeyInfoType" minOccurs="0">
        <xs:annotation>
          <xs:documentation>Identifies what form of Key Information must be used in signature being verified.</xs:documentation>
          <xs:appinfo>This element should NOT be generated if NONE is specified.</xs:appinfo>
        </xs:annotation>
        <!-- constraint: WARNING "Not specifying any KeyInfo accept type is legal but not good practice because it restricts"
                                 "the producer and consumer to a fix out-of-band key management"
                         if NONE, i.e., no element populated, was specified
        -->
      </xs:element>
      <xs:element name="signatureAcceptAlgorithm" type="wssec:JwsSignatureAcceptAlgType"/>
      <xs:element name="serializationAcceptMethod" type="wssec:JwsSerializationMethodType"/>
      <xs:element name="jsonSecurityToken" type="wssec:JsonVerifySecurityToken"/>
      <xs:element name="authenticationPolicy" type="wssec:SecurityConfigPackageType" minOccurs="0">
        <xs:annotation>
          <xs:documentation>
            Name of Web Service Authentication Policy security object in associated security config.
            Authentication policy will supply the trusted CA group, verification depth and CRL enforcement.
          </xs:documentation>
        </xs:annotation>
        <!-- constraint: MUST NOT be PRESENT if (keyType == symmetric) -->
        <!-- constraint: the following are deployment time check between REST policy and security config.
             1) Name must match webServiceAuthenticationPolicy security config object name
             2) If (keyType == x509) then webServiceAuthenticationPolicy security config object with (key model = X.509).
        -->
      </xs:element>
      <xs:element name="caPath" minOccurs="0">
        <!-- constraint: 1) ONLY PRESENT if (keyType == x509) 
                         2) WARNING "Application is overriding CA PAth information that should be passed in signature" 
                            if ((caPath populated) AND (signatureAcceptKeyInfoType == certificateChain))
        -->
        <xs:complexType>
          <xs:choice>
            <xs:element name="fromSecurityConfig" type="wssec:SecurityConfigPackageType">
              <xs:annotation>
                <xs:documentation>Name of CA Path security config object from assocaited security config package</xs:documentation>
              </xs:annotation>
              <!-- constraint: must resolve to a caPath security config object -->
            </xs:element>
            <xs:element name="fromWorkflow" type="wssec:EmptyType">
              <xs:annotation>
                <xs:documentation>
                  Indicates that CA Path is being supplied by the appliation coming from Workflow.
                  The CA Path MUST be encoded in PEM format and ordered starting from the leaf and progressing through the 
                  immediate CAs and terminating with the trusted root CA certificate.
                </xs:documentation>
              </xs:annotation>
              <!--  constraint: Service Designer require to prompt developer for data from workflow when this policy is bind to
                                a specific action. 
              -->
            </xs:element>
          </xs:choice>
        </xs:complexType>
      </xs:element>
    </xs:sequence>
    <xs:attribute name="stripSignature" type="xs:boolean" default="true">
      <xs:annotation>
        <xs:documentation>Indicates if JWS should be removed after successful signature verification.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:complexType>
  <xs:complexType name="JweEncrypt">
    <xs:annotation>
      <xs:documentation>JSON Web Encryption (JWE): Encryption</xs:documentation>
    </xs:annotation>
    <xs:sequence>
      <xs:element name="keyType" type="wssec:JsonKeyType" default="symmetric"/>
      <xs:element name="encryptionGenerationKeyInfoType" type="wssec:JsonKeyInfoType" default="keyId">
        <xs:annotation>
          <xs:documentation>Identifies what form of Key Information will be used in encryption being generated.</xs:documentation>
        </xs:annotation>
      </xs:element>
      <xs:element name="dataEncryptionGenerationAlgorithm" type="wssec:JweDataEncryptionGenerationAlgType" default="A256GCM"/>
      <xs:element name="keyEncryptionGenerationAlgorithm" type="wssec:JweKeyEncryptionGenerationAlgType" default="A256KW"/>
      <xs:element name="serializationGenerationMethod" type="wssec:JwsSerializationMethodType" default="CompactSerialization"/>
      <xs:element name="jsonSecurityToken" type="wssec:JsonEncryptSecurityToken"/>
    </xs:sequence>
  </xs:complexType>
  <xs:complexType name="JweDecrypt">
    <xs:annotation>
      <xs:documentation>JSON Web Encryption (JWE): Decryption</xs:documentation>
    </xs:annotation>
    <xs:sequence>
      <xs:element name="keyType" type="wssec:JsonKeyType" default="symmetric"/>
      <xs:element name="encryptionAcceptKeyInfoType" type="wssec:JsonKeyInfoType" minOccurs="0">
        <xs:annotation>
          <xs:documentation>Identifies what form of Key Information will be acceptable in decryption operation.</xs:documentation>
          <xs:appinfo>This element should not be generated if NONE is specified.</xs:appinfo>
        </xs:annotation>
        <!-- constraint: WARNING "Not specifying any KeyInfo accept type is legal but not good practice because it restricts"
                                 "the producer and consumer to a fix out-of-band key management"
                         if NONE, i.e., no element populated, was specified
        -->
      </xs:element>
      <xs:element name="dataEncryptionAcceptAlgorithm" type="wssec:JweDataEncryptionAcceptAlgType"/>
      <xs:element name="keyEncryptionAcceptAlgorithm" type="wssec:JweKeyEncryptionAcceptAlgType"/>
      <xs:element name="serializationAcceptMethod" type="wssec:JwsSerializationMethodType"/>
      <xs:element name="jsonSecurityToken" type="wssec:JsonDecryptSecurityToken"/>
    </xs:sequence>
    <xs:attribute name="stripEncryption" type="xs:boolean" default="true">
      <xs:annotation>
        <xs:documentation>Indicates if JWE should be removed after successful decryption.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:complexType>
  <xs:simpleType name="JsonKeyType">
    <xs:annotation>
      <xs:documentation>Identifies what type of key will be utilized.</xs:documentation>
    </xs:annotation>
    <xs:restriction base="xs:string">
      <xs:enumeration value="symmetric"/>
      <xs:enumeration value="x509"/>
    </xs:restriction>
  </xs:simpleType>
  <xs:simpleType name="JsonKeyInfoType">
    <xs:annotation>
      <xs:documentation>
        Mechanism used to enables the recipient(s) to obtain the key needed to either validate the JWS or decrypt a JWE.
      </xs:documentation>
    </xs:annotation>
    <xs:restriction base="xs:string">
      <xs:enumeration value="keyId">
        <xs:annotation>
          <xs:documentation>
            Key ID. JSON reserved claim: kid. 
            A hint indicating which key was used. 
            This parameter allows originators to explicitly signal to recipients which key material to use. While kid claim could
            logically be use with asymmetric key pairs, there are other X.509 specific claim mechanisms that have been identified.
            Therefore, we will limit use of kid claim to only supporting symmetric keys.
          </xs:documentation>
          <xs:appinfo>DEFAULT if (keyType == symmetric)</xs:appinfo>
        </xs:annotation>
        <!-- constraint: ONLY ALLOWED if (keyType == symmetric) -->
      </xs:enumeration>
      <xs:enumeration value="certificateChain">
        <xs:annotation>
          <xs:documentation>
            X509 Certificate Chain. JSON reserved claim: x5c. 
            The certificate or certificate chain is represented as a JSON array of certificate value strings. Each string in the
            array is a base64 encoded ([RFC4648] Section 4 -- not base64url encoded) DER PKIX certificate value. The certificate 
            containing the public key corresponding to the key used to digitally sign the JWS MUST be the first certificate. This 
            MAY be followed by additional certificates, with each subsequent certificate being the one used to certify the 
            previous one.
            I have looked at two different examples. One used single long string within double quotes. The other added newline
            every 64 characters within quoted string.
          </xs:documentation>
          <xs:appinfo>DEFAULT if (keyType == x509)</xs:appinfo>
        </xs:annotation>
        <!-- constraint: ONLY ALLOWED if (keyType == x509) -->
      </xs:enumeration>
      <xs:enumeration value="certificateThumbprint">
        <xs:annotation>
          <xs:documentation>
            X509 Certificate Thumbprint. JSON reserved claim: x5t. 
            A base64url encoded SHA-1 thumbprint (a.k.a. digest) of the DER encoding of the X.509 certificate [RFC5280] 
            corresponding to the key used.
            Note: if this encoding utilized then consuming end must locally supply untrusted CA Path certificates.
          </xs:documentation>
        </xs:annotation>
        <!-- constraint: ONLY ALLOWED if (keyType == x509) -->
      </xs:enumeration>
      <xs:enumeration value="x509Url">
        <xs:annotation>
          <xs:documentation>
            X509 URL. JSON reserved claim: x5u. 
            A URI [RFC3986] that refers to a resource for the X.509 public key certificate or certificate chain [RFC5280] 
            corresponding to the key used. The identified resource MUST provide a representation of the certificate or 
            certificate chain that conforms to RFC 5280 [RFC5280] in PEM encoded form [RFC1421]. The certificate containing the 
            public key corresponding to the key used to digitally sign the JWS MUST be the first certificate. This MAY be followed 
            by additional certificates, with each subsequent certificate being the one used to certify the previous one. The 
            protocol used to acquire the resource MUST provide integrity protection; an HTTP GET request to retrieve the 
            certificate MUST use TLS. 
          </xs:documentation>
          <xs:appinfo>Not currently supported. Future release TBD</xs:appinfo>
        </xs:annotation>
        <!-- constraint: ONLY ALLOWED if (keyType == x509) -->
      </xs:enumeration>
      <xs:enumeration value="jsonWebKey">
        <xs:annotation>
          <xs:documentation>
            JSON Web Token. JSON reserved claim: jwt. 
            The public key that corresponds to the key used. This key is represented as a JSON Web Key.
          </xs:documentation>
          <xs:appinfo>Not currently supported. Future release TBD</xs:appinfo>
        </xs:annotation>
        <!-- constraint: ONLY ALLOWED if (keyType == x509) -->
      </xs:enumeration>
      <xs:enumeration value="jsonWebKeyUrl">
        <xs:annotation>
          <xs:documentation>
            JSON Web Key Set URL. JSON reserved claim: jku. 
            A URI [RFC3986] that refers to a resource for a set of JSON-encoded public keys, one of which corresponds to the 
            key used.
            The keys MUST be encoded as a JSON Web Key Set (JWK Set) [JWK]. The protocol used to acquire the resource MUST 
            provide integrity protection; an HTTP GET request to retrieve the JWK Set MUST use TLS. 
          </xs:documentation>
          <xs:appinfo>Not currently supported. Future release TBD</xs:appinfo>
        </xs:annotation>
        <!-- constraint: ONLY ALLOWED if (keyType == x509) -->
      </xs:enumeration>
    </xs:restriction>
  </xs:simpleType>
  <xs:simpleType name="JwsSignatureGenerationAlgType">
    <xs:annotation>
      <xs:documentation>Cryptographic algorithm used to secure the JSON Web Signature.</xs:documentation>
    </xs:annotation>
    <xs:restriction base="xs:string">
      <xs:enumeration value="HS256">
        <xs:annotation>
          <xs:documentation>HMAC using SHA-256</xs:documentation>
        </xs:annotation>
        <!-- constraint: ONLY PRESENT if (keyType == symmetric) -->
      </xs:enumeration>
      <xs:enumeration value="HS384">
        <xs:annotation>
          <xs:documentation>HMAC using SHA-384</xs:documentation>
        </xs:annotation>
        <!-- constraint: ONLY PRESENT if (keyType == symmetric) -->
      </xs:enumeration>
      <xs:enumeration value="HS512">
        <xs:annotation>
          <xs:documentation>HMAC using SHA-512</xs:documentation>
        </xs:annotation>
        <!-- constraint: ONLY PRESENT if (keyType == symmetric) -->
      </xs:enumeration>
      <xs:enumeration value="RS256">
        <xs:annotation>
          <xs:documentation>RSASSA-PKCS-v1_5 using SHA-256</xs:documentation>
        </xs:annotation>
        <!-- constraint: ONLY PRESENT if (keyType == x509) -->
      </xs:enumeration>
      <xs:enumeration value="RS384">
        <xs:annotation>
          <xs:documentation>RSASSA-PKCS-v1_5 using SHA-384</xs:documentation>
        </xs:annotation>
        <!-- constraint: ONLY PRESENT if (keyType == x509) -->
      </xs:enumeration>
      <xs:enumeration value="RS512">
        <xs:annotation>
          <xs:documentation>RSASSA-PKCS-v1_5 using SHA-512</xs:documentation>
        </xs:annotation>
        <!-- constraint: ONLY PRESENT if (keyType == x509) -->
      </xs:enumeration>
      <xs:enumeration value="PS256">
        <xs:annotation>
          <xs:documentation>RSASSA-PSS using SHA-256 and MGF1 with SHA-256</xs:documentation>
          <xs:appinfo>Not currently supported. Future release TBD</xs:appinfo>
        </xs:annotation>
        <!-- constraint: ONLY PRESENT if (keyType == x509) -->
      </xs:enumeration>
      <xs:enumeration value="PS384">
        <xs:annotation>
          <xs:documentation>RSASSA-PSS using SHA-384 and MGF1 with SHA-384</xs:documentation>
          <xs:appinfo>Not currently supported. Future release TBD</xs:appinfo>
        </xs:annotation>
        <!-- constraint: ONLY PRESENT if (keyType == x509) -->
      </xs:enumeration>
      <xs:enumeration value="PS512">
        <xs:annotation>
          <xs:documentation>RSASSA-PSS using SHA-512 and MGF1 with SHA-512</xs:documentation>
          <xs:appinfo>Not currently supported. Future release TBD</xs:appinfo>
        </xs:annotation>
        <!-- constraint: ONLY PRESENT if (keyType == x509) -->
      </xs:enumeration>
      <xs:enumeration value="ES256">
        <xs:annotation>
          <xs:documentation>ECDSA using P-256 curve and SHA-256</xs:documentation>
          <xs:appinfo>Not currently supported. Future release TBD</xs:appinfo>
        </xs:annotation>
        <!-- constraint: ONLY PRESENT if (keyType == x509) -->
      </xs:enumeration>
      <xs:enumeration value="ES384">
        <xs:annotation>
          <xs:documentation>(ECDSA using P-384 curve and SHA-384</xs:documentation>
          <xs:appinfo>Not currently supported. Future release TBD</xs:appinfo>
        </xs:annotation>
        <!-- constraint: ONLY PRESENT if (keyType == x509) -->
      </xs:enumeration>
      <xs:enumeration value="ES512">
        <xs:annotation>
          <xs:documentation>ECDSA using P-521 curve and SHA-512</xs:documentation>
          <xs:appinfo>Not currently supported. Future release TBD</xs:appinfo>
        </xs:annotation>
        <!-- constraint: ONLY PRESENT if (keyType == x509) -->
      </xs:enumeration>
    </xs:restriction>
  </xs:simpleType>
  <xs:complexType name="JwsSignatureAcceptAlgType">
    <xs:annotation>
      <xs:documentation>Cryptographic algorithms acceptable for securing Json Web Signature being verified.</xs:documentation>
    </xs:annotation>
    <xs:sequence>
      <xs:element name="HS256" type="wssec:EmptyType" minOccurs="0">
        <xs:annotation>
          <xs:documentation>HMAC with SHA-256 Signature method: symmetric key based.</xs:documentation>
        </xs:annotation>
        <!-- constraint: ONLY ALLOWED if (keyType == symmetric) -->
      </xs:element>
      <xs:element name="HS384" type="wssec:EmptyType" minOccurs="0">
        <xs:annotation>
          <xs:documentation>HMAC with SHA-384 Signature method: symmetric key based.</xs:documentation>
        </xs:annotation>
        <!-- constraint: ONLY ALLOWED if (keyType == symmetric) -->
      </xs:element>
      <xs:element name="HS512" type="wssec:EmptyType" minOccurs="0">
        <xs:annotation>
          <xs:documentation>HMAC with SHA-512 Signature method: symmetric key based.</xs:documentation>
        </xs:annotation>
        <!-- constraint: ONLY ALLOWED if (keyType == symmetric) -->
      </xs:element>
      <xs:element name="RS256" type="wssec:EmptyType" minOccurs="0">
        <xs:annotation>
          <xs:documentation>RSASSA-PKCS-v1_5 using SHA-256 Signature method: PKI/X509 RSA assymmetric key based.</xs:documentation>
        </xs:annotation>
        <!-- constraint: ONLY ALLOWED if (keyType == x509) -->
        <!-- constraint: Following is a deployment time test between REST-Security policy and security config.
                         1) Associated certificate or asymmetricKeyPair security object must contain RSA based key material.
        -->
      </xs:element>
      <xs:element name="RS384" type="wssec:EmptyType" minOccurs="0">
        <xs:annotation>
          <xs:documentation>RSASSA-PKCS-v1_5 using SHA-384 Signature method: PKI/X509 RSA assymmetric key based.</xs:documentation>
        </xs:annotation>
        <!-- constraint: ONLY ALLOWED if (keyType == x509) -->
        <!-- constraint: Following is a deployment time test between REST-Security policy and security config.
                         1) Associated certificate or asymmetricKeyPair security object must contain RSA based key material.
        -->
      </xs:element>
      <xs:element name="RS512" type="wssec:EmptyType" minOccurs="0">
        <xs:annotation>
          <xs:documentation>RSASSA-PKCS-v1_5 using SHA-512 Signature method: PKI/X509 RSA assymmetric key based.</xs:documentation>
        </xs:annotation>
        <!-- constraint: ONLY ALLOWED if (keyType == x509) -->
        <!-- constraint: Following is a deployment time test between REST-Security policy and security config.
                         1) Associated certificate or asymmetricKeyPair security object must contain RSA based key material.
        -->
      </xs:element>
      <xs:element name="ES256" type="wssec:EmptyType" minOccurs="0">
        <xs:annotation>
          <xs:documentation>(ECDSA using P-256 curve and SHA-256: PKI/X509 ECC assymmetric key based.</xs:documentation>
          <xs:appinfo>Not currently supported. Future release TBD</xs:appinfo>
        </xs:annotation>
        <!-- constraint: ONLY ALLOWED if (keyType == x509) -->
        <!-- constraint: Following is a deployment time test between REST-Security policy and security config.
                         1) Associated certificate or asymmetricKeyPair security object must contain ECC-DSA based key material.
        -->
      </xs:element>
      <xs:element name="ES384" type="wssec:EmptyType" minOccurs="0">
        <xs:annotation>
          <xs:documentation>ECDSA using P-384 curve and SHA-384: PKI/X509 ECC assymmetric key based.</xs:documentation>
          <xs:appinfo>Not currently supported. Future release TBD</xs:appinfo>
        </xs:annotation>
        <!-- constraint: ONLY ALLOWED if (keyType == x509) -->
        <!-- constraint: Following is a deployment time test between REST-Security policy and security config.
                         1) Associated certificate or asymmetricKeyPair security object must contain ECC-DSA based key material.
        -->
      </xs:element>
      <xs:element name="ES512" type="wssec:EmptyType" minOccurs="0">
        <xs:annotation>
          <xs:documentation>ECDSA using P-521 curve and SHA-512: PKI/X509 ECC assymmetric key based.</xs:documentation>
          <xs:appinfo>Not currently supported. Future release TBD</xs:appinfo>
        </xs:annotation>
        <!-- constraint: ONLY ALLOWED if (keyType == x509) -->
        <!-- constraint: Following is a deployment time test between REST-Security policy and security config.
                         1) Associated certificate or asymmetricKeyPair security object must contain ECC-DSA based key material.
        -->
      </xs:element>
      <xs:element name="PS256" type="wssec:EmptyType" minOccurs="0">
        <xs:annotation>
          <xs:documentation>RSASSA-PSS using SHA-256 and MGF1 with SHA-256 Signature method: PKI/X509 RSA assymmetric key based.
          </xs:documentation>
          <xs:appinfo>Not currently supported. Future release TBD</xs:appinfo>
        </xs:annotation>
        <!-- constraint: ONLY ALLOWED if (keyType == x509) -->
        <!-- constraint: Following is a deployment time test between REST-Security policy and security config.
                         1) Associated certificate or asymmetricKeyPair security object must contain RSA based key material.
        -->
      </xs:element>
      <xs:element name="PS384" type="wssec:EmptyType" minOccurs="0">
        <xs:annotation>
          <xs:documentation>RSASSA-PSS using SHA-384 and MGF1 with SHA-384 Signature method: PKI/X509 RSA assymmetric key based.
          </xs:documentation>
          <xs:appinfo>Not currently supported. Future release TBD</xs:appinfo>
        </xs:annotation>
        <!-- constraint: ONLY ALLOWED if (keyType == x509) -->
        <!-- constraint: Following is a deployment time test between REST-Security policy and security config.
                         1) Associated certificate or asymmetricKeyPair security object must contain RSA based key material.
        -->
      </xs:element>
      <xs:element name="PS512" type="wssec:EmptyType" minOccurs="0">
        <xs:annotation>
          <xs:documentation>RSASSA-PSS using SHA-512 and MGF1 with SHA-512 Signature method: PKI/X509 RSA assymmetric key based.
          </xs:documentation>
          <xs:appinfo>Not currently supported. Future release TBD</xs:appinfo>
        </xs:annotation>
        <!-- constraint: ONLY ALLOWED if (keyType == x509) -->
        <!-- constraint: Following is a deployment time test between REST-Security policy and security config.
                         1) Associated certificate or asymmetricKeyPair security object must contain RSA based key material.
        -->
      </xs:element>
    </xs:sequence>
  </xs:complexType>
  <xs:simpleType name="JwsSerializationMethodType">
    <xs:annotation>
      <xs:documentation>Method used to normalize document being signed.</xs:documentation>
    </xs:annotation>
    <xs:restriction base="xs:string">
      <xs:enumeration value="CompactSerialization">
        <xs:annotation>
          <xs:documentation>
            JWS Compact Serialization represents digitally signed or MACed content as a compact URL-safe string. 
            This string is BASE64URL(UTF8(JWS Protected Header)) || '.' || BASE64URL(JWS Payload) || '.' || BASE64URL(JWS Signature).
            Only one signature/MAC is supported by the JWS Compact Serialization. 
          </xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="JsonSerialization">
        <xs:annotation>
          <xs:documentation>
            The JWS JSON Serialization represents digitally signed or MACed content as a JSON object. Unlike the JWS Compact
            Serialization, content using the JWS JSON Serialization can be secured with more than one digital signature and/or 
            MAC value.
            
            The representation is closely related to that used in the JWS Compact Serialization, with the following differences for 
            the JWS JSON Serialization:
            
            * Values in the JWS JSON Serialization are represented as members of a JSON object, rather than as base64url encoded 
              strings separated by period ('.') characters. (However binary values and values that are integrity protected are 
              still base64url encoded.)
            * The value BASE64URL(JWS Payload) is stored in the payload member.
            * There can be multiple signature and/or MAC values, rather than just one. A JSON array in the signatures member is 
              used to hold values that are specific to a particular signature or MAC computation, with one array element per
              signature/MAC represented.
              These array elements are JSON objects.
            * Each value BASE64URL(JWS Signature), if non-empty, is stored in the signature member of a JSON object that is an 
              element of the signatures array.
            * Each value BASE64URL(UTF8(JWS Protected Header)), if non-empty, is stored in the protected member of the 
              corresponding element of the signatures array.
            * Each JWS Unprotected Header value, if non-empty, is stored in the header member of the corresponding element of 
              the signatures array. If present, a JWS Unprotected Header value is represented as an unencoded JSON Text Object, 
              rather than as a string.
            * The Header Parameter values used when creating or validating individual signature or MAC values are the union of the 
              two sets of Header Parameter values that may be present: (1) the JWS Protected Header values represented in the 
              protected member of the signature/MAC's array element, and (2) the JWS Unprotected Header values in the header member 
              of the signature/MAC's array element. The union of these sets of Header Parameters comprises the JWS Header. The 
              Header Parameter names in the two locations MUST be disjoint.
            
             The syntax of a JWS using the JWS JSON Serialization is as follows:
              {
                 "payload":"&lt;payload contents&gt;"
                 "signatures":[
                  {"protected":&lt;integrity-protected header 1 contents&gt;",
                   "header":"&lt;non-integrity-protected header 1 contents&lt;",
                   "signature":"&lt;signature 1 contents&gt;"},
                    ...
                  {"protected":&lt;integrity-protected header N contents&gt;",
                   "header":"&lt;non-integrity-protected header N contents&gt;",
                   "signature":"&lt;signature N contents&gt;"}],
              }
            Of these members, only the payload, signatures, and signature members MUST be present. At least one of the protected 
            and header members MUST be present for each signature/MAC computation so that an alg Header Parameter value is conveyed. 
          </xs:documentation>
          <xs:appinfo>Not currently supported. Future release TBD</xs:appinfo>
        </xs:annotation>
      </xs:enumeration>
    </xs:restriction>
  </xs:simpleType>
  <xs:complexType name="JsonSignSecurityToken">
    <xs:annotation>
      <xs:documentation>Security Token used by JWS sign actions</xs:documentation>
    </xs:annotation>
    <xs:choice>
      <xs:element name="security-config-package" type="wssec:SecurityConfigPackageType">
        <!-- constraint: ONLY ALLOWED if (signatureGenerationKeyInfoType == (keyId OR certificateChain OR certificateThumbprint)) -->
        <!-- constraint: the following are deployment time check between REST policy and security config.
               1) If (keyType == x509) then must be name of asymmetricKeyPair security config object.
               2) If (keyType == symmetric) then must be name of sharedSecret security config object.
        -->
      </xs:element>
      <xs:element name="securityObjectNameFromWorkflow" type="wssec:SecurityObjectNameFromWorkflowType">
        <!-- constraint: ONLY ALLOWED if (signatureGenerationKeyInfoType == (keyId OR certificateChain OR certificateThumbprint)) -->
        <!-- constraint: the following are deployment time check between REST policy and security config.
               1) If (keyType == x509) then must be name of asymmetricKeyPair security config object.
               2) If (keyType == symmetric) then must be name of sharedSecret security config object.
        -->
      </xs:element>
      <xs:element name="keystore">
        <xs:annotation>
          <xs:documentation>
            Use specified key name to query keystore for associated secret/symmetric key or certificate.
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attribute name="signSourceType">
            <xs:simpleType>
              <xs:restriction base="xs:string">
                <xs:enumeration value="username"/>
                <xs:enumeration value="keyname"/>
                <xs:enumeration value="certificate"/>
                <xs:enumeration value="embedded-SKI"/>
                <xs:enumeration value="sha1-fingerprint"/>
                <xs:enumeration value="subjectname"/>
                <!-- keystore supports but are not utilized by anyone now.
                <xs:enumeration value="issuer-serialnumber"/>
                <xs:enumeration value="SKI"/>
                <xs:enumeration value="SKI-short"/>
                <xs:enumeration value="md5-fingerprint"/>
                -->
              </xs:restriction>
            </xs:simpleType>
          </xs:attribute>
        </xs:complexType>
        <!-- constraint: 
             1) ONLY ALLOWED if (JsonKeyInfoType == kid)
             2) Service Designer action builder MUST PROMPT developer for value, i.e., workflow variable, to use in Keystore look-up.
                Service designer action builder should use sourceType, e.g., subject common name, thumbprint, etc.,
                in prompt of developer subject common name, thumbprint, etc.
        -->
      </xs:element>
      <xs:element name="ldap" type="wssec:LdapSearchRequest">
        <xs:annotation>
          <xs:documentation>
            Use specified key name to query LDAP for associated secret/symmetric key.
          </xs:documentation>
        </xs:annotation>
        <!-- constraint: 
             1) ONLY ALLOWED if (JsonKeyInfoType == kid)
             2) Service Designer action builder MUST PROMPT developer for name to use in LDAP retrieval look-up.
        -->
      </xs:element>
    </xs:choice>
  </xs:complexType>
  <xs:complexType name="JsonVerifySecurityToken">
    <xs:annotation>
      <xs:documentation>Security Token used by JWS verify actions</xs:documentation>
    </xs:annotation>
    <xs:choice>
      <xs:element name="useIncoming" type="wssec:EmptyType">
        <xs:annotation>
          <xs:documentation>
            Since full chain of certificates from leaf to root included, incoming signature contains everything need.
          </xs:documentation>
        </xs:annotation>
        <!-- constraint: ONLY ALLOWED if (signatureAcceptKeyInfoType == certificateChain) -->
      </xs:element>
      <xs:element name="security-config-package" type="wssec:SecurityConfigPackageType">
        <!-- constraint: ONLY ALLOWED if ((signatureAcceptKeyInfoType == (keyId OR certificateChain OR certificateThumbprint)) OR
                                          (signatureAcceptKeyInfoType element does not exist)
                                         )
        -->
        <!-- constraint: the following are deployment time check between REST policy and security config.
               1) If (keyType == x509) then must be name of certificate security config object.
               2) If (keyType == symmetric) then must be name of sharedSecret security config object.
        -->
      </xs:element>
      <xs:element name="securityObjectNameFromWorkflow" type="wssec:SecurityObjectNameFromWorkflowType">
        <!-- constraint: ONLY ALLOWED if ((signatureAcceptKeyInfoType == (keyId OR certificateChain OR certificateThumbprint)) OR
                                          (signatureAcceptKeyInfoType element does not exist)
                                         )
        -->
        <!-- constraint: the following are deployment time check between REST policy and security config.
               1) If (keyType == x509) then must be name of certificate security config object.
               2) If (keyType == symmetric) then must be name of sharedSecret security config object.
        -->
      </xs:element>
      <xs:element name="securityObjectNameFromKidClaim" type="wssec:EmptyType">
        <xs:annotation>
          <xs:documentation>
            Symmetric key from sharedSecret security config with keyname matching kid claim used.
          </xs:documentation>
        </xs:annotation>
        <!-- constraint: ONLY ALLOWED if (signatureAcceptKeyInfoType == keyId) -->
        <!-- constraint: the following are deployment time check between REST policy and security config.
               1) If (keyType == symmetric) then must be name of sharedSecret security config object.
        -->
      </xs:element>
      <xs:element name="keystore" type="wssec:EmptyType">
        <xs:annotation>
          <xs:documentation>
            Keystore is use to resolve incoming key info claim in incoming signature to associated key material.
            If symmetric token type then use key name contained in incoming kid claim to query keystore 
            for associated secret/symmetric key.
            If x509 token type then use certificate thumbprint contained in incoming x5t claim to query 
            keystore for associated X.509 certificate.
          </xs:documentation>
        </xs:annotation>
        <!-- constraint: ONLY ALLOWED if (signatureAcceptKeyInfoType == (kid OR certificateThumbprint)) -->
      </xs:element>
      <xs:element name="ldap" type="wssec:LdapSearchRequest">
        <xs:annotation>
          <xs:documentation>
            LDAP backend server used to resolve key info claim in incoming signature to associated key material.
            If symmetric token type then use key name contained in incoming kid claim to query LDAP server for 
            associated secret/symmetric key.
            If assymmetric token type then use certificate thumbprint contained in incoming x5t claim to query 
            LDAP server for associated secret/symmetric key.
          </xs:documentation>
        </xs:annotation>
        <!-- constraint: ONLY ALLOWED if (signatureAcceptKeyInfoType == (kid OR certificateThumbprint)) -->
      </xs:element>
    </xs:choice>
  </xs:complexType>
  <xs:simpleType name="JweDataEncryptionGenerationAlgType">
    <xs:annotation>
      <xs:documentation>Cryptographic algorithm used to secure gemerated symmetric key with JWE.</xs:documentation>
    </xs:annotation>
    <xs:restriction base="xs:string">
      <xs:enumeration value="A128GCM">
        <xs:annotation>
          <xs:documentation>AES Galois/Counter Mode with 128-bit key</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="A192GCM">
        <xs:annotation>
          <xs:documentation>AES Galois/Counter Mode with 192-bit key</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="A256GCM">
        <xs:annotation>
          <xs:documentation>AES Galois/Counter Mode with 256-bit key</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="A128CBC-HS256">
        <xs:annotation>
          <xs:documentation>AES with 128-bit key and Cipher Block Chaining with HMAC authentication using SHA256</xs:documentation>
          <xs:appinfo>Not currently supported. Future release TBD</xs:appinfo>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="A192CBC-HS384">
        <xs:annotation>
          <xs:documentation>AES with 192-bit key and Cipher Block Chaining with HMAC authentication using SHA-384</xs:documentation>
          <xs:appinfo>Not currently supported. Future release TBD</xs:appinfo>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="A256CBC-HS512">
        <xs:annotation>
          <xs:documentation>AES with 256-bit key and Cipher Block Chaining with HMAC authentication using SHA-512</xs:documentation>
          <xs:appinfo>Not currently supported. Future release TBD</xs:appinfo>
        </xs:annotation>
      </xs:enumeration>
    </xs:restriction>
  </xs:simpleType>
  <xs:complexType name="JweDataEncryptionAcceptAlgType">
    <xs:annotation>
      <xs:documentation>
        Cryptographic algorithms acceptable for securing bulk data within JWE.
      </xs:documentation>
    </xs:annotation>
    <xs:sequence>
      <xs:element name="A128GCM" type="wssec:EmptyType" minOccurs="0">
        <xs:annotation>
          <xs:documentation>AES Galois/Counter Mode with 128-bit key method</xs:documentation>
        </xs:annotation>
      </xs:element>
      <xs:element name="A192GCM" type="wssec:EmptyType" minOccurs="0">
        <xs:annotation>
          <xs:documentation>AES Galois/Counter Mode with 192-bit key</xs:documentation>
        </xs:annotation>
      </xs:element>
      <xs:element name="A256GCM" type="wssec:EmptyType" minOccurs="0">
        <xs:annotation>
          <xs:documentation>AES Galois/Counter Mode with 256-bit key</xs:documentation>
        </xs:annotation>
      </xs:element>
      <xs:element name="A128CBC-HS256" type="wssec:EmptyType" minOccurs="0">
        <xs:annotation>
          <xs:documentation>AES with 128-bit key and Cipher Block Chaining with HMAC authentication using SHA256</xs:documentation>
          <xs:appinfo>Not currently supported. Future release TBD</xs:appinfo>
        </xs:annotation>
      </xs:element>
      <xs:element name="A192CBC-HS384" type="wssec:EmptyType" minOccurs="0">
        <xs:annotation>
          <xs:documentation>AES with 192-bit key and Cipher Block Chaining with HMAC authentication using SHA-384</xs:documentation>
          <xs:appinfo>Not currently supported. Future release TBD</xs:appinfo>
        </xs:annotation>
      </xs:element>
      <xs:element name="A256CBC-HS512" type="wssec:EmptyType" minOccurs="0">
        <xs:annotation>
          <xs:documentation>AES with 256-bit key and Cipher Block Chaining with HMAC authentication using SHA-512</xs:documentation>
          <xs:appinfo>Not currently supported. Future release TBD</xs:appinfo>
        </xs:annotation>
      </xs:element>
    </xs:sequence>
  </xs:complexType>
  <xs:simpleType name="JweKeyEncryptionGenerationAlgType">
    <xs:annotation>
      <xs:documentation>Cryptographic algorithm used to secure the Json Web Signature.</xs:documentation>
    </xs:annotation>
    <xs:restriction base="xs:string">
      <xs:enumeration value="A128KW">
        <xs:annotation>
          <xs:documentation>AES Key Wrap 128-bit key</xs:documentation>
        </xs:annotation>
        <!-- constraint: ONLY PRESENT if (keyType == symmetric) -->
      </xs:enumeration>
      <xs:enumeration value="A192KW">
        <xs:annotation>
          <xs:documentation>AES Key Wrap 192-bit key</xs:documentation>
        </xs:annotation>
        <!-- constraint: ONLY PRESENT if (keyType == symmetric) -->
      </xs:enumeration>
      <xs:enumeration value="A256KW">
        <xs:annotation>
          <xs:documentation>AES Key Wrap 256-bit key</xs:documentation>
        </xs:annotation>
        <!-- constraint: ONLY PRESENT if (keyType == symmetric) -->
      </xs:enumeration>
      <xs:enumeration value="RSA1_5">
        <xs:annotation>
          <xs:documentation>RSAES-PKCS1-V1_5</xs:documentation>
        </xs:annotation>
        <!-- constraint: ONLY PRESENT if (keyType == x509) -->
      </xs:enumeration>
      <xs:enumeration value="RSA-OAEP">
        <xs:annotation>
          <xs:documentation>RSAES using Optimal Asymmetric Encryption Padding</xs:documentation>
        </xs:annotation>
        <!-- constraint: ONLY PRESENT if (keyType == x509) -->
      </xs:enumeration>
      <xs:enumeration value="dir">
        <xs:annotation>
          <xs:documentation>Direct use of a shared symmetric key</xs:documentation>
          <xs:appinfo>Not currently supported. Future release TBD</xs:appinfo>
        </xs:annotation>
        <!-- constraint: ONLY PRESENT if (keyType == symmetric) -->
      </xs:enumeration>
      <xs:enumeration value="A128GCMKW">
        <xs:annotation>
          <xs:documentation>AES Galois/Counter Mode using 128 bit keys</xs:documentation>
          <xs:appinfo>Not currently supported. Future release TBD</xs:appinfo>
        </xs:annotation>
        <!-- constraint: ONLY PRESENT if (keyType == symmetric) -->
      </xs:enumeration>
      <xs:enumeration value="A192GCMKW">
        <xs:annotation>
          <xs:documentation>AES Galois/Counter Mode using 192 bit keys</xs:documentation>
          <xs:appinfo>Not currently supported. Future release TBD</xs:appinfo>
        </xs:annotation>
        <!-- constraint: ONLY PRESENT if (keyType == symmetric) -->
      </xs:enumeration>
      <xs:enumeration value="A256GCMKW">
        <xs:annotation>
          <xs:documentation>AES Galois/Counter Mode using 256 bit keys</xs:documentation>
          <xs:appinfo>Not currently supported. Future release TBD</xs:appinfo>
        </xs:annotation>
        <!-- constraint: ONLY PRESENT if (keyType == symmetric) -->
      </xs:enumeration>
      <xs:enumeration value="PBES2-HS256+A128KW">
        <xs:annotation>
          <xs:documentation>PBES2 with HMAC SHA-256 and AES Key Wrap with 128 bit keys</xs:documentation>
          <xs:appinfo>Not currently supported. Future release TBD</xs:appinfo>
        </xs:annotation>
        <!-- constraint: ONLY PRESENT if (keyType == symmetric) -->
      </xs:enumeration>
      <xs:enumeration value="PBES2-HS384+A192KW">
        <xs:annotation>
          <xs:documentation>PBES2 with HMAC SHA-384 and AES Key Wrap with 192 bit keys</xs:documentation>
          <xs:appinfo>Not currently supported. Future release TBD</xs:appinfo>
        </xs:annotation>
        <!-- constraint: ONLY PRESENT if (keyType == symmetric) -->
      </xs:enumeration>
      <xs:enumeration value="PBES2-HS512+A256KW">
        <xs:annotation>
          <xs:documentation>PBES2 with HMAC SHA-512 and AES Key Wrap with 256 bit keys</xs:documentation>
          <xs:appinfo>Not currently supported. Future release TBD</xs:appinfo>
        </xs:annotation>
        <!-- constraint: ONLY PRESENT if (keyType == symmetric) -->
      </xs:enumeration>
      <xs:enumeration value="ECDH-ES">
        <xs:annotation>
          <xs:documentation>Elliptic Curve Diffie-Hellman Ephemeral Static</xs:documentation>
          <xs:appinfo>Not currently supported. Future release TBD</xs:appinfo>
        </xs:annotation>
        <!-- constraint: ONLY PRESENT if (keyType == x509) -->
      </xs:enumeration>
      <xs:enumeration value="ECDHES+A128KW">
        <xs:annotation>
          <xs:documentation>
            Elliptic Curve Diffie-Hellman Ephemeral Static key agreement per ECDH-ES, but where the agreed-upon key 
            is used to wrap the Content Master Key (CMK) with the A128KW function
          </xs:documentation>
          <xs:appinfo>Not currently supported. Future release TBD</xs:appinfo>
        </xs:annotation>
        <!-- constraint: ONLY PRESENT if (keyType == x509) -->
      </xs:enumeration>
      <xs:enumeration value="ECDHES+A192KW">
        <xs:annotation>
          <xs:documentation>
            Elliptic Curve Diffie-Hellman Ephemeral Static key agreement per ECDH-ES, but where the agreed-upon key 
            is used to wrap the Content Master Key (CMK) with the A192KW function
          </xs:documentation>
          <xs:appinfo>Not currently supported. Future release TBD</xs:appinfo>
        </xs:annotation>
        <!-- constraint: ONLY PRESENT if (keyType == x509) -->
      </xs:enumeration>
      <xs:enumeration value="ECDHES+A256KW">
        <xs:annotation>
          <xs:documentation>
            Elliptic Curve Diffie-Hellman Ephemeral Static key agreement per ECDH-ES, but where the agreed-upon key 
            is used to wrap the Content Master Key (CMK) with the A256KW function
          </xs:documentation>
          <xs:appinfo>Not currently supported. Future release TBD</xs:appinfo>
        </xs:annotation>
        <!-- constraint: ONLY PRESENT if (keyType == x509) -->
      </xs:enumeration>
    </xs:restriction>
  </xs:simpleType>
  <xs:complexType name="JweKeyEncryptionAcceptAlgType">
    <xs:annotation>
      <xs:documentation>Cryptographic algorithms acceptable for securing Json Web Encryption Key being encrypted.</xs:documentation>
    </xs:annotation>
    <xs:sequence>
      <xs:element name="A128KW" type="wssec:EmptyType" minOccurs="0">
        <xs:annotation>
          <xs:documentation>AES Key Wrap 128-bit key method: symmetric key based.</xs:documentation>
        </xs:annotation>
        <!-- constraint: ONLY ALLOWED if (keyType == symmetric) -->
      </xs:element>
      <xs:element name="A192KW" type="wssec:EmptyType" minOccurs="0">
        <xs:annotation>
          <xs:documentation>AES Key Wrap 192-bit key method: symmetric key based.</xs:documentation>
        </xs:annotation>
        <!-- constraint: ONLY ALLOWED if (keyType == symmetric) -->
      </xs:element>
      <xs:element name="A256KW" type="wssec:EmptyType" minOccurs="0">
        <xs:annotation>
          <xs:documentation>AES Key Wrap 256-bit key method: symmetric key based.</xs:documentation>
        </xs:annotation>
        <!-- constraint: ONLY ALLOWED if (keyType == symmetric) -->
      </xs:element>
      <xs:element name="dir" type="wssec:EmptyType" minOccurs="0">
        <xs:annotation>
          <xs:documentation>Direct use of a shared symmetric key method: symmetric key based.</xs:documentation>
          <xs:appinfo>Not currently supported. Future release TBD</xs:appinfo>
        </xs:annotation>
        <!-- constraint: ONLY ALLOWED if (keyType == symmetric) -->
      </xs:element>
      <xs:element name="RSA1_5" type="wssec:EmptyType" minOccurs="0">
        <xs:annotation>
          <xs:documentation>RSAES-PKCS1-V1_5 method: PKI/X509 RSA assymmetric key based.</xs:documentation>
        </xs:annotation>
        <!-- constraint: ONLY ALLOWED if (keyType == x509) -->
        <!-- constraint: Following is a deployment time test between REST-Security policy and security config.
                         1) Associated asymmetricKeyPair security object must contain RSA based key material.
        -->
      </xs:element>
      <xs:element name="RSA-OAEP" type="wssec:EmptyType" minOccurs="0">
        <xs:annotation>
          <xs:documentation>RSAES using Optimal Asymmetric Encryption Padding method: PKI/X509 RSA assymmetric key based.</xs:documentation>
        </xs:annotation>
        <!-- constraint: ONLY ALLOWED if (keyType == x509) -->
        <!-- constraint: Following is a deployment time test between REST-Security policy and security config.
                         1) Associated asymmetricKeyPair security object must contain RSA based key material.
        -->
      </xs:element>
      <xs:element name="A128GCMKW" type="wssec:EmptyType" minOccurs="0">
        <xs:annotation>
          <xs:documentation>AES Galois/Counter Mode using 128 bit keys</xs:documentation>
          <xs:appinfo>Not currently supported. Future release TBD</xs:appinfo>
        </xs:annotation>
        <!-- constraint: ONLY ALLOWED if (keyType == symmetric) -->
        <!-- constraint: Following is a deployment time test between REST-Security policy and security config.
                         1) Associated sharedSecret security object.
        -->
      </xs:element>
      <xs:element name="A192GCMKW" type="wssec:EmptyType" minOccurs="0">
        <xs:annotation>
          <xs:documentation>AES Galois/Counter Mode using 192 bit keys</xs:documentation>
          <xs:appinfo>Not currently supported. Future release TBD</xs:appinfo>
        </xs:annotation>
        <!-- constraint: ONLY ALLOWED if (keyType == symmetric) -->
        <!-- constraint: Following is a deployment time test between REST-Security policy and security config.
                         1) Associated sharedSecret security object.
        -->
      </xs:element>
      <xs:element name="A256GCMKW" type="wssec:EmptyType" minOccurs="0">
        <xs:annotation>
          <xs:documentation>AES Galois/Counter Mode using 256 bit keys</xs:documentation>
          <xs:appinfo>Not currently supported. Future release TBD</xs:appinfo>
        </xs:annotation>
        <!-- constraint: ONLY ALLOWED if (keyType == symmetric) -->
        <!-- constraint: Following is a deployment time test between REST-Security policy and security config.
                         1) Associated sharedSecret security object.
        -->
      </xs:element>
      <xs:element name="PBES2-HS256plusA128KW" type="wssec:EmptyType" minOccurs="0">
        <xs:annotation>
          <xs:documentation>PBES2 with HMAC SHA-256 and AES Key Wrap with 128 bit keys</xs:documentation>
          <xs:appinfo>Not currently supported. Future release TBD</xs:appinfo>
        </xs:annotation>
        <!-- constraint: ONLY ALLOWED if (keyType == symmetric) -->
        <!-- constraint: Following is a deployment time test between REST-Security policy and security config.
                         1) Associated sharedSecret security object.
        -->
      </xs:element>
      <xs:element name="PBES2-HS384plusA192KW" type="wssec:EmptyType" minOccurs="0">
        <xs:annotation>
          <xs:documentation>PBES2 with HMAC SHA-384 and AES Key Wrap with 192 bit keys</xs:documentation>
          <xs:appinfo>Not currently supported. Future release TBD</xs:appinfo>
        </xs:annotation>
        <!-- constraint: ONLY ALLOWED if (keyType == symmetric) -->
        <!-- constraint: Following is a deployment time test between REST-Security policy and security config.
                         1) Associated sharedSecret security object.
        -->
      </xs:element>
      <xs:element name="PBES2-HS512plusA256KW" type="wssec:EmptyType" minOccurs="0">
        <xs:annotation>
          <xs:documentation>PBES2 with HMAC SHA-512 and AES Key Wrap with 256 bit keys</xs:documentation>
          <xs:appinfo>Not currently supported. Future release TBD</xs:appinfo>
        </xs:annotation>
        <!-- constraint: ONLY ALLOWED if (keyType == symmetric) -->
        <!-- constraint: Following is a deployment time test between REST-Security policy and security config.
                         1) Associated sharedSecret security object.
        -->
      </xs:element>
      <xs:element name="ES384" type="wssec:EmptyType" minOccurs="0">
        <xs:annotation>
          <xs:documentation>ECDSA using P-384 curve and SHA-384: PKI/X509 ECC assymmetric key based.</xs:documentation>
          <xs:appinfo>Not currently supported. Future release TBD</xs:appinfo>
        </xs:annotation>
        <!-- constraint: ONLY ALLOWED if (keyType == x509) -->
        <!-- constraint: Following is a deployment time test between REST-Security policy and security config.
                         1) Associated certificate or asymmetricKeyPair security object must contain ECC-DSA based key material.
        -->
      </xs:element>
      <xs:element name="ECDH-ES" type="wssec:EmptyType" minOccurs="0">
        <xs:annotation>
          <xs:documentation>Elliptic Curve Diffie-Hellman Ephemeral Static.</xs:documentation>
          <xs:appinfo>Not currently supported. Future release TBD</xs:appinfo>
        </xs:annotation>
        <!-- constraint: ONLY ALLOWED if (keyType == x509) -->
        <!-- constraint: Following is a deployment time test between REST-Security policy and security config.
                         1) Associated certificate or asymmetricKeyPair security object must contain ECC-DSA based key material.
        -->
      </xs:element>
      <xs:element name="ECDHESplusA128KW" type="wssec:EmptyType" minOccurs="0">
        <xs:annotation>
          <xs:documentation>
            Elliptic Curve Diffie-Hellman Ephemeral Static key agreement per ECDH-ES, but where the 
            agreed-upon key is used to wrap the Content Master Key (CMK) with the A128KW function.
          </xs:documentation>
          <xs:appinfo>Not currently supported. Future release TBD</xs:appinfo>
        </xs:annotation>
        <!-- constraint: ONLY ALLOWED if (keyType == x509) -->
        <!-- constraint: Following is a deployment time test between REST-Security policy and security config.
                         1) Associated certificate or asymmetricKeyPair security object must contain RSA based key material.
        -->
      </xs:element>
      <xs:element name="ECDHESplusA192KW" type="wssec:EmptyType" minOccurs="0">
        <xs:annotation>
          <xs:documentation>
            Elliptic Curve Diffie-Hellman Ephemeral Static key agreement per ECDH-ES, but where the agreed-upon key 
            is used to wrap the Content Master Key (CMK) with the A192KW function.
          </xs:documentation>
          <xs:appinfo>Not currently supported. Future release TBD</xs:appinfo>
        </xs:annotation>
        <!-- constraint: ONLY ALLOWED if (keyType == x509) -->
        <!-- constraint: Following is a deployment time test between REST-Security policy and security config.
                         1) Associated certificate or asymmetricKeyPair security object must contain RSA based key material.
        -->
      </xs:element>
      <xs:element name="ECDHESplusA256KW" type="wssec:EmptyType" minOccurs="0">
        <xs:annotation>
          <xs:documentation>
            Elliptic Curve Diffie-Hellman Ephemeral Static key agreement per ECDH-ES, but where the agreed-upon key 
            is used to wrap the Content Master Key (CMK) with the A256KW function.
          </xs:documentation>
          <xs:appinfo>Not currently supported. Future release TBD</xs:appinfo>
        </xs:annotation>
        <!-- constraint: ONLY ALLOWED if (keyType == x509) -->
        <!-- constraint: Following is a deployment time test between REST-Security policy and security config.
                         1) Associated certificate or asymmetricKeyPair security object must contain RSA based key material.
        -->
      </xs:element>
    </xs:sequence>
  </xs:complexType>
  <xs:complexType name="JsonEncryptSecurityToken">
    <xs:annotation>
      <xs:documentation>Security Token used by JWE encryption actions</xs:documentation>
    </xs:annotation>
    <xs:choice>
      <xs:element name="security-config-package" type="wssec:SecurityConfigPackageType">
        <!-- constraint: ONLY ALLOWED if (signatureGenerationKeyInfoType == (keyId OR certificateChain OR certificateThumbprint)) -->
        <!-- constraint: the following are deployment time check between REST policy and security config.
               1) If (keyType == x509) then must be name of certificate security config object.
               2) If (keyType == symmetric) then must be name of sharedSecret security config object.
        -->
      </xs:element>
      <xs:element name="securityObjectNameFromWorkflow" type="wssec:SecurityObjectNameFromWorkflowType">
        <!-- constraint: ONLY ALLOWED if (signatureGenerationKeyInfoType == (keyId OR certificateChain OR certificateThumbprint)) -->
        <!-- constraint: the following are deployment time check between REST policy and security config.
               1) If (keyType == x509) then must be name of certificate security config object.
               2) If (keyType == symmetric) then must be name of sharedSecret security config object.
        -->
      </xs:element>
      <xs:element name="keystore">
        <xs:annotation>
          <xs:documentation>
            Use specified key name to query keystore for associated secret/symmetric key or certificate.
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attribute name="encryptSourceType">
            <xs:simpleType>
              <xs:restriction base="xs:string">
                <xs:enumeration value="username"/>
                <xs:enumeration value="keyname"/>
                <xs:enumeration value="embedded-SKI"/>
                <xs:enumeration value="sha1-fingerprint"/>
                <xs:enumeration value="subjectname"/>
                <!-- keystore supports but are not utilized by anyone now.
                <xs:enumeration value="issuer-serialnumber"/>
                <xs:enumeration value="certificate"/>
                <xs:enumeration value="SKI"/>
                <xs:enumeration value="SKI-short"/>
                <xs:enumeration value="md5-fingerprint"/>
                -->
              </xs:restriction>
            </xs:simpleType>
          </xs:attribute>
        </xs:complexType>
        <!-- constraint: 
             1) ONLY ALLOWED if (signatureGenerationKeyInfoType == (keyId OR certificateChain OR certificateThumbprint))
             2) Service Designer action builder MUST PROMPT developer for value, i.e., workflow variable, to use in Keystore look-up.
                Service designer action builder should use sourceType, e.g., subject common name, thumbprint, etc.,
                in prompt of developer subject common name, thumbprint, etc.
        -->
      </xs:element>
      <xs:element name="ldap" type="wssec:LdapSearchRequest">
        <xs:annotation>
          <xs:documentation>
            Use specified key name to query LDAP for associated secret/symmetric key or certificate.
          </xs:documentation>
        </xs:annotation>
        <!-- constraint: 
             1) ONLY ALLOWED if (signatureGenerationKeyInfoType == (keyId OR certificateChain OR certificateThumbprint))
             2) Service Designer action builder MUST PROMPT developer for name to use in LDAP retrieval look-up.
        -->
      </xs:element>
    </xs:choice>
  </xs:complexType>
  <xs:complexType name="JsonDecryptSecurityToken">
    <xs:annotation>
      <xs:documentation>Security Token used by JWS verify actions</xs:documentation>
    </xs:annotation>
    <xs:choice>
      <xs:element name="security-config-package" type="wssec:SecurityConfigPackageType">
        <!-- constraint: ONLY ALLOWED if (encryptionAcceptKeyInfoType == (keyId OR certificateChain OR certificateThumbprint)) -->
        <!-- constraint: the following are deployment time check between REST policy and security config.
               1) If (keyType == x509) then must be name of asymmetricKeyPair security config object.
               2) If (keyType == symmetric) then must be name of sharedSecret security config object.
        -->
      </xs:element>
      <xs:element name="securityObjectNameFromWorkflow" type="wssec:SecurityObjectNameFromWorkflowType">
        <!-- constraint: ONLY ALLOWED if (encryptionAcceptKeyInfoType == (keyId OR certificateChain OR certificateThumbprint)) -->
        <!-- constraint: the following are deployment time check between REST policy and security config.
               1) If (keyType == x509) then must be name of asymmetricKeyPair security config object.
               2) If (keyType == symmetric) then must be name of sharedSecret security config object.
        -->
      </xs:element>
      <xs:element name="securityObjectNameFromKidClaim" type="wssec:EmptyType">
        <xs:annotation>
          <xs:documentation>
            Symmetric key from sharedSecret security config with keyname matching kid claim used.
          </xs:documentation>
        </xs:annotation>
        <!-- constraint: ONLY ALLOWED if (encryptionAcceptKeyInfoType == keyId) -->
      </xs:element>
      <xs:element name="keystore" type="wssec:EmptyType">
        <xs:annotation>
          <xs:documentation>
            Keystore is use to resolve incoming key info claim in incoming signature to associated key material.
            Use key name contained in incoming kid claim to query keystore for associated secret/symmetric key.
          </xs:documentation>
          <xs:appinfo>Note: operational code hardcoded to utilize keyname to get associated secret.</xs:appinfo>
        </xs:annotation>
        <!-- constraint: ONLY ALLOWED if (encryptionAcceptKeyInfoType == kid) -->
      </xs:element>
      <xs:element name="ldap" type="wssec:LdapSearchRequest">
        <xs:annotation>
          <xs:documentation>
            LDAP backend server used to resolve key info claim in incoming signature to associated key material.
            Use key name contained in incoming kid claim to query LDAP server for associated secret/symmetric key.
          </xs:documentation>
        </xs:annotation>
        <!-- constraint: ONLY ALLOWED if (encryptionAcceptKeyInfoType == kid) -->
      </xs:element>
    </xs:choice>
  </xs:complexType>
  <xs:complexType name="SecurityToken">
    <xs:annotation>
      <xs:documentation/>
    </xs:annotation>
    <xs:choice>
      <xs:element name="security-config-package" type="wssec:SecurityConfigPackageType">
        <xs:annotation>
          <xs:documentation>Using security object defined in application related security config package</xs:documentation>
        </xs:annotation>
        <!-- contraint: name specified must match abstract handle defined in associated security package.
                        Also the type of the security object in the security package and within the Ws-Security policy must match
        -->
      </xs:element>
      <xs:element name="securityTokenFromWorkflow" type="wssec:TokenFromWorkflowType">
        <!--  constraint: 1) Service Designer require to prompt developer for data from workflow when this WSSEC policy is bind to a 
                             specific action.
                          2) ONLY PRESENT if (referenced from encryptKeyInfo->keyRecipientPair->recipientKey).
                          3) NOT PRESENT if ((referenced from signatureInfo->keyPair) OR (referenced from signatureInfo->caPath)).
        -->
      </xs:element>
      <xs:element name="securityObjectNameFromWorkflow" type="wssec:SecurityObjectNameFromWorkflowType">
        <!--  constraint: 1)Service Designer require to prompt developer for data from workflow when this WSSEC policy is bind to a 
                            specific action.
                          2) ONLY PRESENT if (referenced from encryptKeyInfo->keyRecipientPair->recipientKey).
                          3) NOT PRESENT if ((referenced from signatureInfo->keyPair) OR (referenced from signatureInfo->caPath)).
        -->
      </xs:element>
      <!-- Deferred
      <xs:element name="localSqlDatabase" type="wssec:LocalSqlDatabase"/>
      -->
    </xs:choice>
  </xs:complexType>
  <xs:complexType name="GenerateKeystore">
    <xs:annotation>
      <xs:documentation>Retrieve information from the Keystore for populating security token.</xs:documentation>
    </xs:annotation>
    <xs:sequence>
      <xs:element name="sourceType" type="wssec:KeystoreSearchType"/>
      <!--  constraint: Service Designer require to prompt developer for source data from workflow when this WSSEC policy is bind to a specific action.
                        This data will be used in keystore search request action builder code will generate. 
      -->
    </xs:sequence>
  </xs:complexType>
  <xs:complexType name="LdapSearchRequest">
    <xs:annotation>
      <xs:documentation>
        Generate an LDAP search request to retrieve associated infomration required by operation given workflow supplied identity.
      </xs:documentation>
    </xs:annotation>
    <xs:sequence>
      <xs:element name="distinguishedNamePrefix" type="wssec:DistinguishedNameType">
        <xs:annotation>
          <xs:documentation>This string will be used to prefix the extracted identity being substituted in the search expression</xs:documentation>
        </xs:annotation>
      </xs:element>
      <xs:element name="distinguishedNamePostfix" type="wssec:DistinguishedNameType">
        <xs:annotation>
          <xs:documentation>This string will be used to postfix the extracted identity being substituted in the search expression.</xs:documentation>
        </xs:annotation>
      </xs:element>
      <xs:element name="resultAttrName">
        <xs:annotation>
          <xs:documentation>
            The name of the searchResponse - searchResultEntry - attr element containing the desired retrieve value, e.g., password,
            symmetric key, or certificate.
          </xs:documentation>
        </xs:annotation>
        <xs:simpleType>
          <xs:restriction base="xs:string">
            <xs:minLength value="1"/>
            <xs:pattern value="[a-zA-Z0-9_]*"/>
          </xs:restriction>
        </xs:simpleType>
      </xs:element>
      <xs:element name="serverUrl" type="xs:anyURI" minOccurs="0">
        <xs:annotation>
          <xs:documentation>
            Allows AAA Policy writer to bind LDAP IA to a specific backend server.
            This is very useful when automatically using the same AAA policy in multiple places so that they are all bound to same LDAP server.
          </xs:documentation>
          <!-- This element will be mapped to two advanced fields: server host name and port in service designer. Default port = 389 (636 for SSL/TLS future) -->
        </xs:annotation>
      </xs:element>
    </xs:sequence>
    <!-- constraint: When this policy is being bound to an action, Service Designer will need to ask the developer for the following information:
                    1) LDAP server address
                    2) LDAP server port number. Can be defaulted to 389. 636 for when LDAP over SSL/TLS.
                    3) LDAP administator Distinguished Name. This can be default to the LDAP acf config file associated with gnerated parntnerLink.
                    4) LDAP administrator Password. This can be default to the LDAP acf config file associated with gnerated parntnerLink.
    -->
    <!-- constraint: service designer must prompt developer to identify:
                     1) Value used to build distinguished name used in LDAP search request. Inserted between prefix and postfix strings 
                        from current workflow variable when this WS-Security policy is bound to a workflow action. 
                     Currently, restricted to be username.
    -->
    <!-- Associated action builder is required to bind these identified variables to the extension functions requirng them as input. -->
  </xs:complexType>
  <xs:complexType name="LocalSqlDatabase"/>
  <xs:simpleType name="DistinguishedNameType">
    <xs:restriction base="xs:string">
      <xs:pattern value="[\c ,;=@#\\\+]*"/>
    </xs:restriction>
  </xs:simpleType>
  <xs:simpleType name="SecurityConfigPackageType">
    <xs:restriction base="xs:NMTOKEN">
      <xs:minLength value="1"/>
      <xs:maxLength value="160"/>
    </xs:restriction>
  </xs:simpleType>
  <xs:simpleType name="IdPrefix">
    <xs:annotation>
      <xs:documentation>
        Prefix to be added to security token wsu:Id
        Makes it simplier for application code to locate desired security token.
      </xs:documentation>
    </xs:annotation>
    <xs:restriction base="xs:NMTOKEN">
      <xs:minLength value="1"/>
      <xs:maxLength value="64"/>
      <xs:pattern value="[-a-zA-Z0-9_]*"/>
      <!-- dash A-Z a-z 0-9 underscore period -->
    </xs:restriction>
  </xs:simpleType>
  <xs:simpleType name="KeystoreSearchType">
    <xs:restriction base="xs:string">
      <xs:enumeration value="username"/>
      <xs:enumeration value="keyname"/>
      <xs:enumeration value="certificate"/>
      <xs:enumeration value="SKI"/>
      <xs:enumeration value="generated-SKI"/>
      <xs:enumeration value="generate-short-SKI"/>
      <xs:enumeration value="issuer-serialnumber"/>
      <xs:enumeration value="sha1-fingerprint"/>
      <xs:enumeration value="md5-fingerprint"/>
      <xs:enumeration value="subjectname"/>
      <xs:enumeration value="keyvalue"/>
    </xs:restriction>
  </xs:simpleType>
  <xs:simpleType name="KeystoreSourceType">
    <xs:restriction base="xs:string">
      <xs:enumeration value="username"/>
      <xs:enumeration value="keyname"/>
      <xs:enumeration value="certificate"/>
      <xs:enumeration value="embedded-SKI"/>
      <xs:enumeration value="SKI"/>
      <xs:enumeration value="SKI-short"/>
      <xs:enumeration value="issuer-serialnumber"/>
      <xs:enumeration value="sha1-fingerprint"/>
      <xs:enumeration value="md5-fingerprint"/>
      <xs:enumeration value="subjectname"/>
      <xs:enumeration value="keyvalue"/>
    </xs:restriction>
    <!-- depeciated: will be removed at later time -->
  </xs:simpleType>
  <xs:simpleType name="SamlAssertionKeyInfo">
    <xs:annotation>
      <xs:documentation>What form of KeyInfo can be supported of SAML Assertion holder-of-key usage.</xs:documentation>
    </xs:annotation>
    <xs:restriction base="xs:string">
      <xs:enumeration value="SubjectName">
        <xs:annotation>
          <xs:documentation>X509Data: subject distiguished name from associated certificate</xs:documentation>
        </xs:annotation>
        <!-- constraint: only allowed is tokenType is x509 -->
      </xs:enumeration>
      <xs:enumeration value="SKI">
        <xs:annotation>
          <xs:documentation>
            X509Data: SubjectKeyIdentifier (SKI) from associated certificate.
            The subjectKeyIdentifier is an optional element with a certificate. 
            We can generate all the well-defined forms of it but we have no way of know what form the recepient will be expecting.
            This can cause interoperate failures.
            Therefore, WSSEC will automatically use optional element in specified certificate.
            If specified certificate does not contain optional SKI, WSSEC processing will fail.
          </xs:documentation>
        </xs:annotation>
        <!-- constraint: only allowed is tokenType is x509 -->
      </xs:enumeration>
      <xs:enumeration value="ThumbprintSha1">
        <xs:annotation>
          <xs:documentation>
            X509Data: ThumbprintSHA1 from associated certificate.
            The ThumbrintSHA1 is derived from the certificate. 
            It is also referred to s the SHA-1 Fingerprint in most browsers and X.509 PKI systems and our local keystore query mechanism.
          </xs:documentation>
        </xs:annotation>
        <!-- constraint: only allowed is tokenType is x509 -->
      </xs:enumeration>
      <xs:enumeration value="Certificate">
        <xs:annotation>
          <xs:documentation>X509Data: associated certificate</xs:documentation>
        </xs:annotation>
        <!-- constraint: only allowed is tokenType is x509 -->
      </xs:enumeration>
      <xs:enumeration value="RSAKeyValue">
        <xs:annotation>
          <xs:documentation>RSA public key modulus and exponent</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="KeyName">
        <xs:annotation>
          <xs:documentation>
            A character string that the signer or encrypter uses to uniquely identify the key to the recipent.
          </xs:documentation>
          <xs:appinfo>
            If tokenType is x509 then the subject name of the certificate is assumed.
            If tokenType is username then username is assumed. 
            If tokenType is symmetric then keyname is assumed.
          </xs:appinfo>
          <!-- constraint: ONLY ALLOWED if tokenType is X509 at this time. -->
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="BinarySecret">
        <xs:annotation>
          <xs:documentation>A raw symmetric key value.</xs:documentation>
          <xs:appinfo>
            We will automatically always generate a new random symmetric key for each SAML assertion being created.
            The symmetric key will be 32 bytes long, i.e., big enough for use with largest symmetric cipher, AES-256.
            Can be truncerated to work with any other encryption or signature symmetric algorithm.
          </xs:appinfo>
        </xs:annotation>
        <!-- constraint: NOT ALLOWED if (saml version == v1.0) -->
      </xs:enumeration>
      <!-- deferred
      <xs:enumeration value="IssuerSerial">
        <xs:annotation>
          <xs:documentation>X509Data: issuer distinguished name/serial number from associated certificate</xs:documentation>
          <xs:appinfo>constraint: only allowed is tokenType is x509</xs:appinfo>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="DSAKeyValue">
        <xs:annotation>
          <xs:documentation> DSA parameters:
            P (prime modulus), 
            Q (integer in the range 2**159 < Q < 2**160 which is a prime divisor of P-1), 
            G (integer with certain properties with respect to P and Q),
            Y (G**X mod P (where X is part of the private key and not made public))
          </xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      -->
    </xs:restriction>
  </xs:simpleType>
  <xs:complexType name="EmptyType"/>
</xs:schema>
