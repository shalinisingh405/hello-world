<?xml version="1.0" encoding="UTF-8"?>
<xs:schema  
  xmlns:xs="http://www.w3.org/2001/XMLSchema" 
  xmlns:aaa="http://www.intel.com/soae/localService/aaaDefinition-2007a/" 
  targetNamespace="http://www.intel.com/soae/localService/aaaDefinition-2007a/">
  <!-- ======================================================================================================= -->
  <!--   Authentication, Authorization and Audit (AAA) Schema                                                  -->
  <!-- ======================================================================================================= -->
  <xs:element name="aaaPolicy" type="aaa:AaaDefinition"/>
  <xs:complexType name="AaaDefinition">
    <xs:annotation>
      <xs:documentation>
        Defines application developer level Authentication, Authorization and Audit (AAA) Information.
        Actual security token, e.g., private key, trusted CA group, etc., and associate critical Cryptographic 
        Security Parameters (CSPs), e.g., verification depth, CRL checking, etc., are defined in associated 
        security config file.
      </xs:documentation>
    </xs:annotation>
    <xs:all>
      <xs:element name="identityProcessing" type="aaa:IdentityProcessing"/>
      <xs:element name="resourceProcessing" type="aaa:ResourceProcessing" minOccurs="0"/>
    </xs:all>
    <xs:attribute name="writeTransactionLog" type="xs:boolean" use="optional" default="true">
      <xs:annotation>
        <xs:documentation>Controls logging AAA failure to the transaction log at log level == ERROR.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="logSuccessfulCompletionOfAaa" type="xs:boolean" use="optional" default="false">
      <xs:annotation>
        <xs:documentation>Controls logging of successful AAA actions to the transaction log.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="logStartOfAaa" type="xs:boolean" use="optional" default="false">
      <xs:annotation>
        <xs:documentation>Controls logging of the AAA actions starting to the transaction log.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="logLevel" use="optional" default="ERROR">
      <xs:annotation>
        <xs:documentation>Control at what level success completion and starting AAA status will be logged.</xs:documentation>
      </xs:annotation>
      <xs:simpleType>
        <xs:restriction base="xs:string">
          <xs:enumeration value="FATAL">
            <xs:annotation>
              <xs:documentation>
                Very severe error that will probably lead to process abort and restart. Written to exception log. 
                May also show up as internal-processing-failure wihtin a transaction log entry.
              </xs:documentation>
            </xs:annotation>
          </xs:enumeration>
          <xs:enumeration value="ERROR">
            <xs:annotation>
              <xs:documentation>
                Transactional failure, but should not affect underlying process. Written to exception log.
                Should also show up as internal-processing-failure or failure in transaction log entry. 
              </xs:documentation>
            </xs:annotation>
          </xs:enumeration>
          <xs:enumeration value="WARNING">
            <xs:annotation>
              <xs:documentation>Indicates a potentially harmful situation. Written to exception log.</xs:documentation>
            </xs:annotation>
          </xs:enumeration>
          <xs:enumeration value="INFO">
            <xs:annotation>
              <xs:documentation>
                Highlight progress at a coarse-grain level. For operational code such as input servers or invocation agents, 
                INFO would map to summary reports to the transaction log. For non-operational code such as OAM, INFO would  
                map to log entries being written to the exception log.
              </xs:documentation>
            </xs:annotation>
          </xs:enumeration>
          <xs:enumeration value="VERBOSE">
            <xs:annotation>
              <xs:documentation> 
                Highlight progress at a finer-grain then INFO. 
                Currently, the only components using this logtype is operational code that is mapping start and enhanced
                transaction log entries.
              </xs:documentation>
            </xs:annotation>
          </xs:enumeration>
          <xs:enumeration value="DEBUG">
            <xs:annotation>
              <xs:documentation>
                Fine-grain information that is must appropriate to debugging an application. Written to exception log.
              </xs:documentation>
            </xs:annotation>
          </xs:enumeration>
          <xs:enumeration value="TRACE">
            <xs:annotation>
              <xs:documentation>
                Detail bulk data, e.g., entire received message, internal ESII representation of document, etc. 
                Written to the trace log.
              </xs:documentation>
            </xs:annotation>
          </xs:enumeration>
        </xs:restriction>
      </xs:simpleType>
    </xs:attribute>
    <xs:attribute name="soapVersion" type="aaa:SoapVersion" use="optional" default="deferred">
      <!-- constraint: ONLY PRESENT if (bindingType == SOAP) -->
    </xs:attribute>
    <xs:attribute name="wssecVersion" type="aaa:WssecVersion" default="2004-01">
      <!-- constraint: ONLY PRESENT if (bindingType == SOAP) -->
    </xs:attribute>
    <xs:attribute name="samlVersion" type="aaa:SamlVersion" use="optional" default="2.0"/>
    <xs:attribute name="wsAddressingVersion" type="aaa:WsAddressingVersion" use="optional" default="2005-08">
      <!-- constraint: ONLY PRESENT if (bindingType == SOAP) -->
    </xs:attribute>
    <xs:attribute name="oauthVersion" type="aaa:OAuthVersion" default="OAuth2-draft-26"/>
  </xs:complexType>
  <xs:simpleType name="SoapVersion">
    <xs:annotation>
      <xs:documentation>Web Service (WS-)Simple Object Access Protocol (SOAP) Versions</xs:documentation>
    </xs:annotation>
    <xs:restriction base="xs:string">
      <xs:enumeration value="1.1"/>
      <xs:enumeration value="1.2"/>
      <xs:enumeration value="deferred">
        <xs:annotation>
          <xs:documentation>
            This indicates that the actual SOAP version to be utilized will be determined by Service Designer Action
            Builder based upon information associated with the workflow that the AAA operation has been bound to.
            This allows an application to define a single AAA Policy that is reusable in multiple workflows using 
            different SOAP versions. 
          </xs:documentation>
        </xs:annotation>
      </xs:enumeration>
    </xs:restriction>
  </xs:simpleType>
  <xs:simpleType name="SamlVersion">
    <xs:annotation>
      <xs:documentation>Security Assertion Markup Language Versions</xs:documentation>
    </xs:annotation>
    <xs:restriction base="xs:string">
      <xs:enumeration value="1.1"/>
      <xs:enumeration value="2.0"/>
      <xs:enumeration value="1.0"/>
    </xs:restriction>
  </xs:simpleType>
  <xs:simpleType name="WssecVersion">
    <xs:annotation>
      <xs:documentation>Web Service Security Versions</xs:documentation>
    </xs:annotation>
    <xs:restriction base="xs:string">
      <xs:enumeration value="2004-01"/>
      <xs:enumeration value="2002-07"/>
      <xs:enumeration value="2002-12"/>
      <xs:enumeration value="2003-06"/>
    </xs:restriction>
  </xs:simpleType>
  <xs:simpleType name="WsAddressingVersion">
    <xs:annotation>
      <xs:documentation>Web Service Addressing Versions</xs:documentation>
    </xs:annotation>
    <xs:restriction base="xs:string">
      <xs:enumeration value="2005-08">
        <xs:annotation>
          <xs:documentation>
            Official/Approved version of Web Services Addressing 1.0 - Core; 
            W3C Recommendation 9 May 2006
            Maps to wsa namespace = "http://www.w3.org/2005/08/addressing".
          </xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="2004-08">
        <xs:annotation>
          <xs:documentation>
            Draft version of Web Services Addressing (WS-Addressing);
            W3C Member Submission 10 August 2004
            Maps to wsa namespace = "http://schemas.xmlsoap.org/ws/2004/08/addressing".
          </xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="2004-03">
        <xs:annotation>
          <xs:documentation>
            Draft version of Web Services Addressing (WS-Addressing);
            W3C Member Submission: WS-Addressing Specification 2004-03-30
            Maps to wsa namespace = "http://schemas.xmlsoap.org/ws/2004/03/addressing".
          </xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="2003-03">
        <xs:annotation>
          <xs:documentation>
            Draft version of Web Services Addressing (WS-Addressing);
            W3C Member Submission: 13 March 2003
            Maps to wsa namespace = "http://schemas.xmlsoap.org/ws/2003/03/addressing".
          </xs:documentation>
        </xs:annotation>
      </xs:enumeration>
    </xs:restriction>
  </xs:simpleType>
  <xs:simpleType name="OAuthVersion">
    <xs:restriction base="xs:string">
      <xs:enumeration value="OAuth2-draft-26">
        <xs:annotation>
          <xs:documentation>
            The OAuth 2.0 Authorization Protocol draft-ietf-oauth-v2-26, May 1, 2012.
          </xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="OAuth2-draft-25">
        <xs:annotation>
          <xs:documentation>
            The OAuth 2.0 Authorization Protocol draft-ietf-oauth-v2-25, March 8, 2012.
          </xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="OAuth2-draft-24">
        <xs:annotation>
          <xs:documentation>
            The OAuth 2.0 Authorization Protocol draft-ietf-oauth-v2-24, March 8, 2012.
          </xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="OAuth2-draft-23">
        <xs:annotation>
          <xs:documentation>
            The OAuth 2.0 Authorization Protocol draft-ietf-oauth-v2-23, January 21, 2012.
          </xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="OAuth2-draft-22">
        <xs:annotation>
          <xs:documentation>
            The OAuth 2.0 Authorization Protocol draft-ietf-oauth-v2-22, September 22, 2011.
          </xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="OAuth2-draft-21">
        <xs:annotation>
          <xs:documentation>
            The OAuth 2.0 Authorization Protocol draft-ietf-oauth-v2-21, September 5, 2011.
          </xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="OAuth2-draft-20">
        <xs:annotation>
          <xs:documentation>
            The OAuth 2.0 Authorization Protocol draft-ietf-oauth-v2-20, July 25, 2011.
          </xs:documentation>
        </xs:annotation>
      </xs:enumeration>
    </xs:restriction>
  </xs:simpleType>
  <xs:complexType name="IdentityProcessing">
    <xs:annotation>
      <xs:documentation>
        Defines Identity Related AAA Processing
      </xs:documentation>
    </xs:annotation>
    <xs:sequence>
      <xs:element name="extractIdentity" type="aaa:ExtractIdentity" minOccurs="0">
        <!-- constraint: ONLY ALLOWED NOT to be present/populated if map identity is createTokenViaWsTrust -->
      </xs:element>
      <xs:element name="authenticateIdentity" type="aaa:AuthenticateIdentity" minOccurs="0">
        <!-- constraint: NOT ALLOWED if (extract identity nameFromOAuthAuthorizationRequest resourceOwnerSource == name_only_from_workflow) -->
      </xs:element>
      <xs:element name="mapIdentity" type="aaa:MapIdentity" minOccurs="0"/>
    </xs:sequence>
  </xs:complexType>
  <xs:complexType name="ResourceProcessing">
    <xs:annotation>
      <xs:documentation>
        Defines Resource Related AAA Processing
      </xs:documentation>
    </xs:annotation>
    <xs:sequence>
      <xs:element name="extractResource" type="aaa:ExtractResource" minOccurs="0">
        <!-- constraint: 
          1) if ((extractResource element is populated) AND 
                 ((map identity is CreateCookie) AND (%r is not utilized in setCookieFormatString)) AND
                 ((LdapAuthorization is enabled) AND (%r in not used in group-DN or search-filter formatting strings)) AND
                 ((SiteMinderAuthentication OR OracleAccessManagerAuthentication) is not using extracted resource)) AND
                 ((SiteMinderAuthorize OR OracleAccessManagerAuthorize OR TivoliAccessManagerAuthorize OR XACML Oracle Entitlement Server) is not using extracted resource))
                ) then generate WARNING about extracted resource may not be utilizied.
        -->
        <!-- Note: resource could be explicitly retrieved and used by application via an explicit get-metadata action after the AAA action -->
      </xs:element>
      <xs:element name="authorizeResource" type="aaa:AuthorizeResource" minOccurs="0"/>
      <!-- deferred
      <xs:element name="mapResource" type="aaa:MapResource" minOccurs="0"/>
      -->
    </xs:sequence>
  </xs:complexType>
  <xs:simpleType name="FaultHandling">
    <xs:annotation>
      <xs:documentation>
        Defines how any fault encountered when performing AAA action will be handled.
        Information concerning the reason for dropping the request will be logged in the transaction log along
        with an interval alert.
        The fault handling intention will be passed to the application via BEPL fault handling (throw) from the AAA scope.
      </xs:documentation>
    </xs:annotation>
    <xs:restriction base="xs:string">
      <xs:enumeration value="drop-silently">
        <xs:annotation>
          <xs:documentation>
            Incoming request should be dropped silently.
            Sender should be given no information because of the possibly that the sender is an attacker.
          </xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="return-fault">
        <xs:annotation>
          <xs:documentation>The reason for the AAA failure will be returned to the application workflow process for handling.</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
    </xs:restriction>
  </xs:simpleType>
  <xs:complexType name="ExtractIdentity">
    <xs:annotation>
      <xs:documentation>Defines where the Identity should be extracted from.</xs:documentation>
    </xs:annotation>
    <xs:choice>
      <xs:element name="usernameFromHttpBasicAuthenticationHeader">
        <xs:annotation>
          <xs:documentation>
            HTTP Basic Authentication Header. 
            We can automatically find the Authorization element in protocol header metadata and extract
            the value, e.g.,
              POST /InStock HTTP/1.1 
              Host: www.acme.org 
              Content-Type: text/xml; 
              charset=utf-8 
              Content-Length: nnnn
              Authorization: Basic ABxhEDCpbkhvdvcJNuIEDlc2TtPK==
            
            From unbased64 value, the username:password will be recovered.
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:sequence minOccurs="0">
            <xs:element name="specialExceptionHandling" type="aaa:AuthenticationExceptionHandling" minOccurs="0">
              <xs:annotation>
                <xs:documentation>
                  Contains special exception handling details that are to be populated in the exception being thrown because
                  the input document does not contain HTTP Basic Authentication credentials.
                  Operational code will generate error string containing detailed information to be package within response 
                  to client.
                  The ultimate HTTP response will include HTTP status, expected token type and realm. The response message
                  will be of the folowing form:
                  ["401 Unauthorized WWW-Authenticate: " | "407 Proxy Authentication Required Proxy-Authetnication: "]  
                  "Basic realm="" &lt;realm&gt; """
                </xs:documentation>
              </xs:annotation>
              <!-- constraint: ONLY ALLOWED values for typeFailureResponse = (401-Unauthorized OR 407-Proxy Authentication Request) -->
            </xs:element>
          </xs:sequence>
        </xs:complexType>
      </xs:element>
      <xs:element name="usernameFromSecurityHeader" type="aaa:UsernameTokenEmptyType">
        <xs:annotation>
          <xs:documentation>
            Username token from WS-Security Header in PasswordText format.
            This is required when the security token is not being used with a signature verification operation.
            A small XML fragment containing the full UsernameToken element would be made available, not just the
            Username element.
          </xs:documentation>
        </xs:annotation>
      </xs:element>
      <xs:element name="derivedUsernameFromSecurityHeader" type="aaa:UsernameTokenEmptyType">
        <xs:annotation>
          <xs:documentation>
            Username token from WS-Security Header in PasswordDigest format.
            This is required when the security token is not being used with a signature verification operation.
            A small XML fragment containing the full UsernameToken element would be made available, not just the
            Username element. The digest contained within the username token will be verified in authenticateIdentity
            if a token resoultion mechanism is selected like keystore, LDAP, etc. is selected. 
          </xs:documentation>
        </xs:annotation>
      </xs:element>
      <xs:element name="usernamePasswordFromWorkflow" type="aaa:EmptyType">
        <!-- constraint: service designer must prompt developer to identify:
                         1) username, and 
                         2) passwood 
                         from current workflow variable when this AAA policy is bound to a workflow action. 
        -->
        <!-- Associated action builder is required to bind these identified variables to the extension functions requirng them as input. -->
      </xs:element>
      <xs:element name="certificateFromPeerSsl" type="aaa:CertificateAttributeWithSubExtraction">
        <xs:annotation>
          <xs:documentation>X.509 certificate attribute from SSL/TLS (transport layer) peer.</xs:documentation>
        </xs:annotation>
      </xs:element>
      <xs:element name="x509CertificateFromSecurityHeader" type="aaa:WsCertificateAttributeWithSubExtraction">
        <xs:annotation>
          <xs:documentation>
            BinarySecurityToken (KeyInfo is full X.509 Certificate) from WS-Security Header.
            This is required when the security token is not being used with a signature verification operation.
            Only the value of the BinarySecurityToken element will be passed.
            
            Indicated what certificate attribute from X.509 certificate in BST that we are to use as identiity.
          </xs:documentation>
        </xs:annotation>
      </xs:element>
      <xs:element name="certificateAttributeFromSecurityHeader" type="aaa:WsCertificateAttributeWithSubExtraction">
        <xs:annotation>
          <xs:documentation>
            Identify the specific type of derived BinarySecurityToken KeyInfo to use for the extracted identity.
            X.509 certificate supports the following types of derived attribute: subject name, subject key identifier, thumbprintSha1 (sha1-fingerprint), 
            issuer/serial number. A Binary security token may contain one of more of these devired types with/without the full certificate.
            This is required when the security token is not being used with a signature verification operation.
          </xs:documentation>
        </xs:annotation>
        <!-- constraint: fullCertificate, Md5Fingerprint generatedSKI & generateShortSKI are not allowed. -->
      </xs:element>
      <xs:element name="x509CertificateFromWorkflow" type="aaa:CertificateAttributeWithSubExtraction">
        <xs:annotation>
          <xs:documentation>
            BinarySecurityToken (KeyInfo is full X.509 Certificate) from Application Workflow.
            This is required in the rare situation when a non-standard mechanism is being utilized for supplying the certificate.
            
            Indicated what certificate attribute from X.509 certificate in BST that we are to use as identiity.
          </xs:documentation>
          <xs:appinfo>
            Service Designer action builder must prompt for certificate when AAA policy bound to an action. 
            Certificate must be in either PEM or base-64 encoded DER format.
          </xs:appinfo>
        </xs:annotation>
      </xs:element>
      <xs:element name="bstFromVerifyOperation" type="aaa:CertificateAttributeWithSubExtraction">
        <xs:annotation>
          <xs:documentation>X.509 certificate from signature verification operation.</xs:documentation>
          <xs:appinfo>
            Service Designer action builder must prompt application developer to identity the WS-Security policy whose should be 
            exporting their resolved X.509 certificate (PKC) when this policy is bound to an action.
          </xs:appinfo>
        </xs:annotation>
      </xs:element>
      <xs:element name="nameFromSamlAttribute" type="aaa:VerifyDecryptValidateExtractSamlAssertion">
        <!-- constraint: only ALLOWED if SAML version is 1.0 or 1.1 -->
      </xs:element>
      <xs:element name="nameFromSamlAuthentication" type="aaa:VerifyDecryptValidateExtractSamlAssertion">
        <!-- constraint: only ALLOWED if SAML version is 1.0 or 1.1 -->
      </xs:element>
      <xs:element name="nameFromSamlSubject" type="aaa:VerifyDecryptValidateExtractSamlAssertion"/>
      <xs:element name="samlArtifact" type="aaa:EmptyType">
        <xs:annotation>
          <xs:documentation>
            SAML Artifact. 
            We can automatically find the SAML artifact value by scanning the protocol header metadata for an
            element with SAMLART or SAMLart in its name, e.g., https://server.domain.com/service?SAMLART=ed642kkokh
          </xs:documentation>
        </xs:annotation>
        <!-- deferred to a future release -->
      </xs:element>
      <xs:element name="clientIpAddressFromTransportLayer" type="aaa:EmptyType">
        <xs:annotation>
          <xs:documentation>Client source IP-address.</xs:documentation>
        </xs:annotation>
        <!-- deferred to a future release -->
      </xs:element>
      <xs:element name="ssoFromCookie" type="aaa:CookieInfo">
        <xs:annotation>
          <xs:documentation>
            Single Sign On (SSO).
            Extract SSO token from HTTP Input Server metadata.
          </xs:documentation>
        </xs:annotation>
      </xs:element>
      <xs:element name="ssoFromWorkflow" type="aaa:EmptyType">
        <xs:annotation>
          <xs:documentation>
            Arbitrary extraction mechanism to get the SSO token from wherever it is residing in the workflow.
            Could be the message body or associated incoming protocol metadata, e.g., arbitrary HTTP header field.
          </xs:documentation>
        </xs:annotation>
        <!-- Personally would defer the testing of this option -->
        <!-- constraint: service designer action builder must prompt developer to identify SSO token from current workflow
                         variable when this AAA policy is bound to a workflow action. 
        -->
      </xs:element>
      <xs:element name="principalNameFromKerberosToken">
        <xs:annotation>
          <xs:documentation>
            Extracts the principal from a WS-Security Kerberos Token from the WS-Security Header within the SOAP header.
          </xs:documentation>
          <xs:appinfo>
            The principal name (or extracted primary component) is used as the extracted identity.
            The entire Kerberos WS-Security token is extracted and made available to the optional validate Kerberos authentication mechanism.
          </xs:appinfo>
        </xs:annotation>
        <xs:complexType>
          <xs:attribute name="extractPrimary" type="xs:boolean" use="optional" default="true">
            <xs:annotation>
              <xs:documentation>
              Indicates that the first part of a Kerberos principal is to be extracted.
              
              The principal name identifies a specific entity to which a set of credentials may be assigned.
              While the principal name can be an arbitrary number of components, it is usually has three components, e.g., primary/instance@REALM:
              1) primary: first part of a Kerberos principal. In the case of a user, this is the username. In the case of a service, it is the 
                 name of the service.
              2) instance: second part of Kerberos principal. It gives information that qualifies the primary. The instance maybe null.
                 In case of user, the instance is often used to describe the intended use of the corresponding credentials. When a host (service),
                 the instance fully qualifies the hostname.
              3) realm: identifies the logical network served by a single Kerberos database and its associated set of Key Distribution Centers.
                 By convention, the realm names are generally all uppercase letters to differentiate the realm from an internet domain.
            </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="actor" type="aaa:ActorType" use="optional"/>
        </xs:complexType>
        <!-- constraint: WARNING "No Kerberos token validation/authentication is being performed. The principalNameFromKerberosToken"
                                 "extraction will only determine that there is a Kerberos token present. It will not ensure that"
                                 "it is a valid kerberos token or beable to extract the client primary name."
                         if (authenticateIdentity != validateKerberosToken)
        -->
      </xs:element>
      <xs:element name="principalNameFromSpnegoToken">
        <xs:annotation>
          <xs:documentation>
            Extracts the principal from a SPNEGO Token from the HTTP Authenticate Negotiate header.
            Within the SPNEGO toke is embedded is some form of a Kerberos token.
          </xs:documentation>
          <xs:appinfo>
            The principal name (or extracted primary component) is used as the extracted identity.
            The entire Kerberos token is extracted and made available to the optional validate Kerberos authentication mechanism.
          </xs:appinfo>
        </xs:annotation>
        <xs:complexType>
          <xs:attribute name="extractPrimary" type="xs:boolean" use="optional" default="true">
            <xs:annotation>
              <xs:documentation>
              Indicates that the first part of a Kerberos principal is to be extracted.
              
              The principal name identifies a specific entity to which a set of credentials may be assigned.
              While the principal name can be an arbitrary number of components, it is usually has three components, e.g., primary/instance@REALM:
              1) primary: first part of a Kerberos principal. In the case of a user, this is the username. In the case of a service, it is the 
                 name of the service.
              2) instance: second part of Kerberos principal. It gives information that qualifies the primary. The instance maybe null.
                 In case of user, the instance is often used to describe the intended use of the corresponding credentials. When a host (service),
                 the instance fully qualifies the hostname.
              3) realm: identifies the logical network served by a single Kerberos database and its associated set of Key Distribution Centers.
                 By convention, the realm names are generally all uppercase letters to differentiate the realm from an internet domain.
            </xs:documentation>
            </xs:annotation>
          </xs:attribute>
        </xs:complexType>
      </xs:element>
      <xs:element name="nameFromOAuthAuthorizationRequest">
        <xs:annotation>
          <xs:documentation>
            We are expecting to see an HTTP request matching the requirements associated with that flow type.
            From the HTTP header and body, we will valid that all of the required entities are defined correctly
            and to extract the client and user credentials.
          </xs:documentation>
          <xs:appinfo>
            We need to ensure that for all failure that a HTTP 400 (Bad Request) with the appropriate error status code
            is returned with the exception of an invalid_client that is required to be mapped to a 
            HTTP 401 (Unauthorized) response.
            
            Additionally, we may need to save several other fields from the incoming HTTP OAuth request and potenially
            make them available to make exportable to the application or to other parts of AAA . For example, a client
            could include a state and scope on their incoming request. For example:
              1) The state should be copied into a successful OAuth response from the incoming request. This is 
                 processing is embedded entirely within AAA.
              2) Enhanced application checking of the scope 
          </xs:appinfo>
        </xs:annotation>
        <xs:complexType>
          <xs:sequence>
            <xs:element name="flowType" default="AuthorizationCode">
              <xs:simpleType>
                <xs:restriction base="xs:string">
                  <xs:enumeration value="AuthorizationCode">
                    <xs:annotation>
                      <xs:documentation>
                        An AuthorizationCode flow consists of two exchanges with the authorization server.
                        In the first exchange, an authorization request is sent. This comes from the user browser based
                        upon a redirect from the client (web service). It contains information identifying the client
                        with associated information. The authorization server must communicate with the user to get
                        their approval for granting the specific client access to the specified user information.
                        An example request would be:
                          GET /authorize?response_type=code&amp;client_id=s6BhdRkqt3&amp;state=xyz
                            &amp;redirect_uri=https%3A%2F%2Fclient%2Eexample%2Ecom%2Fcb HTTP/1.1
                          Host: server.example.com
                        where response_type, client_id, state, redirect_uri and scope are required, recommended or
                        optional parameters. If authorization is approved then the authorization server will generate
                        an authorization "code" commonly called a grant and return it to the user browser to return
                        to the client (the redirect_uri from the request):
                        For example,
                          HTTP/1.1 302 Found
                          Location: https://client.example.com/cb?code=SplxlOBeZQQYbYS6WxSbIA&amp;state=xyz
                          
                        The client will then take the code value and package it into an authorization_code request
                        get an access_token, e.g.,
                          POST /token HTTP/1.1
                          Host: server.example.com
                          Authorization: Basic czZCaGRSa3F0MzpnWDFmQmF0M2JW
                          Content-Type: application/x-www-form-urlencoded;charset=UTF-8
                          
                          grant_type=authorization_code&amp;code=SplxlOBeZQQYbYS6WxSbIA
                            &amp;redirect_uri=https%3A%2F%2Fclient%2Eexample%2Ecom%2Fcb
                      </xs:documentation>
                      <xs:appinfo>
                        Since the authorization code (grant) is internal to the authorization server, i.e., generated
                        by the authorization server on a grantRequest and then consumed by the authorization, we can 
                        produce a SAML assertion with all the required information, e.g., audience and receipient 
                        populated along with expiration time less than 10 minutes and then consume it on 
                        an accessTokenRequest enforcing all of the desired checks, e.g., uniqueness, desired client, etc.
                      </xs:appinfo>
                    </xs:annotation>
                  </xs:enumeration>
                  <xs:enumeration value="ImplicitGrant">
                    <xs:annotation>
                      <xs:documentation>
                        The incoming HTTP request will have the following form:
                          GET /authorize?response_type=token&amp;client_id=s6BhdRkqt3&amp;state=xyz
                                                            &amp;redirect_uri=https://client.example.com/cb HTTP/1.1
                          Host: server.example.com
                        where response_type is required MUST be set to token
                              client_id is REQUIRED,
                              redirect_uri is OPTIONAL but is normally required and value is known from client registratkion process,
                              scope is OPTIONAL, and
                              state is RECOMMENDED. The parameter SHOULD be used to prevent cross-site request forgery.
                      </xs:documentation>
                    </xs:annotation>
                  </xs:enumeration>
                  <xs:enumeration value="RefreshToken">
                    <xs:annotation>
                      <xs:documentation>
                        Refresh tokens are credentials used to obtain access tokens. Refresh tokens are issued to the client by the
                        authorization server and are used to obtain a new access token when the current access token becomes invalid or
                        expires, or to obtain additional access tokens with identical or narrower scope (access tokens may have a
                        shorter lifetime and fewer permissions than authorized by the resource owner).
                        If a refresh token was generated on the original access token request then the client at a later time could 
                        issue the following request to generate a new access token and refresh token, e.g.,
                          POST /token HTTP/1.1
                          Host: server.example.com
                          Authorization: Basic czZCaGRSa3F0MzpnWDFmQmF0M2JW
                          Content-Type: application/x-www-form-urlencoded;charset=UTF-8
                          
                          grant_type=refresh_token&amp;refresh_token=tGzv3JOkF0XG5Qx2TlKWIA
                          
                        Note: that it does have its own unique grant_type value, i.e., is really a unique OAuth flow.
                      </xs:documentation>
                      <xs:appinfo>
                        Since a refresh token is entirely internal to the authorization server we can utilize a modified grant encoding for
                        our refresh encoding. In particular, we will utilize a SAML assertion with grant provising except that the Audience
                        restriction has been changed to REFRESH-ONLY.
                        
                        The client can specify an optional scope value on this call. If none is specified then we will assume that the
                        client is asking for the full scope defined within the refresh token. If the client specify a scope then that scope
                        must be covered by the scope defined within the refresh token.
                      </xs:appinfo>
                    </xs:annotation>
                    <!-- constraint: consistency check between AAA policies, i.e., wizard constraint. 
                                     For example, scope in AAA refresh policies must be subset of all policies for following AAA policies:
                                     ((flowType == (ResourceOwnerXxxCredential OR ClientCredential OR ImplictGrant)) AND 
                                      (authorizationCodeRequestType == accessTokenRequest) AND
                                      (roleBeingChecked == resourceOwner)
                                     )
                    -->
                  </xs:enumeration>
                  <xs:enumeration value="ClientCredential">
                    <xs:annotation>
                      <xs:documentation>
                        The incoming HTTP request will have the following form:
                          POST /token HTTP/1.1 
                          Host: server.example.com 
                          Authorization: Basic czZCaGRSa3F0MzpnWDFmQmF0M2JW 
                          Content-Type: application/x-www-form-urlencoded;charset=UTF-8 
                          
                          grant_type=client_credentials&amp;scope=list-of_case-sensitive_space-delimited_strings
                           
                        where the client name and password are carried in the Authorization: Basic entity.
                        Extract code should check that Content-Type and grant_type are correctly populated.
                        Note: there is no user credential to check in this flow.
                      </xs:documentation>
                    </xs:annotation>
                  </xs:enumeration>
                  <xs:enumeration value="ResourceOwnerPasswordCredential">
                    <xs:annotation>
                      <xs:documentation>
                        The incoming HTTP request will have the following form:
                          POST /token HTTP/1.1 
                          Host: server.example.com 
                          Authorization: Basic czZCaGRSa3F0MzpnWDFmQmF0M2JW 
                          Content-Type: application/x-www-form-urlencoded;charset=UTF-8
                          
                          grant_type=password&amp;username=johndoe&amp;password=A3ddj3w&amp;scope=list-of_case-sensitive_strings  
                        where the client name and password are carried in the Authorization: Basic entity
                        and the user name and password are in the body.
                        Extract code should check that Content-Type and grant_type are correctly populated.
                      </xs:documentation>
                    </xs:annotation>
                  </xs:enumeration>
                  <xs:enumeration value="ResourceOwnerSamlAssertionCredential">
                    <xs:annotation>
                      <xs:documentation>
                        SAML v2.0 Bearer assertion is use as an authorization grant.
                        The value of "grant_type" parameter MUST be "urn:ietf:params:oauth:grant-type:saml2-bearer".
                        The value of the "assertion" parameter MUST contain a single SAML 2.0 Assertion. The SAML
                        Assertion XML data MUST be encoded using base64url, where the encoding adheres to the 
                        definition in Section 5 of RFC4648 [RFC4648] and where the padding bits are set to zero. 
                        To avoid the need for subsequent encoding steps (by "application/x-www-form-urlencoded" 
                        [W3C.REC-html401-19991224], for example), the base64url encoded data SHOULD NOT be line 
                        wrapped and pad characters ("=") SHOULD NOT be included.
                        
                        For example:
                          POST /token.oauth2 HTTP/1.1
                          Host: authz.example.net
                          Content-Type: application/x-www-form-urlencoded
                          
                          grant_type=urn%3Aietf%3Aparams%3Aoauth%3Agrant-type%3Asaml2-bearer&amp;
                          assertion=PEFzc2VydGlvbiBJc3N1ZUl[...omitted for brevity...]aG5TdGF0ZW1lbnQ-PC9Bc3NlcnRpb24-
                      </xs:documentation>
                    </xs:annotation>
                  </xs:enumeration>
                </xs:restriction>
              </xs:simpleType>
            </xs:element>
            <xs:element name="authorizationCodeRequestType" default="accessTokenRequest">
              <xs:simpleType>
                <xs:restriction base="xs:string">
                  <xs:enumeration value="grantRequest">
                    <xs:annotation>
                      <xs:documentation>
                        An example request would be:
                          GET /authorize?response_type=code&amp;client_id=s6BhdRkqt3&amp;state=xyz
                            &amp;redirect_uri=https%3A%2F%2Fclient%2Eexample%2Ecom%2Fcb HTTP/1.1
                          Host: server.example.com
                        where response_type is REQUIRED. Value MUST be set to "code",
                              client_id is REQUIRED,
                              redirect_uri is OPTIONAL,
                              scope is OPTIONAL. The scope of the access request, and
                              state is RECOMMENDED. An opaque value used by the client to maintain state between
                                the request and callback. The authorization server includes this value when
                                redirecting the user-agent back to the client. The parameter SHOULD be used for
                                preventing cross-site request forgery.
                        
                        If authorization is approved then the authorization server will generate
                        an authorization "code" commonly called a grant and return it to the user browser to return
                        to the client (the redirect_uri from the request):
                        For example,
                          HTTP/1.1 302 Found
                          Location: https://client.example.com/cb?code=SplxlOBeZQQYbYS6WxSbIA&amp;state=xyz
                          
                        where code is REQUIRED. The authorization code generated by the authorization server. The
                                   authorization code MUST expire shortly after it is issued to mitigate the risk of
                                   leaks. A maximum authorization code lifetime of 10 minutes is RECOMMENDED.
                                   The client MUST NOT use the authorization code more than once. If an authorization
                                   code is used more than once, the authorization server MUST deny the request and SHOULD
                                   attempt to revoke all tokens previously issued based on that authorization code. The
                                   authorization code is bound to the client identifier and redirection URI.
                              state is REQUIRED if the state parameter was present in the client authorization request.
                                    The exact value received from the client.
                      </xs:documentation>
                    </xs:annotation>
                    <!-- constraint: ONLY ALLOWED if (flowType == AuthorizationCode) -->
                  </xs:enumeration>
                  <xs:enumeration value="accessTokenRequest">
                    <xs:annotation>
                      <xs:documentation>
                        If this is an AuthorizationCode flow this request maps a authorization code (grant) into a access token.
                        An example request would be:
                          POST /token HTTP/1.1
                          Host: server.example.com
                          Authorization: Basic czZCaGRSa3F0MzpnWDFmQmF0M2JW
                          Content-Type: application/x-www-form-urlencoded;charset=UTF-8
                          grant_type=authorization_code&amp;code=SplxlOBeZQQYbYS6WxSbIA
                            &amp;redirect_uri=https%3A%2F%2Fclient%2Eexample%2Ecom%2Fcb
                            
                        where grant_type is REQUIRED. Value MUST be set to authorization_code.
                              code is REQUIRED. The authorization code received from the authorization server.
                              redirect_uri is REQUIRED, if the redirect_uri parameter was included in the authorization
                                           request and their values MUST be identical.
                                           
                        For the other flow types: ImplicitGrant, ClientCredential, ResourceOwnerPasswordCredential,
                        ResourceOwnerSamlAssertionCredential and RefreshToken, the access token is generated based upon
                        the explicitly supplied parameters.
                      </xs:documentation>
                    </xs:annotation>
                  </xs:enumeration>
                </xs:restriction>
              </xs:simpleType>
            </xs:element>
            <xs:element name="roleBeingChecked" default="client">
              <xs:simpleType>
                <xs:restriction base="xs:string">
                  <xs:enumeration value="client"/>
                  <xs:enumeration value="resource_owner">
                    <!-- constraint: ONLY ALLOWED if (flowType == (ResourceOwnerPasswordCredential OR
                                                                   ResourceOwnerSamlAssertionCredential OR
                                                                   authorizationCode OR ImplicitGrant OR RefreshToken
                                                                  )
                                                     )
                    -->
                  </xs:enumeration>
                </xs:restriction>
              </xs:simpleType>
            </xs:element>
            <xs:element name="scopeChecking" minOccurs="0">
              <!-- constraint: ONLY PRESENT if (((flowType == (ResourceOwnerPasswordCredential OR 
                                                               ResourceOwnerSamlAssertionCredential OR 
                                                               ImplicitGrant OR RefreshToken
                                                              )
                                                 ) AND
                                                 (role == resourceOwner)
                                                ) OR
                                                ((flowType = AuthorizationCode) AND 
                                                 (authorizationCodeRequestType = grantRequest) AND
                                                 (role == resourceOwner)
                                                ) OR
                                                ((flowType = ClientCredential) AND 
                                                 (role == client)
                                                )
                                               )
              -->
              <xs:complexType>
                <xs:sequence>
                  <xs:element name="scopeRequired" type="xs:boolean" default="true">
                    <xs:annotation>
                      <xs:documentation>
                        Indicates that the optional scope parameter is populated in the incoming request: ClientCredential,
                        ResourceOwnerPasswordCredential, ResourceOwnerSamlAssertionCredential, ImplicitGrant, RefreshToken and
                        the AuthorizatioCode grant request.
                      </xs:documentation>
                    </xs:annotation>
                    <!-- constraint: 1) WARNING "Having no scope implies that the existing interface can not be modified to 
                                                 add additional scopes/resource management"
                                        if ((flowType == (ClientCredential OR ResourceOwnerPasswordCredential OR
                                                          ResourceOwnerSamlAssertionCredential OR ImplicitGrant OR RefreshToken
                                                         )
                                            ) AND 
                                            (scopeRequired == FALSE) AND
                                            (OauthVersion = OAuth2-draft-22 OR OAuth2-draft-21 OR OAuth2-draft-20)
                                           )
                                     2) WARNING "Having no scope implies that default application scope being assumed"
                                        if ((flowType == (ClientCredential OR ResourceOwnerPasswordCredential OR
                                                          ResourceOwnerSamlAssertionCredential OR ImplicitGrant OR RefreshToken
                                                         )
                                            ) AND 
                                            (scopeRequired == FALSE) AND
                                            (OauthVersion = OAuth2-draft-23)
                                           )
                                     3) MUST be false if ((flowType == AuthorizationCode) AND 
                                                          (authorizationCodeRequestType == accessTokenRequest)
                                                         )
                                        Note: we will not show on screen.
                    -->
                  </xs:element>
                  <xs:element name="subsetOfRefreshToken" type="xs:boolean" default="true" minOccurs="0">
                    <xs:annotation>
                      <xs:documentation>
                        The incoming request for an access token contains a scope that must be contained within the approved scope
                        within the supplied refresh token.
                      </xs:documentation>
                    </xs:annotation>
                    <!-- constraint: ONLY PRESENT if ((flowType == RefreshToken) AND (scopeRequired == true)) -->
                  </xs:element>
                  <xs:element name="acceptableScopes" type="aaa:SamlString" minOccurs="0" maxOccurs="unbounded">
                    <xs:annotation>
                      <xs:documentation>
                        Identifies one or more exceptable scopes. 
                        
                        I would expect that this option will only be used for Resource Owner, Client Credential, refresh token and 
                        implicit grant types of flows, and not an authorization code flow. This is because these types of 
                        flows do not have the authorization server interacting with the user (resource owner) to get their 
                        approval, i.e., have to decide if the request will be accepted. The authorization code flow would
                        display this information to the resource owner (user) as part of their interactions/exchanges.
                      </xs:documentation>
                    </xs:annotation>
                    <!-- constraint: 1) NOT PRESENT if ((subsetOfRefreshToken == true) OR
                                                        ((flowType == AuthorizationCode) AND 
                                                         (authorizationCodeRequestType == accessTokenRequest)
                                                        )
                                                       )
                                     2) ERROR "Requiring scope to be supplied but not checking that it is valid"
                                        if ((scopeRequired == TRUE) AND (no acceptableScopes entries populated) AND (OAuth version >= 23))
                                     3) WARNING "Requiring scope to be supplied but not checking that it is valid"
                                        if ((scopeRequired == TRUE) AND (no acceptableScopes entries populated) AND (OAuth version <= 22))
                                     4) WARNING "Checking scope has a valid value, but not requiring a scope to be supplied"
                                        if ((acceptableScope populated) AND (scopeRequired == false))
                    -->
                  </xs:element>
                </xs:sequence>
              </xs:complexType>
            </xs:element>
            <xs:choice>
              <xs:sequence>
                <xs:annotation>
                  <xs:documentation>Client specific information</xs:documentation>
                </xs:annotation>
                <!-- constraint: ONLY PRESENT if (roleBeingChecked == client) -->
                <xs:element name="clientCredentialSource" type="aaa:OAuthClientCredentialSourceType" default="HttpBasicAuthorization">
                  <!-- constraint: 1) WARNING "No form of client credentials identified. Legal but not normal unless your 
                                               authorization server supporting public clients"
                                      if (flowType == (AuthorizationCode OR ResourceOwnerPasswordCredentials OR RefreshToken OR
                                                       ResourceOwnerSamlAssertionCredentials OR ClientCredentials
                                                      )
                                         )
                                   2) MUST be POPULATED if (flowType == ImplictGrant)
                  -->
                </xs:element>
                <xs:element name="clientAssertion" type="aaa:VerifyDecryptValidateExtractOAuthSamlAssertion" minOccurs="0">
                  <xs:annotation>
                    <xs:documentation>
                      SAML v2.0 Bearer assertion is use for client or resource owner credentials.
                    </xs:documentation>
                  </xs:annotation>
                  <!-- constraint: MUST be POPULATE if (clientCredentialSource == SamlAssertion) -->
                </xs:element>
                <xs:element name="specialExceptionHandling" type="aaa:AuthenticationExceptionHandling" minOccurs="0">
                  <xs:annotation>
                    <xs:documentation>
                      Indicates that client authentication failed (e.g. unknown client, no client authentication included, or 
                      unsupported authentication method).
                    </xs:documentation>
                  </xs:annotation>
                  <!-- constraint: 1) if (clientCredentialSource == HttpBasicAuthorization)
                                      then typeFailureResponse is FIXED to 401-Unauthorized 
                                   2) if (clientCredentialSource == (RequestBody OR SamlAssertion OR clientIdFromOAuthRequest))
                                      then typeFailureResponse is FIXED to 400-Bad Request 
                                   3) NOT PRESENT if (OAuthClientCredentialSourceType == no-credentials)
                  -->
                </xs:element>
              </xs:sequence>
              <xs:sequence>
                <xs:annotation>
                  <xs:documentation>Resource Owner specific information</xs:documentation>
                </xs:annotation>
                <!-- constraint: ONLY ALLOWED if roleBeingChecked == resource_owner) -->
                <xs:element name="resourceOwnerSource" default="name_only_from_workflow" minOccurs="0">
                  <xs:annotation>
                    <xs:documentation>
                      This element will make it explicit to the developer what form of resource owner credential will be utilized.
                      Not only is its presence controlled by the flowType, authorizationCodeRequestType and roleBeingChecked 
                      values selected but what values it can assume.
                    </xs:documentation>
                  </xs:annotation>
                  <!-- constraint: ONLY PRESENT if (((flowType == authorizationCode) AND 
                                                     (authorizationCodeRequestType == grantRequest)
                                                    ) OR
                                                    (flowType == (ResourceOwnerPasswordCredential OR
                                                                  ResourceOwnerSamlAssertionCredential
                                                                 )
                                                    )
                                                   )
                  -->
                  <xs:simpleType>
                    <xs:restriction base="xs:string">
                      <xs:enumeration value="name_only_from_workflow">
                        <!-- constraint: 1) Service Designer action builder must prompt for name when policy bound to an action.
                                         2) MUST be SELECTED/FIXED if (flowType == (AuthorizationCode OR ImplicitGrant))
                        -->
                      </xs:enumeration>
                      <xs:enumeration value="HTTP_request_body_username_password_parameters">
                        <xs:annotation>
                          <xs:documentation>
                            Given the following example Resource Owner Password Credential request:
                              POST /token HTTP/1.1
                              Host: server.example.com
                              Authorization: Basic czZCaGRSa3F0MzpnWDFmQmF0M2JW
                              Content-Type: application/x-www-form-urlencoded;charset=UTF-8
                              grant_type=password&amp;username=johndoe&amp;password=A3ddj3w
                            where
                              username: the resource owner username, encoded as UTF-8.
                              password: the resource owner password, encoded as UTF-8.
                          </xs:documentation>
                        </xs:annotation>
                        <!-- constraint: MUST be SELECTED/FIXED if (flowType == ResourceOwnerPasswordCredential) -->
                      </xs:enumeration>
                      <xs:enumeration value="SAML_assertion_from_HTTP_request_body_parameters">
                        <xs:annotation>
                          <xs:documentation>
                            Given the following example Resource Owner Password Credential request:
                              POST /token HTTP/1.1
                              Host: server.example.com
                              Authorization: Basic czZCaGRSa3F0MzpnWDFmQmF0M2JW
                              Content-Type: application/x-www-form-urlencoded;charset=UTF-8
                              grant_type=urn:ietf:params:oauth:grant-type:saml2-bearer&amp;assertion=xsdsweor583msdshcwplmd
                            where
                              assertion: base64url encoded SAML Assertion.
                          </xs:documentation>
                        </xs:annotation>
                        <!-- constraint: MUST be SELECTED/FIXED if (flowType == ResourceOwnerSamlAssertionCredential) -->
                      </xs:enumeration>
                      <!-- deferred to future enhancement if we ever want to modified workflow generation to merge AAA policies
                      <xs:enumeration value="name_password_from_workflow">
                        <xs:annotation>
                          <xs:appinfo>
                            constraint: Service Designer action builder must prompt for name and password when policy 
                                        bound to an action.
                          </xs:appinfo>
                        </xs:annotation>
                      </xs:enumeration>
                      <xs:enumeration value="sso_token"/>
                      <xs:enumeration value="cookie">
                        <xs:annotation>
                          <xs:appinfo>
                            constraint: Service Designer action builder must prompt for cookie when policy
                                        bound to an action.
                          </xs:appinfo>
                        </xs:annotation>
                      </xs:enumeration>
                      -->
                    </xs:restriction>
                  </xs:simpleType>
                </xs:element>
                <xs:element name="resourceOwnerAssertion" type="aaa:VerifyDecryptValidateExtractOAuthSamlAssertion" minOccurs="0">
                  <xs:annotation>
                    <xs:documentation>
                      SAML v2.0 Bearer assertion is use for client or resource owner credentials.
                    </xs:documentation>
                  </xs:annotation>
                  <!-- constraint: MUST be POPULATE if ((flowType = ResourceOwnerSamlAssertionCredential) AND
                                                        (authorizationCodeRequestType == accessTokenRequest) AND
                                                        (roleBeingChecked == resource_owner)
                                                       )
                  -->
                </xs:element>
                <!-- deferred to future enhancement if we ever want to modified workflow generation to merge AAA policies
                <xs:element name="cookieName" type="aaa:CookieNameType" minOccurs="0">
                  <xs:annotation>
                    <xs:appinfo>constraint: ONLY AllOWED if (resourceOwnerSource == cookie)</xs:appinfo>
                  </xs:annotation>
                </xs:element>
                 -->
              </xs:sequence>
              <xs:element name="grant" type="aaa:GrantReceiveInfoType" minOccurs="0">
                <!-- constraint: MUST be populated if ((flowType == AuthorizationCode) AND 
                                                       (authorizationCodeRequestType == accessTokenRequest) AND
                                                       (roleBeingChecked == resource_owner)
                                                      )
                -->
              </xs:element>
              <xs:element name="refreshToken" minOccurs="0">
                <!-- constraint: MUST be populated if ((flowType == RefreshToken) AND 
                                                       (authorizationCodeRequestType == accessTokenRequest) AND
                                                       (roleBeingChecked == resource_owner)
                                                      )
                -->
                <xs:complexType>
                  <xs:complexContent>
                    <xs:extension base="aaa:GrantReceiveInfoType">
                      <xs:sequence>
                        <xs:element name="checkUniqueness" type="xs:boolean" default="false">
                          <xs:annotation>
                            <xs:documentation>
                              Only allow this refresh token to be used once to generate an access token.
                            </xs:documentation>
                          </xs:annotation>
                        </xs:element>
                        <xs:element name="checkForRefreshTokenRevocation" type="aaa:InvokedService" minOccurs="0">
                          <xs:annotation>
                            <xs:documentation>
                              Identifies application workflow that will check to see if this refresh token has been revoked.
                            </xs:documentation>
                          </xs:annotation>
                        </xs:element>
                      </xs:sequence>
                    </xs:extension>
                  </xs:complexContent>
                </xs:complexType>
              </xs:element>
            </xs:choice>
          </xs:sequence>
        </xs:complexType>
      </xs:element>
      <xs:element name="tokenFromHttpOauthAuthorization" type="aaa:HttpOauthAuthorizationInfo">
        <xs:annotation>
          <xs:documentation>
            Extract token identifying resource owner or client from HTTP Authorization header field, 
            e.g.,   Authorization: Oauth czZCaGRSa3F0MzpnWDFmQmF0M2JW
          </xs:documentation>
        </xs:annotation>
      </xs:element>
    </xs:choice>
  </xs:complexType>
  <xs:complexType name="HttpOauthAuthorizationInfo">
    <xs:sequence>
      <xs:element name="tokenType" type="aaa:HttpAuthorizationCredentialType" default="Bearer">
        <xs:annotation>
          <xs:documentation>Identifies the HTTP Authorization credential request header type to look for.</xs:documentation>
        </xs:annotation>
      </xs:element>
      <xs:choice>
        <xs:element name="jsonTokenInfo" type="aaa:JsonWebTokenReceiveType"/>
        <xs:element name="samlBearerAssertion" type="aaa:VerifyDecryptValidateExtractOAuthSamlAssertion">
          <xs:annotation>
            <xs:appinfo>
              Primary reason for having this option and not restrict us to using Bearer option from nameFromSamlSubject is
              that knowing that we have an OAuth access token implies additional restrictions about what SAML entities should
              be populated with special restrictions applied but also the potential usage of the resource authorization mechanism
              that checks that requested resource is covered by access token scope.
              When these special restriction do not apply 
            </xs:appinfo>
          </xs:annotation>
        </xs:element>
      </xs:choice>
      <xs:element name="specialExceptionHandling" type="aaa:AuthenticationExceptionHandling">
        <xs:annotation>
          <xs:documentation>
            Contains special exception handling details that are to be populated in the exception being thrown because
            the input document does not contain HTTP Basic Authentication credentials.
            Operational code will generate error string containing detailed information to be package within response 
            to client.
            The ultimate HTTP response will include HTTP status, expected token type and realm. The response message
            will be of the folowing form:
            ["401 Unauthorized WWW-Authenticate: " | "407 Proxy Authentication Required Proxy-Authetnication: "]  
            "Basic realm="" &lt;realm&gt; """
          </xs:documentation>
        </xs:annotation>
        <!-- constraint: ONLY ALLOWED values for typeFailureResponse = (401-Unauthorized OR 407-Proxy Authentication Request) -->
      </xs:element>
      <xs:element name="checkForAccessTokenRevocation" type="aaa:InvokedService" minOccurs="0">
        <xs:annotation>
          <xs:documentation>Identifies application workflow to check if this access token has been revoked.</xs:documentation>
        </xs:annotation>
      </xs:element>
    </xs:sequence>
  </xs:complexType>
  <xs:complexType name="UsernameTokenEmptyType">
    <xs:complexContent>
      <xs:extension base="aaa:EmptyType">
        <xs:attribute name="actor" type="aaa:ActorType" use="optional"/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:complexType name="VerifyDecryptValidateExtractSamlAssertion">
    <xs:complexContent>
      <xs:extension base="aaa:VerifyDecryptInitialValidateSamlAssertion">
        <xs:sequence>
          <xs:element name="extractMostSpecificPartOfName" type="aaa:ExtractMostSpecificPartOfNameType" default="false" minOccurs="0"/>
          <xs:element name="inputBindingInfo" type="aaa:InputBindingInfo" minOccurs="0">
            <xs:annotation>
              <xs:documentation>
                Contains information about where to find the SAML assertion to be processed, and
                any special information about any special decoding/processing that will be required.
              </xs:documentation>
              <xs:appinfo>
                If no inputBindingInfo is present then the SAML Assertion is assumpted to come from the WS-Security
                header within the SOAP header.
              </xs:appinfo>
            </xs:annotation>
          </xs:element>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:complexType name="VerifyDecryptValidateExtractOAuthSamlAssertion">
    <xs:complexContent>
      <xs:extension base="aaa:VerifyDecryptInitialValidateSamlAssertion">
        <xs:sequence>
          <xs:element name="extractMostSpecificPartOfName" type="aaa:ExtractMostSpecificPartOfNameType" default="false" minOccurs="0"/>
          <xs:element name="contentLocations" minOccurs="0">
            <xs:annotation>
              <xs:documentation>
                Identifies where in the SAML Assertion critical information has been saved.
                In particular, the Attribute name/value pair.
              </xs:documentation>
              <xs:appinfo>
                Other fields like audience (Conditions AudienceRestriction Audience) and resource owner (Subject) have 
                known existing elements assigned.
              </xs:appinfo>
            </xs:annotation>
            <xs:complexType>
              <xs:sequence>
                <xs:element name="scopeLocation" type="xs:string" default="scope">
                  <xs:annotation>
                    <xs:documentation>Identifies the Attribute element that contains access token scope</xs:documentation>
                  </xs:annotation>
                </xs:element>
                <xs:element name="clientLocation" type="xs:string" default="client_id">
                  <xs:annotation>
                    <xs:documentation>Identifies the Attribute element that contains access token client identifier</xs:documentation>
                  </xs:annotation>
                </xs:element>
              </xs:sequence>
            </xs:complexType>
          </xs:element>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:simpleType name="ExtractMostSpecificPartOfNameType">
    <xs:annotation>
      <xs:documentation>
        Instructs us to extract the most specific part of the name and to use it as the extracted identity.
        For example, 
        1) if name identifier format type is X509 subject name, then the value of CN= or uid=.
        2) if name identifier format type is email-address then component before "@", e.g., xxx@domain
        3) if name identifier format type is Windows Domain Qualified Name then component after "/", e.g., domain/user
      </xs:documentation>
      <!--  constraint: only ALLOWED if required name identifier format is either:
                        1) urn:oasis:names:tc:SAML:1.1:nameid-format:X509SubjectName
                        2) urn:oasis:names:tc:SAML:1.1:nameid-format:emailAddress
                        3) urn:oasis:names:tc:SAML:1.1:nameid-format:WindowsDomainQualifiedName
      -->
    </xs:annotation>
    <xs:restriction base="xs:boolean"/>
  </xs:simpleType>
  <xs:complexType name="VerifyDecryptInitialValidateSamlAssertion">
    <xs:annotation>
      <xs:documentation>
        Contains information needed to:
        1) Identify SAML assertion to be processed. Note: SAML assertion can be emedded within another SAML element.
          When a SAML assertion does not contain a ds:Signature element, but is contained in an enclosing SAML element
          that contains a ds:Signature element, that signature applies to the assertion element and all of its children.
          The assertion is considered as inherenting the signature from the enclosing element. My intepretion is that we should
          check the signature from the enclosing assertion when we validate the inner assertion. Will deal with this in a future
          release! For this release, we will only support signature verification for signatures in the assertion we are extracting.
        2) perform optional signature verification. This step is required because it does not make any sense to trust anything
          from the incoming message without at least verifying the content has not been modified or illegally generated.
          SAML Signatures have the following restrictions of signature processing:
          a) Must use enveloped signature.
          b) Must use rsa-sha1 signature method.
          c) Must have a single reference to the ID attribute of the root element.
          d) Must use exclusive canonicalization with ot without comments.
          e) KeyInfo MAY be absent, i.e., statically configurated in orginator and receiver.
        3) perform optional decryption of all encrypted SAML entities. This step is here because the name could be encrypted into
          an EncryptID, If we are going to decrypt them, we might as well decrypt everything in the incoming SAML assertion
          in a form that we can example and check anything present.
        4) perform optional minimial checking of selected common SAML entities that they contain equired values.
          Note: this full checking is normally done as part of resource authorization. However, since we do not have
          any resource authorization being performed in this release, we will support some limited amount as a side-effect
          of identity extraction.
        
        When both signature and encrpytion is performed upon the same SAML assertion, the encryption MUST be performed first
        by the originator and then a signature calculated over the assertion containing the encrypted elements. Therefore, signature
        verification is performed first then decryption when we are validating/extracting information form the SAML assertion.
      </xs:documentation>
    </xs:annotation>
    <xs:sequence>
      <!-- Not needed at this time because we will automatically match the only SAML assertion in incoming message content
        <xs:element name="samlAssertionToBeProcessed" type="aaa:SimpleFullXPath">
          <xs:annotation>
            <xs:documentation>Identify SAML assertion to be processed.</xs:documentation>
          </xs:annotation>
        </xs:element>
      -->
      <xs:element name="signatureInfo" minOccurs="0">
        <xs:complexType>
          <xs:sequence>
            <xs:element name="signatureAcceptMethods" type="aaa:SignatureAcceptMethod">
              <xs:annotation>
                <xs:documentation>
                  What signature method will be use when accepting a SAML assertion signature.
                  Note: The standard only support rsa-sha1 at this time, ie.e., that is why it uses fixed.
                  We have added additional methods because Microsoft ADFS.
                </xs:documentation>
              </xs:annotation>
            </xs:element>
            <xs:element name="digestAcceptMethod" type="aaa:DigestAcceptMethods">
              <xs:annotation>
                <xs:documentation>What digest method will we use when accepting a SAML assertion signature</xs:documentation>
              </xs:annotation>
            </xs:element>
            <xs:element name="canonicalAcceptMethod" type="aaa:CanonicalAcceptMethods">
              <xs:annotation>
                <xs:documentation>What canonicalization method will we use when generating a SAML assertion signature</xs:documentation>
              </xs:annotation>
            </xs:element>
            <xs:element name="keyInfoAcceptType" type="aaa:AcceptableSamlKeyInfo" default="Certificate" minOccurs="0">
              <xs:annotation>
                <xs:documentation>
                Identifies what form on KeyInfo must be present in the incoming SAML assertion embedded signature.
              </xs:documentation>
              </xs:annotation>
            </xs:element>
            <xs:element name="authenticationPolicy" type="aaa:WebServiceAuthenticationPolicy"/>
            <xs:element name="certificate" type="aaa:VerifyCertSecurityToken" minOccurs="0">
              <xs:annotation>
                <xs:documentation>
                  This should only be populated if the SAML assertion does not contain the X.509 certificates, but instead some derived KeyInfo
                  such as subject name or SKI which would require us to have some way to resolute the KeyInfo to the associated certificate.
                </xs:documentation>
              </xs:annotation>
              <!-- constraint: 1) MUST be (security-config-package OR inputFromWorkflow) if (keyInfoAcceptType == RsaKeyValue)
                               2) MUST be (security-config-package OR inputFromWorkflow OR keystore) 
                                  if (keyInfoAcceptType == (SubjectName OR SKI OR ThumbprintSha1 OR KeyName))
                               3) MAY NOT be POPULATED or be (security-config-package OR inputFromWorkflow OR keystore) 
                                  if (keyInfoAcceptType == Certificate)
                                  Note: not being populated indicates that certificate package within incoming SAML assertion KeyInfo
                                        is being used.
                               4) ERROR "Value of Accepted KeyInfo type and keystore source type MUST be the same"
                                  if ((certificate->keystore selected) AND (keyInfoAcceptType != certificate->keystore->sourceType))
              -->
            </xs:element>
            <xs:element name="caPath" type="aaa:VerifyCaPathSecurityToken" minOccurs="0">
              <xs:annotation>
                <xs:documentation>
                  Name of a caPath element. 
                  This element identifies a list of untrusted Certificate Authorities.
                    
                  In signature verification, the caPath is utilized in checkTrust to supply missing immediate Certificate Authorities certificates
                  between the far-end certificate and a CA certificate within the trustedCaGroup of CA certificates.
                </xs:documentation>
                <xs:appinfo>
                  At this time, SAML assertion verification will ONLY support the CA Path being supplied from the associated security config, not the workflow.
                </xs:appinfo>
              </xs:annotation>
            </xs:element>
          </xs:sequence>
        </xs:complexType>
        <!-- constraint: MUST be populated if (being used within nameFromOAuthAuthorizationRequest as resource owner or client credential) -->
      </xs:element>
      <xs:element name="encryptionInfo" minOccurs="0">
        <xs:annotation>
          <xs:documentation>
            All required information necessary to decrypt any SAML encryption contained in the incoming SAML assertion.
            Encryption is only supported in SAML 2.0 version.
            All SAML encrypted entities: EncryptedID, EncryptedAssertion and EncryptedAttribute, consist of an EncryptedData 
            element and an optional EncryptedKey element.
            When an EncryptedKey element is used, the KeyInfo element within EncryptedData SHOULD reference the
            EncryptedKey element using a RetrievalMethod element of Type http://www.w3.org/2001/04/xmlenc#EncryptedKey.
            When the encrypted element is being "multicast" to multiple recipients, and the key used to encrypt the message must
            be in turn encrypted individually and independently for each of the multiple recipients, the CarriedKeyName element 
            SHOULD be used to assign a common name to each of the EncryptedKey elements so that a KeyName can be
            used from within the EncryptedData elements KeyInfo element.
            
            SAML 2.0 standard allows a SAML assertion generator to encrypt the following types of SAML assertion entities:
            1) Name Identifiers: NameID and BaseID with EncryptedID element. These elements may exist within a SAML assertion
              at multiple places: Subject and SubjectConfirmation elements.
              Note: an entire assertion can be encrypted into this element, EncryptedID, by using the identifier of the subject from
              the enclosing assertion. (Will not support in initial release.)
            2) Assertion information: AssertionIDRef, AssertionURIRef or Assertion within Advice or Evidence elements with an 
              EncryptedAssertion element.
            3) Attribute elements: Attribute and AttributeValue elements within Attribute statements with EncryptedAttribte element.
          </xs:documentation>
        </xs:annotation>
        <!-- constraint: 1) ONLY PRESENT if (SAML version == v2.0)
                         2) a) ONLY PRESENT if ((extracted identity == nameFromSamlSubject) OR (authorization Resource mechanism == samlAttributeQuery))
                            b) NOT PRESENT if (extracted identity == (nameFromSamlAttribute OR nameFromSamlAuthentication))
        -->
        <xs:complexType>
          <xs:sequence>
            <xs:element name="decryptkeyInfo" type="aaa:DecryptSamlKeyInfoType"/>
            <xs:element name="acceptableDataEncryptionMethods">
              <xs:complexType>
                <xs:attribute name="aes128" type="xs:boolean" use="optional" default="true"/>
                <xs:attribute name="aes192" type="xs:boolean" use="optional" default="true"/>
                <xs:attribute name="aes256" type="xs:boolean" use="optional" default="true"/>
                <xs:attribute name="aes128Gcm" type="xs:boolean" use="optional" default="true"/>
                <xs:attribute name="aes192Gcm" type="xs:boolean" use="optional" default="true"/>
                <xs:attribute name="aes256Gcm" type="xs:boolean" use="optional" default="true"/>
                <xs:attribute name="des3" type="xs:boolean" use="optional" default="true"/>
                <xs:attribute name="arc4" type="xs:boolean" use="optional" default="false"/>
              </xs:complexType>
            </xs:element>
            <xs:element name="recipient" minOccurs="0">
              <xs:annotation>
                <xs:documentation>
                  Identifies which encryptedData elements we need to decrypt.
                  This is only utilized when the SAML assertion has NameID, Attibutes and Assertion elements encrypted for
                  multiple destination recipients.
                </xs:documentation>
              </xs:annotation>
              <xs:simpleType>
                <xs:restriction base="xs:anyURI">
                  <xs:minLength value="1"/>
                </xs:restriction>
              </xs:simpleType>
            </xs:element>
          </xs:sequence>
        </xs:complexType>
      </xs:element>
      <xs:element name="requiredSamlEntitiesAndValues" minOccurs="0">
        <xs:annotation>
          <xs:documentation>
            Identifies SAML entities and there associated values that must be present for this SAML assertion to be considered valid.
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:sequence>
            <xs:element name="Issuer" type="xs:anyURI" minOccurs="0">
              <!-- constraint: MUST be POPULATED if ((extract identity == nameFromOAuthAuthorizationRequest) AND
                                                     (clientCredentialSource == SamlAssertion)
                                                    )
              -->
            </xs:element>
            <xs:element name="SubjectNameIdentifierFormat" type="aaa:NameIdFormatType" minOccurs="0"/>
            <xs:element name="SubjectNameIdentifier" type="xs:anyURI" minOccurs="0"/>
            <xs:element name="SubjectConfirmationMethod" type="aaa:ConfirmationMethodType" minOccurs="0">
              <!-- constraint: While we should expect that the SAML version should restrict the actual value, it is possible for a user to
                               selects a value from a different SAML version. At most, we should generate a warning message when a developer
                               use value from a different release. 
              -->
            </xs:element>
            <xs:sequence minOccurs="0">
              <xs:element name="expectedHolderOfKeyKeyInfo" type="aaa:HolderOfKeyKeyInfoType">
                <xs:annotation>
                  <xs:documentation>
                  Identifies what form of KeyInfo element must be present in extracted SAML assertion.
                  A KeyInfo element must be present when hold-of-key confirmation method type has been specified.
                </xs:documentation>
                  <xs:appinfo>
                    When AAA policy with this element is bound to an action, action builder must prompt for the associated client credential.
                    This client credential can come from one of the following sources:
                    1) if (extectedHolderOfKeyKeyInfo is X509Certificate, X509SKI, X509SubjectName, X509IssuerSerialNumber, RSAKeyValue, DSAKeyValue or KeyName)
                       then peer X509 certificate from HTTP IS metadata ALLOWED.
                    2) Exported resolved security token from a preceding successfully processed WS-Security signature verification operation ALLOWED 
                       a) If the operation was X509 token type, the exported data cache variable will be a base64 encoded DER certificate. 
                       b) If the operation was username token type, the exported data cache variable will be the resolved username. (deferred to future release)
                       c) If the operation was symmetric token type, the exported data cache variable will be the keyname. (deferred to future release)
                    3) Extracted identity from a preceding successfuly processed AAA action ALLOWED (deferred to future release)
                       If ((extectedHolderOfKeyKeyInfo is KeyName) AND 
                           (extract identity mechanism of the preceding AAA action is 
                            (usernameFromHttpBasicAuthentication OR usernameFromSecurityHeader OR derivedUsernameFromSecurityheader OR usernamePasswordFromWorkflow)
                           )
                          )
                  </xs:appinfo>
                </xs:annotation>
              </xs:element>
              <xs:element name="clientCredentialSource" minOccurs="0">
                <xs:annotation>
                  <xs:documentation>Identifies source of client credential to be used in holder-of-key checking</xs:documentation>
                </xs:annotation>
                <xs:simpleType>
                  <xs:restriction base="xs:string">
                    <xs:enumeration value="bstFromVerifyOperation">
                      <xs:annotation>
                        <xs:documentation>X.509 certificate resolved by preceding WS-Security Verify operation.</xs:documentation>
                      </xs:annotation>
                    </xs:enumeration>
                    <xs:enumeration value="peerCertificateFromSsl">
                      <xs:annotation>
                        <xs:documentation>Peer certificate HTTP IS SSL/TLS session.</xs:documentation>
                        <xs:appinfo>Certificate extracted directly for incoming request metadata.</xs:appinfo>
                      </xs:annotation>
                      <!-- constraint: MUST BE SPECIFIED if inputBindingInfo importSource == from-ESG-HTTP-Authorization-saml2-hok-ssl) -->
                    </xs:enumeration>
                    <!-- deferred
                    <xs:enumeration value="usernameFromWorkflow">
                      <xs:annotation>
                        <xs:documentation>Authenticated username from workflow.</xs:documentation>
                        <xs:appinfo>Partial kludge because of difficulty getting authenticated username from preceding AAA action.</xs:appinfo>
                      </xs:annotation>
                    </xs:enumeration>
                    <xs:enumeration value="symmetricKeyFromVerifyOperation">
                      <xs:annotation>
                        <xs:documentation>Username or Symmetric keyname resolved by preceding WS-Security Signature operation.</xs:documentation>
                      </xs:annotation>
                    </xs:enumeration>
                    -->
                  </xs:restriction>
                </xs:simpleType>
              </xs:element>
              <!-- constraint: 1) MUST be populated if (expectedHolderOfKeyKeyInfo != BinarySecret). 
                               2) MUST NOT be present if (expectedHolderOfKeyKeyInfo == BinarySecret).
              -->
            </xs:sequence>
            <xs:element name="NotBeforeAndNotOnOrAfter" default="none" minOccurs="0">
              <xs:annotation>
                <xs:documentation>
                  The NotBefore and NotOnOrAfter timestamps will be checked against the current time of the receiving system.
                  The NotBefore and NotOnOrAfter atributes can be package several places within a SAML Assertion:
                  1) within the saml:Conditions element
                  2) within the saml:Subject saml:SubjectConfirmation saml:SubjectConfirmationData element for SAML v2.0. 
                     Note: for SAML V1.x the situation is more confusing because:
                           a) The SignatureConfirmationData element can show up under a SubjectStatement, AuthenticationStatement,
                              AuthorizationDecisionStatement or AttributeStatement
                           b) It is not explicitly defined. These attributes are allowed through use of the any extension mechanism.
                </xs:documentation>
                <!-- constraint: 
                        1) non-none value MUST be selected if ((extract identity == nameFromOAuthAuthorizationRequest) AND
                                                               (clientCredentialSource == SamlAssertion)
                                                              )
                -->
              </xs:annotation>
              <xs:simpleType>
                <xs:restriction base="xs:string">
                  <xs:enumeration value="none">
                    <xs:annotation>
                      <xs:documentation>No lifetime change for this SAML assertion is to be performed.</xs:documentation>
                    </xs:annotation>
                  </xs:enumeration>
                  <xs:enumeration value="onlyCheckConditionsElement">
                    <xs:annotation>
                      <xs:documentation>Only check the NotBefore or NotOnOrAfter attributes within the Conditions element.</xs:documentation>
                    </xs:annotation>
                  </xs:enumeration>
                  <xs:enumeration value="onlyCheckSubjectConfirmationDataElements">
                    <xs:annotation>
                      <xs:documentation>
                        Only check the NotBefore or NotOnOrAfter attributes within SubjectConfirmationData elements.
                      </xs:documentation>
                      <xs:appinfo>
                        There may be multiple SubjectConfirmationData elements defined with the SAML Assertion.
                        We will need to check that all of them have valid lifetimes if these attributes are present.
                        However, at LEAST ONE SignatureConfirmationData elements MUST have these attributes defined.
                      </xs:appinfo>
                    </xs:annotation>
                  </xs:enumeration>
                  <xs:enumeration value="checkBothConditionsAndSubjectConfirmationDataElements">
                    <xs:annotation>
                      <xs:documentation>
                        Check both Conditions and SubjectConfirmationData elements for NotBefore or NotOnOrAfter attributes.
                      </xs:documentation>
                      <xs:appinfo>
                        At LEAST ONE SignatureConfirmationData or Conditions elements MUST have these attributes defined.
                      </xs:appinfo>
                    </xs:annotation>
                  </xs:enumeration>
                </xs:restriction>
              </xs:simpleType>
            </xs:element>
            <xs:element name="Audience" type="aaa:SamlUri" minOccurs="0">
              <xs:annotation>
                <xs:documentation>
                  A URI reference that identifies an intended audience. For OAuth 2.0, it identifies the token  
                  endpoint URL of the authorization server. 
                  The URI reference MAY identify a document that describes the terms and conditions of audience 
                  membership. It MAY also contain the unique identifier URI from a SAML name identifier that 
                  describes a system entity.
                </xs:documentation>
              </xs:annotation>
              <!-- constraint: MUST be POPULATED if ((extract identity == nameFromOAuthAuthorizationRequest) AND
                                                     (clientCredentialSource == SamlAssertion)
                                                    )
              -->
            </xs:element>
            <xs:element name="Recipient" type="aaa:SamlUri" minOccurs="0">
              <xs:annotation>
                <xs:documentation>
                  A URI specifying the entity or location to which an attesting entity can present the assertion. For
                  example, this attribute might indicate that the assertion must be delivered to a particular network
                  endpoint in order to prevent an intermediary from redirecting it someplace else.
                  For OAuth 2.0, the Recipient attribute with a value indicating the token endpoint URL of the
                  authorization server.
                </xs:documentation>
              </xs:annotation>
              <!-- constraint: MUST be POPULATED if ((extract identity == nameFromOAuthAuthorizationRequest) AND
                                                     (clientCredentialSource == SamlAssertion)
                                                    )
              -->
            </xs:element>
            <xs:group ref="aaa:UniquenessCheckingType" minOccurs="0"/>
            <xs:element name="QueryResponse" type="aaa:QueryResponseTypeForExtraction" minOccurs="0">
              <!-- constraint: ONLY PRESENT if (importSource == (from-ESG-HTTP-Authorization-saml2-bearer OR from-ESG-HTTP-Authorization-saml2-hok-ssl)) -->
            </xs:element>
          </xs:sequence>
        </xs:complexType>
      </xs:element>
    </xs:sequence>
  </xs:complexType>
  <xs:group name="UniquenessCheckingType">
    <xs:sequence>
      <xs:element name="checkUniqueness" type="xs:boolean" default="false">
        <xs:annotation>
          <xs:documentation>
            Indicates if the uniqueness of this token is required.
            If enabled then the token identifier is check for uniqueness.
            The unique identifier is maintained in an internal cache for the lifetime of the token.
          </xs:documentation>
        </xs:annotation>
      </xs:element>
      <xs:element name="uniquenessCacheImplementation" type="aaa:UniquenessCacheImplementationType" default="single_host_non_persistent" minOccurs="0">
        <xs:annotation>
          <xs:documentation>Uniqueness Cache Implementation Options</xs:documentation>
        </xs:annotation>
        <!-- constraint: Only present when (checkUniqueness == true) -->
      </xs:element>
    </xs:sequence>
  </xs:group>
  <xs:simpleType name="UniquenessCacheImplementationType">
    <xs:restriction base="xs:string">
      <xs:enumeration value="single_host_non_persistent">
        <xs:annotation>
          <xs:documentation>
            Single host incore uniqueness cache.
            Uniqueness cache restricted to a single member of the cluster.
            Additionally, uniqueness cache is not persistent across reboot and process restart.
          </xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <!-- deferred
      <xs:enumeration value="cluster_non_persistent">
        <xs:annotation>
          <xs:documentation>
            Uniqueness cache ensures uniqueness across all members of the cluster.
            However, various failure modes may cause the nonce cache to be lost.
            For example, host processor supporting the uniqueness cache being rebooted.
          </xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="cluster_persistent">
        <xs:annotation>
          <xs:documentation>
            Uniqueness cache ensures uniqueness across all members of the cluster.
            Additionally, uniqueness cache status should not be lost due to any simple single failure condition, 
            e.g., process reboot, disk failure.
          </xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      -->
    </xs:restriction>
  </xs:simpleType>
  <xs:complexType name="DecryptSamlKeyInfoType">
    <xs:choice>
      <xs:element name="symmetric">
        <xs:complexType>
          <xs:all>
            <xs:element name="outOfBandSymmetricKey" type="aaa:SymmetricSecurityToken">
              <xs:annotation>
                <xs:documentation>Out-of-band symmetric secret that has been used to encrypt one or more SAML entities</xs:documentation>
              </xs:annotation>
            </xs:element>
          </xs:all>
        </xs:complexType>
      </xs:element>
      <xs:element name="x509">
        <xs:complexType>
          <xs:sequence>
            <xs:element name="acceptableKeyTransportMethods">
              <xs:complexType>
                <xs:attribute name="rsaOaep" type="xs:boolean" use="optional" default="true"/>
                <xs:attribute name="rsa-v1.5" type="xs:boolean" use="optional" default="true"/>
              </xs:complexType>
            </xs:element>
            <xs:element name="keyPair">
              <xs:complexType>
                <xs:choice>
                  <xs:element name="securityConfig" type="aaa:SecurityPackageHandle"/>
                </xs:choice>
              </xs:complexType>
            </xs:element>
          </xs:sequence>
        </xs:complexType>
      </xs:element>
    </xs:choice>
  </xs:complexType>
  <xs:complexType name="WsCertificateAttributeWithSubExtraction">
    <xs:complexContent>
      <xs:extension base="aaa:CertificateAttributeWithSubExtraction">
        <xs:attribute name="actor" type="aaa:ActorType" use="optional"/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:complexType name="CertificateAttributeWithSubExtraction">
    <xs:simpleContent>
      <xs:extension base="aaa:CertificateAttribute">
        <xs:attribute name="extractMostSpecificComponentFromSubjectName" type="xs:boolean" use="optional" default="true">
          <xs:annotation>
            <xs:documentation>
              Instructs us to extract the most specific component from the subject name. This is normally the common name 
              (CN=) or username (uid=) component of the subject name distriguished name (DN). It contain the most specific/
              personal information.
              For example, "charlie" in "uid=charlie,ou=People,dc=entegrity,dc=com", or
                           "Agent Smith" in "CN=Agent Smith, O=Matrix,C=NL" or
                           "GridShib" in "CN=GridShib,OU=NCSA,O=UIUC"
            </xs:documentation>
          </xs:annotation>
          <!-- constraint: only allowed when CertificateAttribute == subjectName -->
        </xs:attribute>
      </xs:extension>
    </xs:simpleContent>
    <!-- constraint: if ((CertificateAtributeWithSubExtraction is being used from 
                          (certificateFromPeerSsl | x509CertificateFromSecurityHeader | X509CertificateFromWrkflow |
                           bstFromVerifyOperation) &&
                         (subextraction type is (SubjectName | SKI | Sha1Fingerprint | Md5Fingerprint | generatedSKI |
                                                 generatedShortSKI | issueSerialNumber)) && 
                         (NO authentication mechanism is selected) && 
                         (NO authorization mechanism is selected)
                        ) then generate a WARNING message indicating that extraction type should be full certificate for maximum efficiently.
    -->
  </xs:complexType>
  <xs:complexType name="CookieInfo">
    <xs:annotation>
      <xs:appinfo>Have to embed within a complexType and not a simpleType due to EMF issues</xs:appinfo>
    </xs:annotation>
    <xs:sequence>
      <xs:element name="cookieName" type="aaa:CookieNameType"/>
      <xs:element name="eca360CookieVerification" type="aaa:Eca360CookieVerification" minOccurs="0">
        <!-- constraint: 1) MUST be PRESENT AND POPULATED if (extract identity cookie name != "SplashLoginCookie")
                         2) NOT PRESENT if (extract identity cookiename == (SMSESSION OR ObSSOCookie OR custom))
        -->
      </xs:element>
    </xs:sequence>
  </xs:complexType>
  <xs:simpleType name="CookieNameType">
    <xs:annotation>
      <xs:documentation>Name of cookie in HTTP header containing SSO token.</xs:documentation>
      <xs:appinfo>
        We should support in the policy editor the ability to select the well-defined cookie names utilized by SiteMinter, 
        Oracle Access Manager, ECA 360, etc.
        in addition to an completely arbitrary cookie name.
        For SiteMinder: the default cookie name should be: SMSESSION.
        For Oracle Access Manager: the default cookie name should be: ObSSOCookie.
        For ECA 360: the default cookie name should be: SplashLoginCookie.
      </xs:appinfo>
    </xs:annotation>
    <xs:restriction base="xs:string">
      <xs:minLength value="1"/>
    </xs:restriction>
  </xs:simpleType>
  <xs:simpleType name="CertificateAttribute">
    <xs:restriction base="xs:string">
      <xs:enumeration value="subjectName">
        <xs:annotation>
          <xs:documentation>Subject Distriguished Name</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="SKI">
        <xs:annotation>
          <xs:documentation>Subject Key Identifier that was embedded within X.509 certificate by issuing Certificate Authority</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="fullCertificate"/>
      <xs:enumeration value="Sha1Fingerprint"/>
      <xs:enumeration value="Md5Fingerprint"/>
      <xs:enumeration value="generatedSKI"/>
      <xs:enumeration value="generatedShortSKI"/>
      <xs:enumeration value="issueSerialNumber"/>
    </xs:restriction>
  </xs:simpleType>
  <xs:complexType name="InputBindingInfo">
    <xs:annotation>
      <xs:documentation>
        Contains information required to extract the token, i.e., SAML assertion. Different binding mechanisms
        may require different encoding mechanism/procedures.
      </xs:documentation>
      <xs:appinfo>Currently only required for REST bindings.</xs:appinfo>
    </xs:annotation>
    <xs:sequence>
      <xs:element name="importSource" default="from-WS-Security-header">
        <xs:annotation>
          <xs:documentation>This element identifies where the SAML Assertion to be processed is located.</xs:documentation>
          <xs:appinfo>Am defaulting this element so that existing AAA policies will NOT require any retrofit.</xs:appinfo>
        </xs:annotation>
        <xs:simpleType>
          <xs:restriction base="xs:string">
            <xs:enumeration value="from-WS-Security-header">
              <xs:annotation>
                <xs:documentation>SAML assertion is located in WS-Security header within the SOAP header of the input document</xs:documentation>
              </xs:annotation>
            </xs:enumeration>
            <xs:enumeration value="from-HTTP-Authorization-Request-Header">
              <xs:annotation>
                <xs:documentation>
                  SAML v2.0 Bearer Assertion is packaged within HTTP POST or GET request (see OAuth 2.0
                  Authorization Protocol: Bearer Tokens, draft-ietf-oath-v2-bearer and I-D.ietf-httpbis-p7-auth), e.g.,
                  
                    GET /resource HTTP/1.1
                    Host: server.example.com
                    Authorization: Bearer vF9dft4qmT[... not shown for brevity]
                    
                  where the crendentials = "Bearer" 1*sp b64token
                </xs:documentation>
              </xs:annotation>
              <!-- constraint: NOT ALLOWED if (being reference from nameFromSamlAttribute or nameFromSamlAuthentication) 
                               equivalent to NOT ALLOWED if (samlVersion == 1.x)
              -->
            </xs:enumeration>
            <xs:enumeration value="from-form-embedded-access-token">
              <xs:annotation>
                <xs:documentation>
                  Special form of from-workflow where SAML v2.0 Bearer Assertion is packaged within HTTP POST request 
                  entity body (see OAuth 2.0 Authorization Protocol: Bearer Tokens, draft-ietf-oath-v2-bearer),
                  e.g.,
                    POST /resource HTTP/1.1
                    Host: server.example.com
                    Content-Type: application/x-www-form-urlencoded
                    
                    access_token=vF9dft4qmT[... not shown for brevity]
                       
                  where the Content-Type must be application/x-www-form-urlencoded. The entity-body may include other 
                  request specific parameters separated using &amp; characters.
                </xs:documentation>
                <xs:appinfo>Restricted form of from-workflow.</xs:appinfo>
              </xs:annotation>
              <!-- constraint: NOT ALLOWED if (being reference from nameFromSamlAttribute or nameFromSamlAuthentication) 
                               equivalent to NOT ALLOWED if (samlVersion == 1.x)
              -->
              <!-- Constraint: SD action builder should automatic pick-up SAML Assertion from incoming message
                               access_token parameter. SD must throw appropriate error if parameter is no present/populated.
              -->
            </xs:enumeration>
            <xs:enumeration value="from-HTTP-URI-Query-Parameter">
              <xs:annotation>
                <xs:documentation>
                  SAML v2.0 Bearer Assertion is packaged within HTTP GET request URI (see OAuth 2.0
                  Authorization Protocol: Bearer Tokens, draft-ietf-oath-v2-bearer and I-D.ietf-httpbis-p7-auth), e.g.,
                  
                    GET /resource?access_token=vF9dft4qmT[... not shown for brevity] HTTP/1.1
                    Host: server.example.com
                    
                  The query may include other request specific parameters separated using &amp; characters.
                  This encoding should NOT be used if possible because of security weaknesses associated with
                  the URI method.
                </xs:documentation>
                <xs:appinfo>Restricted form of from-workflow.</xs:appinfo>
              </xs:annotation>
              <!-- constraint: NOT ALLOWED if (being reference from nameFromSamlAttribute or nameFromSamlAuthentication) 
                               equivalent to NOT ALLOWED if (samlVersion == 1.x)
              -->
              <!-- constraint: Generate warning message if this option is selected. -->
              <!-- Constraint: SD action builder should automatic pick-up SAML Assertion from query -->
            </xs:enumeration>
            <xs:enumeration value="from-ESG-HTTP-Authorization-saml2-bearer">
              <xs:annotation>
                <xs:documentation>
                  A base64(deflate(SAML assertion)) is packaged within the HTTP header after the Authorization field of 
                  type: saml2-bearer. This is an Intel ESG proprietary encoding.
                  The SAML assertion should be a bearer assertion.
                </xs:documentation>
              </xs:annotation>
              <!-- constraint: NOT ALLOWED if (being reference from nameFromSamlAttribute or nameFromSamlAuthentication) 
                               equivalent to NOT ALLOWED if (samlVersion == 1.x)
              -->
              <!-- constraint: 1) ONLY ALLOWED if (samlVersion == 2.0) 
                               2) ONLY ALLOWED if (requiredSamlEntitiesAndValue.SubjectConfirmationMethod == Saml v2.0 bearer)
                                  This constraint ensures that the received SAML assertion is actually using the correct
                                  SubjectConfirmationMethod.
              -->
            </xs:enumeration>
            <xs:enumeration value="from-ESG-HTTP-Authorization-saml2-hok-ssl">
              <xs:annotation>
                <xs:documentation>
                  A base64(deflate(SAML assertion)) is packaged within the HTTP header after the Authorization field of 
                  type: saml2-bearer. This is an Intel ESG proprietary encoding.
                  The SAML assertion should be a holder-of-key assertion whose credential will be valided via the authenticated
                  peer certificate from the associated SSL/TLS session.
                </xs:documentation>
              </xs:annotation>
              <!-- constraint: NOT ALLOWED if (being reference from nameFromSamlAttribute or nameFromSamlAuthentication) 
                               equivalent to NOT ALLOWED if (samlVersion == 1.x)
              -->
              <!-- constraint: 
                1) ONLY ALLOWED if (samlVersion == 2.0) 
                2) ONLY ALLOWED if ((requiredSamlEntitiesAndValue.SubjectConfirmationMethod == Saml v2.0 holder-of-key) AND
                                    (requiredSamlEntitiesAndValue.clientCredentialSource == peerCertificateFromSsl)
                                   ) 
                   This constraint ensures that we are meeting the implied requirements that the client credential, i.e.,
                   certificate, was securely received via a HTTPS session. The holder-of-key semantics embedded within the
                   SAML assertion is being enforced.
              -->
            </xs:enumeration>
            <xs:enumeration value="from-workflow">
              <xs:annotation>
                <xs:documentation>
                  General mechanism to allow application to get SAML assertion from anywhere.
                </xs:documentation>
              </xs:annotation>
              <!-- constraint: NOT ALLOWED if (being reference from nameFromSamlAttribute or nameFromSamlAuthentication) 
                               equivalent to NOT ALLOWED if (samlVersion == 1.x)
              -->
              <!-- constraint: Service Designer action builder must prompt application for workflow variable holding SAML assertion
                               to be processed.
              -->
            </xs:enumeration>
          </xs:restriction>
        </xs:simpleType>
      </xs:element>
      <xs:sequence minOccurs="0">
        <xs:annotation>
          <xs:documentation>
            A SAML assertion that is package within a SAML Query response is normally Deflated and then Base64 encoded.
            The Base 64 encoding is required because the compression mechanism can cause binary values to be generated.
            Additionally, the base64 encoding will remove linefeeds and whitespaces that can cause problems when they
            appear with the HTTP header.
            See Bindings for the OASIS Security Assertion Markup Language (SAML) V2.0 OASIS Standard, 15 March 2005
            for processing details.
          </xs:documentation>
          <xs:appinfo>
            For similar reasons, we will also be deflating and base64 encoding SAML assertions for our proprietary usage.
          </xs:appinfo>
        </xs:annotation>
        <!-- constraint: ONLY PRESENT if (importSource == (from-ESG-HTTP-Authorization-saml2-bearer OR
                                                           from-ESG-HTTP-Authorization-saml2-hok-ssl OR
                                                           from-HTTP-Authorization-Request-Header OR
                                                           from-form-embedded-access-token OR
                                                           from-HTTP-URI-Query-Parameter OR
                                                           from-workflow
                                                          )
                                         )
        -->
        <xs:element name="inflate" type="xs:boolean" minOccurs="0" default="false">
          <xs:annotation>
            <xs:documentation> 
              Indicates if the incoming token (entire SAML assertion) is to be inflated, i.e, expanded according to RFC1951.
            </xs:documentation>
          </xs:annotation>
          <!-- constraint:
               1) MUST be SET to TRUE if (importSource == (from-ESG-HTTP-Authorization-saml2-bearer OR
                                                           from-ESG-HTTP-Authorization-saml2-hok-ssl
                                                          )
                                         )
               2) NOT PRESENT if (importSource == (from-WS-Security-header OR 
                                                   from-HTTP-Authorization-Request-Header OR
                                                   from-HTTP-Form-Encoded-Body-Parameter OR 
                                                   from-HTTP-URI-Query-Parameter
                                                  )  
                                 )
          -->
        </xs:element>
        <xs:element name="base64Decode" type="xs:boolean" default="true">
          <xs:annotation>
            <xs:documentation>
              Indicates it the incoming token (entire SAML Assertion) is to be base64 decoded according to RFC 2045.
            </xs:documentation>
          </xs:annotation>
          <!-- constraint: 
               1) MUST be SET to TRUE if (importSource == (from-ESG-HTTP-Authorization-saml2-bearer OR
                                                           from-ESG-HTTP-Authorization-saml2-hok-ssl OR
                                                           from-HTTP-Authorization-Request-Header OR
                                                           from-HTTP-URI-Query-Parameter
                                                          )
                                         )
               2) MUST be SET to TRUE if (inflate == true)
               3) NOT PRESENT if (importSource == from-WS-Security-header)
          -->
        </xs:element>
      </xs:sequence>
      <xs:element name="specialExceptionHandling" type="aaa:AuthenticationExceptionHandling" minOccurs="0">
        <xs:annotation>
          <xs:documentation>
            Contains special exception handling information that is to be package in exception thrown if input document 
            does not contain a valid SAML Assertion. For example, there is no SAML Assertion: 
            Authorization: Bearer shdgencysgxbfm274mdkdfju8400dm ... kdoeu4678
            Fault generation code will utilized data in exception thrown to populate HTTP response status and authentication
            challenge to client.
            In particular, HTTP response will contain the HTTP status failure code, type of token expected and realm:
            ["401 Unauthorized/r/n WWW-Authenticate: " | "407 Proxy Authentication Required/r/n Proxy-Authetnication: "]  
            ["Bearer" | "saml2-bearer" | "saml2-hok-ssl"] " realm="" &lt;realm&gt; ""/r/n"
          </xs:documentation>
        </xs:annotation>
        <!-- constraint: 1) ONLY PRESENT if (importSource == (from-HTTP-Authorization-Request-Header OR
                                                              from-form-embedded-access-token OR
                                                              from-HTTP-URI-Query-Parameter OR
                                                              from-ESG-HTTP-Authorization-saml2-bearer OR 
                                                              from-ESG-HTTP-Authorization-saml2-hok-ssl OR
                                                             )
                                            )
                         2) if (importSource == (from-HTTP-Authorization-Request-Header OR
                                                 from-ESG-HTTP-Authorization-saml2-bearer OR 
                                                 from-ESG-HTTP-Authorization-saml2-hok-ssl OR
                                                )
                               ) 
                            then ONLY ALLOWED values for typeFailure = (401-Unauthorized | 407-Proxy Authentication Request)
                         3) if (importSource == (from-form-embedded-access-token OR
                                                 from-HTTP-URI-Query-Parameter
                                                )
                               ) 
                            then ONLY ALLOWED values for typeFailure = (400-Bad Request)
        -->
      </xs:element>
      <xs:element name="actor" type="aaa:ActorType" minOccurs="0">
        <!-- constraint: ONLY PRESENT if (importSource == from-WS-Security-header) -->
      </xs:element>
    </xs:sequence>
  </xs:complexType>
  <xs:complexType name="GrantReceiveInfoType">
    <xs:annotation>
      <xs:appinfo>
        Our intention is to use a SAML Bearer Assertion to encode all the infomration in the grant request.
        
        We should map the grant extraction into the following nameFromSamlSubject provisioning:
        1) signatureAcceptMethods must be set to: rsaWithSha256
        2) digestAcceptMethod must be set to: sha256
        3) canonicalAcceptMethod must be set to: C14N_exclusive
        4) authenticationPolicy must be set to grant provisioned value: SignatureVerificationInfo authenticationPolicy value
        5) certificate must not be populated, i.e., use certificate in incoming SAML assertion
        6) if grant entry provisioned then caPath must be set to grant provisioned value: SignatureVerificationInfo caPath value
        7) requiredSamlEntitiesAndValues Issuer must be set to grant provisioned authorization server name
        8) requiredSamlEntitiesAndValues SubjectNameIdentifierFormat must be set to: 
        9) requiredSamlEntitiesAndValues SubjectConfirmationMethod must be set to: urn:oasis:names:tc:SAML:2.0:cm:bearer
        10) requiredSamlEntitiesAndValues NotBeforeAndNotOnOrAfter must be set to: onlyCheckConditionsElement
        11) requiredSamlEntitiesAndValues Recipient must be set to provisioned grant authorization server name
        12) requiredSamlEntitiesAndValues Audience must be set to provisioned grant authorization server name
        13) requiredSamlEntitiesAndValues checkUniqueness must be set to: true
        14) A SAML Attribute; name: client_id, value: client_id from incoming request
        15) A SAML Attribute; name redirect_uri, value from incoming request
        16) If SAML Assertion encrypted then
            a) acceptableKeyTransportMethods must be set to: rsa-v1.5
            b) keyPair must be set to provision grant value
            c) acceptableDataEncryptionMethods must be set to: aes128
      </xs:appinfo>
    </xs:annotation>
    <xs:sequence>
      <xs:element name="authorizationServer" type="aaa:SamlUri">
        <xs:annotation>
          <xs:documentation>
            URI uniquely identifying the authorization server or the service provider controlling domain.
          </xs:documentation>
        </xs:annotation>
      </xs:element>
      <xs:element name="verificationInfo">
        <xs:complexType>
          <xs:sequence>
            <xs:element name="authenticationPolicy" type="aaa:WebServiceAuthenticationPolicy"/>
            <xs:element name="caPath" type="aaa:VerifyCaPathSecurityToken" minOccurs="0">
              <xs:annotation>
                <xs:documentation>
                  Name of a caPath element. 
                  This element identifies a list of untrusted Certificate Authorities.
                    
                  In signature verification, the caPath is utilized in checkTrust to supply missing immediate Certificate Authorities certificates
                  between the far-end certificate and a CA certificate within the trustedCaGroup of CA certificates.
                </xs:documentation>
                <xs:appinfo>
                  At this time, SAML assertion verification will ONLY support the CA Path being supplied from the associated security config, not the workflow.
                </xs:appinfo>
              </xs:annotation>
            </xs:element>
          </xs:sequence>
        </xs:complexType>
      </xs:element>
      <xs:element name="decryptionInfo" minOccurs="0">
        <xs:complexType>
          <xs:sequence>
            <xs:element name="x509KeyPair" type="aaa:SecurityPackageHandle"/>
          </xs:sequence>
        </xs:complexType>
      </xs:element>
    </xs:sequence>
  </xs:complexType>
  <xs:complexType name="AuthenticationExceptionHandling">
    <xs:sequence>
      <xs:element name="typeFailureResponse" default="401-Unauthorized">
        <xs:simpleType>
          <xs:restriction base="xs:string">
            <xs:enumeration value="400-Bad Request">
              <xs:annotation>
                <xs:documentation>
                  The request could NOT be processed by the server because it is malformed.
                </xs:documentation>
              </xs:annotation>
            </xs:enumeration>
            <xs:enumeration value="401-Unauthorized">
              <xs:annotation>
                <xs:documentation>Server is challenging the authorization of the client.</xs:documentation>
              </xs:annotation>
            </xs:enumeration>
            <xs:enumeration value="407-Proxy Authentication Required">
              <xs:annotation>
                <xs:documentation>Proxy is challenging the authorization of the client.</xs:documentation>
              </xs:annotation>
            </xs:enumeration>
          </xs:restriction>
        </xs:simpleType>
      </xs:element>
      <xs:element name="realm" type="aaa:SamlUri" minOccurs="0">
        <xs:annotation>
          <xs:documentation>
            Realm identifies the computer or system being accessed. It typically allows a whole set of pages
            to be protected by authentication.
          </xs:documentation>
        </xs:annotation>
        <!-- constraint: 1) MUST be POPULATED if (typeFailureResponse == (401-Unauthorized OR 407-Proxy Authentication Required)) 
                         2) Should NOT be POPULATD if (typeFailureResponse == 400-Bad Request)
        -->
      </xs:element>
    </xs:sequence>
  </xs:complexType>
  <xs:complexType name="AuthenticateIdentity">
    <xs:annotation>
      <xs:documentation>
        Define what authentication method should be used to validate the extracted Identity.
      </xs:documentation>
      <xs:appinfo>
        When there are two instances, i.e., extracted identity is nameFromOAuthAuthorizationRequest and flowType is 
        ResourceOwnerPasswordCredential or ImplicitGrant, the first instance identifies the user and the second instance identifies the client.
        I am making this choice because:
        1) the access token will be user specific and not client specific in general when both entities are present.
        2) The user resolution could be resolved by some back-end service that could be a SSO token that can be used as the access token.
      </xs:appinfo>
    </xs:annotation>
    <xs:choice>
      <xs:element name="xpath" type="aaa:EmptyType">
        <xs:annotation>
          <xs:documentation>
              Support the ability to check that arbitrary extracted identity matches populated XML document.
              constraint: service designer must prompt developer to identify:
              XPath expression upon BEPL variable with substitution of extracted identity in the expression
              from current workflow variable when this AAA policy is bound to a workflow action. 
              Associated action builder is required to bind these identified variables to the extension functions requiring them as input.
            </xs:documentation>
        </xs:annotation>
        <!-- constraint: NOT ALLOWED if identity extraction method is ssoFromCookie or ssoFromWorkflow -->
      </xs:element>
      <xs:element name="keystore" type="aaa:EmptyType">
        <xs:annotation>
          <xs:documentation>Authenicating Identity against statically provisioned keystore.</xs:documentation>
        </xs:annotation>
        <!-- constraint: 
            Note: Parenthesize is important in the following constraints!
            1) PRESENT if (extractIndentity == (httpBasicAuthenticationHeader OR usernameFromSecurityHeader OR
                                                usernamePasswordFromWorkflow OR derivedUsernameFromSecurityHeader
                                               )
               {Reason: have username to perform keystore query to get password.}
            2) Not present when (extract identity is nameFromSamlSubject, nameFromSamlAuthentication or nameFromSamlAttribute) AND 
               (sub-extraction is enabled, OR NameIdentifierFormat is NOT urn:oasis:names:c:SAML1.1:nameid-format:X509SubjectName).
               {Reason: 1) do not know how to map to keystore supported attributes, e.g., subject-name, ski, etc.
                        2) if sub-extraction then do not know what keystore attribute, e.g., username, identity, keyname, to use.}
            3) Present when ((extract identity is nameFromSamlSubject, nameFromSamlAuthentication or nameFromSamlAttribute) AND   
                             (NameIdentifierFormat is urn:oasis:names:tc:SAML:1.1:nameid-format:X509SubjectName) AND 
                             (sub-extraction is disabled)
                            )
               {Reason: have full X509 subject name for keystore query.}
            4) Not present when (extract identity is clientIpAddr).
               {Reason: currently not supporting clientIpAddr extract identity.}
            5) Not Present when (extract identity is certificateAttributeFromSecurityHeader, nameFromSamlSubject, nameFromSamlAuthentication or nameFromSamlAttribute)
               AND (map identity is createUsernameToken or httpAuthentication) 
               AND (map identity is using keystore or LDAP resolution mechanism to retrieve the username & password).
               {Reason: really more of an optimization to avoid redundant queries?}
            6) PRESENT if ((extractIndentity == (certificateFromPeerSsl OR x509CertificateFromSecurityHeader OR
                                                 certificateAttributeFromSecurityHeader OR bstFromVerifyOperation OR x509CertificateFromWorkflow
                                                )
                           ) AND 
                           (certificate attribute == (subject-name OR SKI OR sha1-fingerprint OR certificate))
                          )
               {Note: this constraint is more restricted then is necessary.}
            7) NOT PRESENT IF ((extractIndentity == (certificateFromPeerSsl OR x509CertificateFromSecurityHeader OR bstFromVerifyOperation OR 
                                                     x509CertificateFromWorkflow OR certificateAttributeFromSecurityHeader
                                                    )
                               ) AND 
                               (certificate attribute == (Generated subject key identifier OR Generated short subject key identifier OR
                                                          issuer/serial number OR MD5 fingerprint)
                               )
                              )
            8) NOT ALLOWED if ((extractIndentity == (certificateFromPeerSsl OR x509CertificateFromSecurityHeader OR bstFromVerifyOperation OR
                                                     x509CertificateFromWorkflow OR certificateAttributeFromSecurityHeader) AND 
                               (certificate attribute is subjectName) AND 
                               (extractMostSpecificComponentFromSubjectName == TRUE)
                              )
               Note: NOT ALLOWED specified here because I want keystore as a mechanism to be visible to user. 
            9) NOT ALLOWED if identity extraction method is ssoFromCookie or ssoFromWorkflow
            10)NOT ALLOWED if ((mapIdentity mechanism == (createUsernameToken or createHttpBasicAutnentication) AND 
                               (using keystore resolution mechanism to retrieve username and password)
                              )
            11)NOT ALLOWED if ((extract identity mechanism is principalNameFromKerberosToken) AND (extract primary is FALSE))
            12) ALLOWED if ((extractIdentity == nameFromOAuthAuthorizationRequest) AND 
                            (((flowType == (ClientCredential OR ResourceOwnerPasswordCredential OR
                                            ResourceOwnerSamlAssertionCredential OR RefreshToken)
                              ) AND 
                              (roleBeingChecked == client) AND (clientSourceType == (HttpBasicAuthorization OR RequestBody))
                             ) OR
                             ((flowType == AuthorizationCode) AND (authorizationCodeRequestType == accessTokenRequest) AND
                              (roleBeingChecked == client) AND (clientSourceType == (HttpBasicAuthorization OR RequestBody))
                             ) OR
                             ((flowType == ResourceOwnerPasswordCredential) AND (roleBeingChecked == resourceOwner))
                            )
                           )
          -->
      </xs:element>
      <xs:element name="ldapAuthentication" type="aaa:LdapAuthentication">
        <!-- constraint:
          1) NOT ALLOWED if ((extract identity mechanism == (certificateFromPeerSsl OR x509CertificateFromSecurityHeader OR 
                                                             x509CertificateFromWorkflow OR bstFromVerifyOperation
                                                           )
                             ) AND 
                             (certifcate-attribute exraction == (full certificate OR SKI OR Sha1Fingerprint OR Md5Fingerprint OR
                              generatedSKI OR ShortSKI OR issuerSerialNumber
                             )
                            )
          2) NOT ALLOWED if identity extraction method is ssoFromCookie or ssoFromWorkflow.
          3) NOT ALLOWED if ((mapIdentity mechanism == (createUsernameToken or createHttpBasicAutnentication) AND 
                             (using LDAP resolution mechanism to retrieve username and password)
                            )
          4) NOT ALLOWED if ((extract identity mechanism is principalNameFromKerberosToken) AND (extract primary is FALSE))
          5) ALLOWED if ((extractIdentity == nameFromOAuthAuthorizationRequest) AND 
                         (((flowType == (ClientCredential OR ResourceOwnerPasswordCredential OR 
                                         ResourceOwnerSamlAssertionCredential OR RefreshToken
                                        )
                            )
                           ) AND 
                           (roleBeingChecked == client) AND (clientSourceType == (HttpBasicAuthorization OR RequestBody))
                          ) OR
                          ((flowType == AuthorizationCode) AND (authorizationCodeRequestType == accessTokenRequest) AND
                           (roleBeingChecked == client) AND (clientSourceType == (HttpBasicAuthorization OR RequestBody))
                          ) OR
                          ((flowType == ResourceOwnerPasswordCredential) AND (roleBeingChecked == resourceOwner))
                         )
                        )
          -->
      </xs:element>
      <xs:element name="siteMinderAuthentication" type="aaa:SiteMinderAuthentication">
        <!-- constraint: 
             1) ALLOWED if ((extracted identity == (certificateFromPeerSsl OR x509CertificateFromSecurityHeader OR
                                                    x509CertificateFromWorkflow OR bstFromVerifyOperation
                                                   )
                            ) AND
                            (extract certificate attribute is full certificate)
                           )
             2) ALLOWED if (extracted identity == (usernameFromHttpBasicAuthenticationHeader OR usernameFromSecurityHeader OR 
                                                   usernamePasswordFromWorkflow OR ssoFromWorkflow  
                                                  )
                           )
             3) ALLOWED if ((extracted identity == ssoFromCookie) AND (cookieName != ("SplashLoginCookie" OR "ObSSOCookie")))
             4) ALLOWED if ((extractIdentity == nameFromOAuthAuthorizationRequest) AND 
                            (((flowType == (ClientCredential OR ResourceOwnerPasswordCredential OR 
                                            ResourceOwnerSamlAssertionCredential OR RefreshToken
                                           )
                              )
                             ) AND 
                             (roleBeingChecked == client) AND (clientSourceType == (HttpBasicAuthorization OR RequestBody))
                            ) OR
                            ((flowType == AuthorizationCode) AND (authorizationCodeRequestType == accessTokenRequest) AND
                             (roleBeingChecked == client) AND (clientSourceType == (HttpBasicAuthorization OR RequestBody))
                            ) OR
                            ((flowType == ResourceOwnerPasswordCredential) AND (roleBeingChecked == resourceOwner))
                           )
             5) WARNING "Cookie authentication mechanism is not consistent with SiteMinder default cookie name"
                if (extract identity cookie name != "SMSESSION")
        -->
      </xs:element>
      <xs:element name="oracleAccessManagerAuthentication" type="aaa:OracleAccessManagerAuthentication">
        <!-- constraint: 
             1) ALLOWED if ((extracted identity == (certificateFromPeerSsl OR x509CertificateFromSecurityHeader OR   
                                                    x509CertificateFromWorkflow OR bstFromVerifyOperation
                                                   )
                            ) AND 
                            (extract certificate attribute is full certificate)
                           )
             2) ALLOWED if (extracted identity == (usernameFromHttpBasicAuthenticationHeader OR usernameFromSecurityHeader OR
                                                   usernamePasswordFromWorkflow OR ssoFromWorkflow
                                                  )
                           )
             3) ALLOWED if ((extracted identity == ssoFromCookie) AND (cookieName != ("SplashLoginCookie" OR "SMSESSION")))
             4) ALLOWED if ((extractIdentity == nameFromOAuthAuthorizationRequest) AND 
                            (((flowType == (ClientCredential OR ResourceOwnerPasswordCredential OR 
                                            ResourceOwnerSamlAssertionCredential OR RefreshToken
                                           )
                              )
                             ) AND 
                             (roleBeingChecked == client) AND (clientSourceType == (HttpBasicAuthorization OR RequestBody))
                            ) OR
                            ((flowType == AuthorizationCode) AND (authorizationCodeRequestType == accessTokenRequest) AND
                             (roleBeingChecked == client) AND (clientSourceType == (HttpBasicAuthorization OR RequestBody))
                            ) OR
                            ((flowType == ResourceOwnerPasswordCredential) AND (roleBeingChecked == resourceOwner))
                           )
             5) WARNING "Cookie authentication mechanism is not consistent with Oracle Access Manager default cookie name"
                if (extract identity cookie name != "ObSSOCookie")
          -->
      </xs:element>
      <xs:element name="tivoliAccessManagerAuthentication" type="aaa:TivoliAccessManagerAuthentication">
        <!-- constraint: 
             1) ALLOWED if (extracted identity == (usernameFromHttpBasicAuthenticationHeader OR usernameFromSecurityHeader OR
                                                   usernamePasswordFromWorkflow
                                                  )
                           )
             2) ALLOWED if ((extractIdentity == nameFromOAuthAuthorizationRequest) AND 
                            (((flowType == (ClientCredential OR ResourceOwnerPasswordCredential OR 
                                            ResourceOwnerSamlAssertionCredential OR RefreshToken
                                           )
                              )
                             ) AND 
                             (roleBeingChecked == client) AND (clientSourceType == (HttpBasicAuthorization OR RequestBody))
                            ) OR
                            ((flowType == AuthorizationCode) AND (authorizationCodeRequestType == accessTokenRequest) AND
                             (roleBeingChecked == client) AND (clientSourceType == (HttpBasicAuthorization OR RequestBody))
                            ) OR
                            ((flowType == ResourceOwnerPasswordCredential) AND (roleBeingChecked == resourceOwner))
                           )
        -->
        <!-- constraint: NOT ALLOWED if identity extraction method is ssoFromCookie or ssoFromWorkflow -->
      </xs:element>
      <xs:element name="oracleEntitlementServerAuthentication" type="aaa:OracleEntitlementServerAuthentication">
        <!-- constraint: 
             1) ALLOWED if (extract identity == (usernameFromHttpBasicAuthenticationHeader OR usernameFromSecurityHeader OR
                                                 usernamePasswordFromWorkflow
                                                )
                           )
             2) ALLOWED if ((extractIdentity == nameFromOAuthAuthorizationRequest) AND 
                            (((flowType == (ClientCredential OR ResourceOwnerPasswordCredential OR 
                                            ResourceOwnerSamlAssertionCredential OR RefreshToken
                                           )
                              )
                             ) AND 
                             (roleBeingChecked == client) AND (clientSourceType == (HttpBasicAuthorization OR RequestBody))
                            ) OR
                            ((flowType == AuthorizationCode) AND (authorizationCodeRequestType == accessTokenRequest) AND
                             (roleBeingChecked == client) AND (clientSourceType == (HttpBasicAuthorization OR RequestBody))
                            ) OR
                            ((flowType == ResourceOwnerPasswordCredential) AND (roleBeingChecked == resourceOwner))
                           )
          -->
      </xs:element>
      <xs:element name="validateKerberosToken" type="aaa:ValidateKerberosToken">
        <!-- constraint: ONLY ALLOWED if (extract identity == principalNameFromKerberosToken) -->
      </xs:element>
      <xs:element name="checkX509CerticateChainOfTrust" type="aaa:CheckX509CertificateChainOfTrust">
        <!-- constraint: ONLY ALLOWED if (extract identity == (x509CertifcateFromWorkflow OR x509CertificateFromSecurityHeader)) -->
      </xs:element>
      <xs:element name="checkX509CertificateUsingOcsp" type="aaa:CheckX509CertificateUsingOcsp">
        <!-- constraint: ONLY ALLOWED if (extract identity == (certificateFromPeerSsl OR x509CertifcateFromWorkflow OR
                                                                 x509CertificateFromSecurityHeader OR bstFromVerifyOperation
                                                                )
                                           )
          -->
      </xs:element>
      <xs:element name="wsTrustAuthentication" type="aaa:WsTrustAuthentication">
        <xs:annotation>
          <xs:appinfo>
            1) The wst:RequestedSecurityToken of the wst:RequestSecurityTokenResponse needs to be made available to the application via
               a getSecurityMetadata action
            2) The wst:RequestedProofToken of the wst:RequestSecurityTokenResponse needs to be made available to the application via
               a getSecurityMetadata action
          </xs:appinfo>
        </xs:annotation>
        <!-- constraint: 
             1) ALLOWED if (extract identity == (usernameFromSecurityHeader, usernameFromHttpBasicAuthenticationHeader, 
                                                 usernamePasswordFromWorkflow, 
                                                 nameFromSamlAttribute, nameFromSamlAuthentication and nameFromSamlSubject
                                                )
                           )
                In theory, we should be able to support: certificateFromPeerSsl, x509CertifcateFromWorkflow, 
                x509CertificateFromSecurityHeader, bstFromVerifyOperation, CertificateAttributeFromSecurityHeader, 
                and principalNameFromKerberosToken.
                In theory, ssoFromCookie, ssoFromWorkflow and samlArtifact should be able to be handled as custom tokens.
             2) ALLOWED if ((extractIdentity == nameFromOAuthAuthorizationRequest) AND 
                            (((flowType == (ClientCredential OR ResourceOwnerPasswordCredential OR 
                                            ResourceOwnerSamlAssertionCredential OR RefreshToken
                                           )
                              )
                             ) AND 
                             (roleBeingChecked == client) AND (clientSourceType == (HttpBasicAuthorization OR RequestBody))
                            ) OR
                            ((flowType == AuthorizationCode) AND (authorizationCodeRequestType == accessTokenRequest) AND
                             (roleBeingChecked == client) AND (clientSourceType == (HttpBasicAuthorization OR RequestBody))
                            ) OR
                            ((flowType == (ResourceOwnerPasswordCredential)) AND 
                             (roleBeingChecked == resourceOwner)
                            )
                           )
                In theory, we should be able to support WS-Trust checking of SAML Assertion for ResourceOwnerPasswordCredential,
                ResourceOwnerSamlAssertionCredential, RefreshToken, or AuthorizationCode.
          -->
      </xs:element>
      <!-- constraint: 
           1) WARNING "Not authenticating the extracted name and password"
              if NOT POPULATED if (extract identity == (usernameFromSecurityHeader OR usernameFromHttpBasicAuthenticationHeader OR
                                                        usernamePasswordFromWorkflow,derivedUsernameFromSecurityHeader OR
                                                        principalNameFromKerberosToken [OR usernameFromHttpDigestAuthentication]
                                                       )
                                  )
           2) WARNING "Not authenticating the extracted name and password"
              if ((extractIdentity == nameFromOAuthAuthorizationRequest) AND 
                  (((flowType == (ImplicitGrant OR ClientCredential OR ResourceOwnerPasswordCredential OR RefreshToken)) AND 
                   (roleBeingChecked == client) AND (clientSourceType == (HttpBasicAuthorization OR RequestBody))
                  ) OR
                   ((flowType == AuthorizationCode) AND (authorizationCodeRequestType == accessTokenRequest) AND
                    (roleBeingChecked == client) AND (clientSourceType == (HttpBasicAuthorization OR RequestBody))
                   )
                  ) OR
                  ((flowType == ResourceOwnerPasswordCredential) AND (roleBeingChecked == resourceOwner))
                 )
      -->
    </xs:choice>
  </xs:complexType>
  <xs:complexType name="AuthenticationMechanisms"/>
  <xs:complexType name="LdapAuthentication">
    <xs:annotation>
      <xs:documentation>
        A LDAP Authentication Request will be generated to verify that the extracted Identity is approved.
        Because we are authenticating via an LDAP Authentication Request message, username tokens utilizing
        PasswordDigest or key derivation format can NOT be authenticated because the password is unknown.
        Therefore, a separate LDAP invocation to generate a search/access request must be explicitly performed to
        retrieve the associated password for an explicit authentication request to be performed.
      </xs:documentation>
      <xs:appinfo>
        A potential optimization is for Action Builder to combine this LDAP Authentication request with the LDAP authorization 
        request into a single LDAP request as a batch request.
      </xs:appinfo>
    </xs:annotation>
    <xs:sequence>
      <xs:element name="distinguishedNamePrefix" type="aaa:DistinguishedNameType">
        <xs:annotation>
          <xs:documentation>This string will be used to prefix the username extracted for this identity</xs:documentation>
        </xs:annotation>
      </xs:element>
      <xs:element name="distinguishedNamePostfix" type="aaa:DistinguishedNameType">
        <xs:annotation>
          <xs:documentation>This string will be used to postfix the extracted username for this identity.</xs:documentation>
        </xs:annotation>
      </xs:element>
      <xs:element name="resultAttrName" type="aaa:ResultAttrType" default="UserPassword" minOccurs="0">
        <xs:annotation>
          <xs:documentation>
            The name of the searchResponse - searchResultEntry - attr element containing the desired retrieve value, 
            e.g., password, certificate.
          </xs:documentation>
        </xs:annotation>
        <!-- constraint: this element should only be allowed/visible if the extractedIdentity mechanism is derivedUsernameTokenFromSecurityHeader. -->
      </xs:element>
      <xs:element name="serverUrl" type="xs:anyURI" minOccurs="0">
        <xs:annotation>
          <xs:documentation>
            Allows AAA Policy writer to bind LDAP IA to a specific backend server.
            This is very useful when automatically using the same AAA policy in multiple places so that they are all bound to same LDAP server.
          </xs:documentation>
          <!-- This element will be mapped to two advanced fields: server host name and port in service designer. Default port = 389 (636 for SSL/TLS future) -->
        </xs:annotation>
      </xs:element>
    </xs:sequence>
    <!-- constraint: 
      When this policy is being bound to an action, Service Designer will need to ask the developer for the following information:
        1) LDAP server address
        2) LDAP server port number. Can be defaulted to 389. 636 for when LDAP over SSL/TLS.
      The following two should only be prompted for when the extractedIdentity mechanism is derivedUsernameFromSecurityHeader. This is because 
      we will have to generate an LDAP search request to retrieve the password. When we have the password, we can generate an LDAP authentication
      request that doesnot require the LDAP administrator distriguished name and password to be authorize to perform the LDAP operation.
        3) LDAP administator Distinguished Name. This can be default to the LDAP acf config file associated with gnerated parntnerLink.
        4) LDAP administrator Password. This can be default to the LDAP acf config file associated with gnerated parntnerLink.
        5) Not allowed when extract identity is certificateAttributeFromSecurityHeader, nameFromSamlSubject, nameFromSamlAuthentication or 
           nameFromSamlAttribute, and map identity is createUsernameToken or httpAuthentication and it is using keystore or LDAP resolution 
           mechanism to retrieve the username & password.
    -->
    <!-- constraint: service designer will be supplying an internal variable with the following information. The specific information
           depends upon the context of the AAA processing being performed.
           1) Value used to build distinguished name used in LDAP search request. Inserted between prefix and postfix strings 
              from current workflow variable when this WS-Security policy is bound to a workflow action. 
    -->
    <!-- Associated action builder is required to bind these identified variables to the extension functions requirng them as input. -->
  </xs:complexType>
  <xs:complexType name="CheckX509CertificateChainOfTrust">
    <xs:annotation>
      <xs:documentation>
        This authentication mechanism support PKIX Certificate Path Validation defined in RFC 5280 "Internet X.509 Public Key Infrastructure
        Certificate and Certificate Revocation List (CRL) Profile". See section 6.
        The basic idea is that a chain-of-trust can be established from the target certuificate and a trusted Certificate Authority (CA). This 
        chain-of-trust can pass through zero or more immediate CAs.
      </xs:documentation>
    </xs:annotation>
    <xs:sequence>
      <xs:element name="authenticationPolicy" type="aaa:WebServiceAuthenticationPolicy"/>
      <xs:element name="caPath" type="aaa:VerifyCaPathSecurityToken" minOccurs="0">
        <xs:annotation>
          <xs:documentation>
            Name of a caPath element. 
            This element identifies a list of untrusted Certificate Authorities.
            The caPath is utilized in checkTrust to supply missing immediate Certificate Authorities certificates
            between the far-end certificate and a CA certificate within the trustedCaGroup of CA certificates.
            The trusted CA group is identified in the assocaited authentication policy.
          </xs:documentation>
        </xs:annotation>
      </xs:element>
    </xs:sequence>
  </xs:complexType>
  <xs:complexType name="CheckX509CertificateUsingOcsp">
    <xs:annotation>
      <xs:documentation>
        This authentication mechanism support checking the target certificate with the specified OCSP responder: RFC 2560 or RFC 5019
      </xs:documentation>
    </xs:annotation>
    <xs:sequence>
      <xs:element name="OcspPolicy">
        <xs:annotation>
          <xs:documentation>Name of OCSP Policy in associated Security Config Package</xs:documentation>
        </xs:annotation>
        <xs:simpleType>
          <xs:restriction base="xs:NMTOKEN">
            <xs:minLength value="1"/>
            <xs:maxLength value="160"/>
          </xs:restriction>
        </xs:simpleType>
      </xs:element>
    </xs:sequence>
  </xs:complexType>
  <xs:complexType name="SiteMinderAuthentication">
    <xs:annotation>
      <xs:documentation>
        A Netegrity SiteMinder request will be generated to verify that the extracted Identity is approved.
      </xs:documentation>
    </xs:annotation>
    <xs:sequence>
      <xs:element name="resource" type="aaa:SiteMinderResourceType"/>
      <xs:element name="action" type="aaa:SiteMinderActions" default="Get"/>
      <xs:element name="serverUrl" type="aaa:SiteMinderServerUrl" minOccurs="0">
        <xs:annotation>
          <xs:documentation>
            Advance SiteMinder server parameterization.
            It is very useful for the AAA Policy generator to specify this when the policy will be utilized in multiple places
            because it allows policy generator to bind all back-end SiteMinder server to the same SiteMinder IA.
          </xs:documentation>
        </xs:annotation>
      </xs:element>
      <xs:element name="ssoOptions" type="aaa:SsoChoices" minOccurs="0">
        <!-- constraint: if extract identity is ssoFromCookie and cookie name is not SMSESSION then generate a warning -->
      </xs:element>
    </xs:sequence>
  </xs:complexType>
  <xs:complexType name="OracleAccessManagerAuthentication">
    <xs:annotation>
      <xs:documentation>
        A Oracle Access Manager request will be generated to verify that the extracted Identity is approved.
      </xs:documentation>
    </xs:annotation>
    <xs:sequence>
      <xs:element name="resource" type="aaa:OracleAccessManagerResourceType"/>
      <xs:element name="method" type="aaa:OracleAccessManagerMethods" default="Get"/>
      <xs:element name="oracleInstallationDirectory" type="xs:anyURI" minOccurs="0">
        <xs:annotation>
          <xs:documentation>
            Allows AAA Policy writer to bind Oracle Access Manager IA to a specific backend server.
            This is very useful when automatically using the same AAA policy in multiple places so that they are all bound to same OAM server.
          </xs:documentation>
        </xs:annotation>
      </xs:element>
      <xs:element name="ssoOptions" type="aaa:SsoChoices" minOccurs="0">
        <!-- constraint: if extract identity is ssoFromCookie and cookie name is not ObSSOCookie then generate a warning -->
      </xs:element>
    </xs:sequence>
  </xs:complexType>
  <xs:simpleType name="SiteMinderServerUrl">
    <xs:annotation>
      <xs:documentation>
        Allows AAA Policy writer to bind SiteMinder IA to a specific backend server.
        This is very useful when automatically using the same AAA policy in multiple places so that 
        they are all bound to same SiteMinder server.
      </xs:documentation>
      <!-- The host name will have appended the port number for acctPort, authPort and azPort, where
           acctPort default: 44441
           authPort default: 44442
           azPort   default: 44443
      -->
    </xs:annotation>
    <xs:restriction base="xs:anyURI"/>
  </xs:simpleType>
  <xs:complexType name="Eca360CookieVerification">
    <xs:sequence>
      <xs:element name="iceTokenDecryptionInfo" type="aaa:AcceptIceTokenEncryptionInfo" minOccurs="0">
        <xs:annotation>
          <xs:documentation>
            Proprietary ECA 360 (Split Point) light-weight web JSON token.
            If encryption required, then the plain text format will be converted to the following encrypted format:
              {
                "encryption":{
                  "enc_alg":"xxxxxx",
                  "enc_iv":"xxxxxx",
                  "enc_salt":"xxxxxx",
                  "enc_value":"xxxxxxxxxxxxxxxxxxxxxxxxx"
                }
              }
        </xs:documentation>
        </xs:annotation>
      </xs:element>
      <xs:element name="iceTokenVerifyInfo" type="aaa:AcceptIceTokenSignatureInfo">
        <xs:annotation>
          <xs:documentation>
            Proprietary ECA 360 (Split Point) light-weight web JSON token.
            The plain-text ICE token is:
            { 
              "payload": [
                ...
              ],
              "signature":{
                "sign_alg":"SHA1withRSA",
                "sign_value":"base64 encoded signature value"
              }
            }
          </xs:documentation>
        </xs:annotation>
        <!-- WARNING "Ability to ensure the integrity of ECA 360 proprietary token is not being enforced" 
             if (iceTokenVerifyInfo is not being populated)
        -->
      </xs:element>
      <xs:element name="requiredVerification" minOccurs="0">
        <xs:annotation>
          <xs:documentation>
            Proprietary ECA 360 (Split Point) light-weight web JSON token.
            The plain-text ICE token is:
            { 
              "payload": 
                [
                  {"subject":"xxxxxx"},
                  {"not_before":"xxxxxx"},
                  {"not_after":"xxxxxx"},
                  {"issuer":"xxxxxx"},
                  {"audiences":["xxxxxx", ..., "xxxxxx"]},
                  {"ext_attrs":
                    [
                      {"name-1":"value-1"},
                        ...
                      {"name-n":"value-n"}
                    ]
                  }
                ],
              "signature":{
                "xxx":"xxxx"
              }
            }
            
            where ext_attrs: map, user defined attributes that describes the authenticated user.
            UTF-8 will be used for JSON object encoding algorithm.
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:sequence>
            <xs:element name="validateLifetime" type="xs:boolean" default="true">
              <xs:annotation>
                <xs:documentation>
                  Validate the lifetome of the token.
                  not_before: integer, when this token becomes valid. Seconds since midnight 1/1/1970 Zulu. 
                  not_after: integer, when this token expires. Seconds since midnight 1/1/1970 Zulu.
                </xs:documentation>
              </xs:annotation>
            </xs:element>
            <xs:element name="issuer" minOccurs="0">
              <xs:annotation>
                <xs:documentation>
                  Server descriptor of the issuer. This could be the service descriptor itself or some form of
                  client ID, which verifier can map to a server descriptor.
                </xs:documentation>
              </xs:annotation>
              <xs:simpleType>
                <xs:restriction base="xs:string">
                  <xs:minLength value="1"/>
                </xs:restriction>
              </xs:simpleType>
            </xs:element>
            <xs:element name="audience" type="aaa:SamlString" minOccurs="0">
              <xs:annotation>
                <xs:documentation>
                  Identifies a specific audience that this ECA 360 ICE token must match.
                  The audiences claim within the ICE token is a string array. A single ICE Token can be issued for use by 
                  multiple consuming entities/audiences, i.e., why it is an string array. The specified audience must appear
                  in this array.
                </xs:documentation>
              </xs:annotation>
            </xs:element>
          </xs:sequence>
        </xs:complexType>
      </xs:element>
    </xs:sequence>
  </xs:complexType>
  <xs:complexType name="TivoliAccessManagerAuthentication">
    <xs:annotation>
      <xs:documentation>
        A TivoliAccessManager request will be generated to verify that the extracted Identity is approved.
      </xs:documentation>
    </xs:annotation>
    <xs:sequence>
      <xs:element name="tivoliAccessManagerConfigUrl" type="aaa:TivoliAccessManagerConfigUrl" minOccurs="0"/>
    </xs:sequence>
  </xs:complexType>
  <xs:complexType name="OracleEntitlementServerAuthentication">
    <xs:annotation>
      <xs:documentation>
        A Oracle Entitlement Server request will be generated to verify that the extracted Identity is approved.
      </xs:documentation>
    </xs:annotation>
    <xs:sequence>
      <xs:element name="serverUrl" type="xs:anyURI" minOccurs="0"/>
    </xs:sequence>
    <xs:attribute name="cacheLifeTime" type="xs:unsignedInt" default="3">
      <xs:annotation>
        <xs:documentation>
          Application can choose to cache the OES authentication result or not. The default cache life time (timeout) is 3 seconds.
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:complexType>
  <xs:complexType name="WsTrustAuthentication">
    <xs:annotation>
      <xs:documentation>
        A WS-Trust request will be generated to verify that the extracted Identity is approved/authenticated. The server authenticates 
        the requester and returns a WS-Trust token that can be used for further communication.
      </xs:documentation>
    </xs:annotation>
    <xs:sequence>
      <xs:element name="version" default="1.3">
        <xs:simpleType>
          <xs:restriction base="xs:string">
            <xs:enumeration value="1.3"/>
            <xs:enumeration value="1.4"/>
          </xs:restriction>
        </xs:simpleType>
      </xs:element>
      <xs:element name="soapVersion" type="aaa:SoapVersion" default="1.2">
        <xs:annotation>
          <xs:documentation>
            Identify what SOAP version should be used to communicate with the WS-Trust Server (STS).
            Note: 1) The SOAP version being used on the application request and communicating with theSTS can be different.
                  2) The WS-Trust standard applies to imply that on SOAP version 1.1 should be used. However, MS ADFS requires
                     that SOAP version 1.2 is used.
          </xs:documentation>
        </xs:annotation>
      </xs:element>
      <xs:element name="requestType" default="Issue">
        <xs:simpleType>
          <xs:restriction base="xs:string">
            <xs:enumeration value="Issue">
              <xs:annotation>
                <xs:documentation>http://docs.oasis-open.org/ws-sx/ws-trust/200512/Issue</xs:documentation>
              </xs:annotation>
            </xs:enumeration>
            <!-- deferred
            <xs:enumeration value="Renew">
              <xs:annotation>
                <xs:documentation>http://docs.oasis-open.org/ws-sx/ws-trust/200512/Renew</xs:documentation>
              </xs:annotation>
            </xs:enumeration>
            <xs:enumeration value="Cancel">
              <xs:annotation>
                <xs:documentation>http://docs.oasis-open.org/ws-sx/ws-trust/200512/Cancel</xs:documentation>
              </xs:annotation>
            </xs:enumeration>
            <xs:enumeration value="Validate">
              <xs:annotation>
                <xs:documentation>http://docs.oasis-open.org/ws-sx/ws-trust/200512/Validate</xs:documentation>
              </xs:annotation>
            </xs:enumeration>
            -->
          </xs:restriction>
        </xs:simpleType>
      </xs:element>
      <xs:element name="tokenType" default="SAML-v2.0">
        <xs:annotation>
          <xs:documentation>Type of token being requested from WS-Trust server (STS)</xs:documentation>
        </xs:annotation>
        <xs:simpleType>
          <xs:restriction base="xs:string">
            <xs:enumeration value="SAML-v1.1">
              <xs:annotation>
                <xs:documentation>http://docs.oasis-open.org/wss/oasis-wss-saml-token-profile-1.1#SAMLV1.1</xs:documentation>
              </xs:annotation>
              <!-- constraint: requestType MUST be Issue -->
            </xs:enumeration>
            <xs:enumeration value="SAML-v2.0">
              <xs:annotation>
                <xs:documentation>http://docs.oasis-open.org/wss/oasis-wss-saml-token-profile-1.1#SAMLV2.0</xs:documentation>
              </xs:annotation>
              <!-- constraint: requestType MUST be Issue -->
            </xs:enumeration>
            <xs:enumeration value="Inferred">
              <xs:annotation>
                <xs:documentation>
                  No explicit token type is specified. The OPTIONAL wsp:AppliesTo element is used to indicate the target where this token will 
                  be used (similar to the Kerberos target service model). If both the wst:TokenType and wsp:AppliesTo elements are defined, then
                  the wsp:AppliesTo element takes precedence.
                </xs:documentation>
              </xs:annotation>
            </xs:enumeration>
            <xs:enumeration value="SCT">
              <xs:annotation>
                <xs:documentation>Secure Conversation: http://docs.oasis-open.org/ws-sx/ws-secureconversation/200512/sct</xs:documentation>
              </xs:annotation>
              <!-- deferred: temporary uncommented so that Derc can use in show and tell. Should not be visible in official release -->
            </xs:enumeration>
          </xs:restriction>
        </xs:simpleType>
      </xs:element>
      <xs:element name="rstFormat" default="RST">
        <xs:annotation>
          <xs:documentation>
            What type of RequestSecurityToken (RST) request should be generated.
            A RST request can contain only a request for a single security token.
            A RSTC (RequestSecurityTokenCollection) allows one or more RST to be packaged within a single request.
          </xs:documentation>
        </xs:annotation>
        <xs:simpleType>
          <xs:restriction base="xs:string">
            <xs:enumeration value="RST"/>
            <xs:enumeration value="RSTC">
              <xs:annotation>
                <xs:documentation>For our usage, only a single RST will be package within the collection.</xs:documentation>
              </xs:annotation>
            </xs:enumeration>
          </xs:restriction>
        </xs:simpleType>
      </xs:element>
      <xs:element name="appliesTo" type="aaa:SamlUri" minOccurs="0">
        <xs:annotation>
          <xs:documentation>
            Specifies the scope for which this security token is desired, e.g., the service(s) to which the requested token applies.
            In the situation where BOTH the wsp:TokenType and wsp:AppliesTo elements have values, the wsp:AppliesTo element should takes precedence. 
            This is because the issuing service is more likely to know the type of token to be used for the specified scope than the requestor. 
            Additionally, the returned tokens should be opaque to the requestor.
          </xs:documentation>
        </xs:annotation>
      </xs:element>
      <xs:element name="lifetime" minOccurs="0">
        <xs:annotation>
          <xs:documentation>
            Is used to specify the desired valid time range for which the token is valid to be used.
          </xs:documentation>
          <xs:appinfo>
            We will populate:
              /wst:RequestSecurityToken/wst:Lifetime/wsu:Created element = current_time - skew
              /wst:RequestSecurityToken/wst:Lifetime/wsu:Expires element = current_time + maxExpirationTime + skew
              
            On the response processing, I would generate a warning message if the expiration time is less than what we requested.
          </xs:appinfo>
        </xs:annotation>
        <xs:complexType>
          <xs:sequence>
            <xs:element name="skew" default="2">
              <xs:annotation>
                <xs:documentation>
                  Maximum time spread in seconds between the STS client(us), the STS and the target server clocks.
                  For example, if our clock is 5 seconds faster than the STS clock it could return s a token with an 
                  embedded time stamp that is not yet valid.
                </xs:documentation>
              </xs:annotation>
              <xs:simpleType>
                <xs:restriction base="xs:unsignedInt">
                  <xs:maxInclusive value="360">
                    <xs:annotation>
                      <xs:documentation>maximum allowed value is 6 minute = 360 seconds</xs:documentation>
                    </xs:annotation>
                  </xs:maxInclusive>
                </xs:restriction>
              </xs:simpleType>
            </xs:element>
            <xs:element name="maxExpirationTime" type="aaa:ExpirationLifetimeType">
              <xs:annotation>
                <xs:documentation>
                  Time in seconds that the requested token should be valid before it expires.
                  requested_expiration_time = current_time + skew + maximum_expiration_time.
                </xs:documentation>
              </xs:annotation>
            </xs:element>
          </xs:sequence>
        </xs:complexType>
      </xs:element>
      <xs:element name="clientEntropy" minOccurs="0">
        <xs:annotation>
          <xs:documentation>
            Allows a requestor to specify entropy that is to be used in creating the key. The value of this element SHOULD be either 
            a xenc:EncryptedKey or wst:BinarySecret element depending on whether or not the key is encrypted. Secrets SHOULD be encrypted 
            unless the transport/channel is already providing encryption.
            
            The size of the entropy should be based upon the type of symmetric key algorithm that will be utilited.
          </xs:documentation>
          <xs:appinfo>
            This is only utilized when some form of symmetric key algorithm is being utilized. We will generate a new random number for each token
            that we are requesting.  
            Note: we MAY need to restrict the random number string that we generate based upon the target algorithm. For example, both DES3-CBC and 
            AES-192 encryption algorithms have 24 byte keys. However, DES3 requires the most-significant bit of each byte enforces odd-parity.
          </xs:appinfo>
        </xs:annotation>
        <xs:complexType>
          <xs:sequence>
            <xs:element name="algorithmSuite" default="Basic256Rsa15">
              <xs:annotation>
                <xs:documentation>
                  Identifies the different alorithms to be used for digest[DIG], encryption{Enc], symmetric key wrap[Sym KW], asymmetric key wrap[Asym KW],
                  encryption key derivation[Enc KD], signature key derivation[Sig KD], minimum symmetric key length [Min SKL].
                  The following notation is based upon WS-Security Policy v1.3 standard.
                </xs:documentation>
              </xs:annotation>
              <xs:simpleType>
                <xs:restriction base="xs:string">
                  <xs:enumeration value="Basic256">
                    <xs:annotation>
                      <xs:documentation>
                        [Dig] Sha1, [Enc] Aes256, [Sym KW] KwAes256, [Asym KW] KwRsaOaep, [Enc KD] PSha1L256, [Sig KD] PSha1L192, [Min SKL] 256
                      </xs:documentation>
                      <!-- need to doublcheck that standard really intended to use PSha1L192 -->
                    </xs:annotation>
                  </xs:enumeration>
                  <xs:enumeration value="Basic192">
                    <xs:annotation>
                      <xs:documentation>
                        [Dig] Sha1, [Enc] Aes192, [Sym KW] KwAes192, [Asym KW] KwRsaOaep, [Enc KD] PSha1L192, [Sig KD] PSha1L192, [Min SKL] 192
                      </xs:documentation>
                    </xs:annotation>
                  </xs:enumeration>
                  <xs:enumeration value="Basic128">
                    <xs:annotation>
                      <xs:documentation>
                        [Dig] Sha1, [Enc] Aes128, [Sym KW] KwAes128, [Asym KW] KwRsaOaep, [Enc KD] PSha1L128, [Sig KD] PSha1L128, [Min SKL] 128
                      </xs:documentation>
                    </xs:annotation>
                  </xs:enumeration>
                  <xs:enumeration value="TripleDes">
                    <xs:annotation>
                      <xs:documentation>
                        [Dig] Sha1, [Enc] TripleDes, [Sym KW] KwTripleDes, [Asym KW] KwRsaOaep, [Enc KD] PSha1L192, [Sig KD] PSha1L192, [Min SKL] 192
                      </xs:documentation>
                    </xs:annotation>
                  </xs:enumeration>
                  <xs:enumeration value="Basic256Rsa15">
                    <xs:annotation>
                      <xs:documentation>
                        [Dig] Sha1, [Enc] Aes256, [Sym KW] KwAes256, [Asym KW] KwRsa15, [Enc KD] PSha1L256, [Sig KD] PSha1L192, [Min SKL] 256
                      </xs:documentation>
                      <!-- need to doublcheck that standard really intended to use PSha1L192 -->
                    </xs:annotation>
                  </xs:enumeration>
                  <xs:enumeration value="Basic192Rsa15">
                    <xs:annotation>
                      <xs:documentation>
                        [Dig] Sha1, [Enc] Aes192, [Sym KW] KwAes192, [Asym KW] KwRsa15, [Enc KD] PSha1L192, [Sig KD] PSha1L192, [Min SKL] 192
                      </xs:documentation>
                    </xs:annotation>
                  </xs:enumeration>
                  <xs:enumeration value="Basic128Rsa15">
                    <xs:annotation>
                      <xs:documentation>
                        [Dig] Sha1, [Enc] Aes128, [Sym KW] KwAes128, [Asym KW] KwRsa15, [Enc KD] PSha1L128, [Sig KD] PSha1L128, [Min SKL] 128
                      </xs:documentation>
                    </xs:annotation>
                  </xs:enumeration>
                  <xs:enumeration value="TripleDesRsa15">
                    <xs:annotation>
                      <xs:documentation>
                        [Dig] Sha1, [Enc] TripleDes, [Sym KW] KwTripleDes, [Asym KW] KwRsa15, [Enc KD] PSha1L192, [Sig KD] PSha1L192, [Min SKL] 192
                      </xs:documentation>
                    </xs:annotation>
                  </xs:enumeration>
                  <xs:enumeration value="Basic256Sha256">
                    <xs:annotation>
                      <xs:documentation>
                        [Dig] Sha256, [Enc] Aes256, [Sym KW] KwAes256, [Asym KW] KwRsaOaep, [Enc KD] PSha1L256, [Sig KD] PSha1L192, [Min SKL] 256
                      </xs:documentation>
                      <!-- need to doublcheck that standard really intended to use PSha1L192 -->
                    </xs:annotation>
                  </xs:enumeration>
                  <xs:enumeration value="Basic192Sha256">
                    <xs:annotation>
                      <xs:documentation>
                        [Dig] Sha256, [Enc] Aes192, [Sym KW] KwAes192, [Asym KW] KwRsaOaep, [Enc KD] PSha1L192, [Sig KD] PSha1L192, [Min SKL] 192
                      </xs:documentation>
                    </xs:annotation>
                  </xs:enumeration>
                  <xs:enumeration value="Basic128Sha256">
                    <xs:annotation>
                      <xs:documentation>
                        [Dig] Sha256, [Enc] Aes128, [Sym KW] KwAes128, [Asym KW] KwRsaOaep, [Enc KD] PSha1L128, [Sig KD] PSha1L128, [Min SKL] 128
                      </xs:documentation>
                    </xs:annotation>
                  </xs:enumeration>
                  <xs:enumeration value="TripleDesSha256">
                    <xs:annotation>
                      <xs:documentation>
                        [Dig] Sha256, [Enc] TripleDes, [Sym KW] KwTripleDes, [Asym KW] KwRsaOaep, [Enc KD] PSha1L192, [Sig KD] PSha1L192, [Min SKL] 192
                      </xs:documentation>
                    </xs:annotation>
                  </xs:enumeration>
                  <xs:enumeration value="Basic256Sha256Rsa15">
                    <xs:annotation>
                      <xs:documentation>
                        [Dig] Sha256, [Enc] Aes256, [Sym KW] KwAes256, [Asym KW] KwRsa15, [Enc KD] PSha1L256, [Sig KD] PSha1L192, [Min SKL] 256
                      </xs:documentation>
                      <!-- need to doublcheck that standard really intended to use PSha1L192 -->
                    </xs:annotation>
                  </xs:enumeration>
                  <xs:enumeration value="Basic192Sha256Rsa15">
                    <xs:annotation>
                      <xs:documentation>
                        [Dig] Sha256, [Enc] Aes192, [Sym KW] KwAes192, [Asym KW] KwRsa15, [Enc KD] PSha1L192, [Sig KD] PSha1L192, [Min SKL] 192
                      </xs:documentation>
                    </xs:annotation>
                  </xs:enumeration>
                  <xs:enumeration value="Basic128Sha256Rsa15">
                    <xs:annotation>
                      <xs:documentation>
                        [Dig] Sha256, [Enc] Aes128, [Sym KW] KwAes128, [Asym KW] KwRsa15, [Enc KD] PSha1L128, [Sig KD] PSha1L128, [Min SKL] 128
                      </xs:documentation>
                    </xs:annotation>
                  </xs:enumeration>
                  <xs:enumeration value="TripleDesSha256Rsa15">
                    <xs:annotation>
                      <xs:documentation>
                        [Dig] Sha256, [Enc] TripleDes, [Sym KW] KwTripleDes, [Asym KW] KwRsa15, [Enc KD] PSha1L192, [Sig KD] PSha1L192, [Min SKL] 192
                      </xs:documentation>
                    </xs:annotation>
                  </xs:enumeration>
                </xs:restriction>
              </xs:simpleType>
            </xs:element>
            <xs:element name="requireServerEntropy" type="xs:boolean" default="false" minOccurs="0">
              <xs:annotation>
                <xs:documentation>
                  Indicates that STS is required to populate their response with a /wst:RequestSecurityTokenResponse/wst:Entropy element.
                  This optional element allows an issuer to specify entropy that is to be used in creating the key. The value of this element 
                  should be either a xenc:EncryptedKey or wst:BinarySecret depending on whether or not the key is encrypted (it should be unless 
                  the transport/channel is already encrypted).
                </xs:documentation>
              </xs:annotation>
            </xs:element>
          </xs:sequence>
        </xs:complexType>
      </xs:element>
      <xs:element name="wsSecurityPolicyGroup" type="xs:string" minOccurs="0">
        <xs:annotation>
          <xs:documentation>
            Optional WS-Security Policy Group that is to be applied to the exchange with the STS.
          </xs:documentation>
          <xs:appinfo>A WS-Security Group identifies the WS-Security processing for both the request and response legs.</xs:appinfo>
        </xs:annotation>
        <!-- constraint: name specified must match a WS-Security Group policy known to SD associated with this application -->
      </xs:element>
      <xs:element name="clientAuthenticationMethod" minOccurs="0">
        <xs:annotation>
          <xs:documentation>This informaton is used to authenticate the client (us) to the STS.</xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:sequence>
            <xs:element name="mechanism" default="Use_WS-Security_Policy_Group">
              <xs:simpleType>
                <xs:restriction base="xs:string">
                  <xs:enumeration value="Use_WS-Security_Policy_Group">
                    <xs:annotation>
                      <xs:documentation>
                        This option implies a number of things:
                        1) There is a WS-Security signature operation in the associated WS-Security Policy Group
                        2) This signature operation uses the security token reference for KeyInfo that populated by the create-rst extension function.
                      </xs:documentation>
                    </xs:annotation>
                    <!-- constraint: wsSecurityPolicyGroup element MUST be specified with a signature operation within it -->
                  </xs:enumeration>
                  <xs:enumeration value="Use_SSL/TLS">
                    <!-- constraint: 1) If serverUrl specified then the URL specified must begin with https:// 
                                     2) If NO serverUrl is specified then a deploy time test must check that https:// is specified.
                    -->
                  </xs:enumeration>
                </xs:restriction>
              </xs:simpleType>
            </xs:element>
            <xs:element name="expectedTokenType" default="BST" minOccurs="0">
              <xs:annotation>
                <xs:documentation>
                  Identifies the token from the WS-Security header to be reference from the wst:UseKey element in the STS request.
                </xs:documentation>
              </xs:annotation>
              <!-- constraint: 1) MUST be POPULATED if mechanism is Use_WS-Security_Policy_Group
                               2) The type of token utilized by the signature operation must match. 
                                  a) If ((ClientAuthenticationMethod ExpectedTokenType == BST) AND (ds:Signature KeyInfo == X.509 [OR Kerberos])) then OK else ERROR
                                  b) If ((ClientAuthenticationMethod ExpectedTokenType == Username/Password) AND (ds:Signature KeyInfo == username token)) then OK else ERROR
                                  c) If ((ClientAuthenticationMethod ExpectedTokenType == Saml_Assertion) AND (SAML assertion with holder-of-key confirmation method)) 
                                     then OK
                                     else if ((ClientAuthenticationMethod ExpectedTokenType == Saml_Assertion) AND (SAML assertion)) 
                                          then WARNING that signature not directly bound to token 
                                          else ERROR
              -->
              <xs:simpleType>
                <xs:restriction base="xs:string">
                  <xs:enumeration value="BST">
                    <xs:annotation>
                      <xs:documentation>
                        Use Binary Security Token (BST) in the SOAP Header-&gt;WS_Security Header.
                        BST could be X.509 certificates, Kerberos tokens, CA Paths, PKCS11 bag, etc.
                        We will only support X.509 certificates at this time.
                        
                        Normally this token will also be utilized by a WS-Security signature specified in the wsSecurityPolicyGroup 
                        that is used to sign the message body and security token.
                      </xs:documentation>
                    </xs:annotation>
                  </xs:enumeration>
                  <xs:enumeration value="Username/Password">
                    <xs:annotation>
                      <xs:documentation>
                        A username/password token in PasswordText format.
                        Because the password is in the clear, either the associated wsSecurityPolicyGroup must encrypt the username token
                        or SSL/TLS transport layer security is utilized to encrypt the data in flight.
                      </xs:documentation>
                    </xs:annotation>
                  </xs:enumeration>
                  <xs:enumeration value="Saml_Assertion"/>
                </xs:restriction>
              </xs:simpleType>
            </xs:element>
            <xs:element name="source" minOccurs="0">
              <xs:annotation>
                <xs:documentation>Identifies where the key material will come from</xs:documentation>
              </xs:annotation>
              <xs:complexType>
                <xs:choice>
                  <xs:element name="useExtractedIdentity" type="aaa:InternalExtractedToken">
                    <xs:annotation>
                      <xs:documentation>Indicates that we are to utilize the username and password identified by the AAA extract identity step</xs:documentation>
                    </xs:annotation>
                    <!-- constraint: 1) ALLOWED if (((extracted identity == (usernameFromHttpBasicAuthentication | usernameFromSecurityHeader |
                                                                             usernamePasswordFromWorkflow
                                                                            ) OR
                                                     ((extracted identity == DerivedUsernameFromSecurityHeader) AND
                                                      (authenticate identity == (keystore | ldapAuthentication))
                                                     )
                                                    ) AND
                                                    (ClientExpectedTokenType == Username/Password)
                                                   )
                                     2) ALLOWED if ((extracted identity is (certificateFromPeerSsl | x509CertificateFromSecurityHeader | 
                                                                            x509certificateFromWorkflow | bstFromVerifyOperation
                                                                           ) 
                                                    ) AND
                                                    (ClientExpectedTokenType == BST)
                                                   )
                                     3) ALLOWED if ((extracted identity is (nameFromSamlAttribute | nameFromSamlAuthentication | nameFromSamlSubject) 
                                                    ) AND
                                                    (ClientExpectedTokenType == Saml_Assertion)
                                                   )
                    -->
                  </xs:element>
                  <xs:element name="usernameFromSecurityConfig" type="aaa:SecurityPackageHandle">
                    <xs:annotation>
                      <xs:documentation>
                        Using username security object defined in application related security config package.
                        This allows application to hardcore the username and password to populate the username token to be used.
                      </xs:documentation>
                    </xs:annotation>
                    <!-- constraint: ONLY ALLOWED if (ClientExpectedTokenType == Username/Password) -->
                  </xs:element>
                  <xs:element name="usernameFromWorkflow" type="aaa:TokenFromWorkflowType">
                    <!-- constraint: service designer action builder must prompt developer to identify:
                          1) username: from current workflow variable when this AAA policy is bound to a workflow action.
                          2) password: from current workflow variable when this AAA policy is bound to a workflow action.
                    -->
                    <!-- constraint: 1) if identity extraction method is (usernameFromHttpBasicAuthentication | usernameFromSecurityHeader | 
                                        usernamePasswordFromWorkflow) then generate WARNING that username/password also available from extract 
                                        identity step
                                     2) ONLY ALLOWED if (ClientExpectedTokenType == Username/Password)
                    -->
                  </xs:element>
                  <xs:element name="certificateFromSecurityConfig" type="aaa:SecurityPackageHandle">
                    <xs:annotation>
                      <xs:documentation>
                        Using username security object defined in application related security config package.
                        This allows application to hardcore the certificate token to be used.
                      </xs:documentation>
                    </xs:annotation>
                    <!-- constraint: ONLY ALLOWED if (ClientExpectedTokenType == BST) -->
                  </xs:element>
                  <xs:element name="bstFromWorkflow" type="aaa:TokenFromWorkflowType">
                    <!-- constraint: service designer action builder must prompt the developer for a certificate in base64 DER or PEM format. -->
                    <!-- constraint: ONLY ALLOWED if (ClientExpectedTokenType == BST) -->
                  </xs:element>
                  <xs:element name="samlAssertionFromWorkflow" type="aaa:TokenFromWorkflowType">
                    <!-- constraint: service designer action builder must prompt the developer for a SAML assertion -->
                  </xs:element>
                </xs:choice>
              </xs:complexType>
              <!-- constraint: ONLY ALLOWED if (ClientExpectedTokenType == Saml_Assertion) -->
              <!-- constraint: 1) There is an implied SD cross check between the token type and the actual token information being used by the signature 
                                  operation within the associated WS-Security Policy Group.
                               2) There is an implied operational check that the same token information is used in the signature operation and within the
                                  WS-Trust request.
              -->
            </xs:element>
          </xs:sequence>
        </xs:complexType>
      </xs:element>
      <xs:element name="proofToken" minOccurs="0">
        <xs:annotation>
          <xs:documentation>
            A security token that contains secret data that can be used to demonstrate authorized use of an associated security token. 
            Typically, although not exclusively, the proof-of-possession information is encrypted with a key known only to the recipient 
            of the Proof-Of-Possession token.
            One way to demonstrate authorized use of a security token is to include a digital signature using the associated secret key 
            (from a proof-of-possession token). This allows a requestor to prove a required set of claims by associating security tokens 
            (e.g., PKIX, X.509 certificates) with the messages.
          </xs:documentation>
          <xs:appinfo>
            If not present/populated then no wst:KeyType should be populated in the wst:RequestSecurityToken element.
            Note: the wst:KeyType element will not be populated if proofType is symmetric-key.
          </xs:appinfo>
        </xs:annotation>
        <xs:complexType>
          <xs:sequence>
            <xs:element name="proofType" default="bearer">
              <xs:annotation>
                <xs:documentation>On the RST request, the wst:KeyType element carries the type of proof key.</xs:documentation>
              </xs:annotation>
              <!-- open issue: should symmetric-key be the default??? -->
              <xs:simpleType>
                <xs:restriction base="xs:string">
                  <xs:enumeration value="public-key">
                    <xs:annotation>
                      <xs:documentation>
                        A public key token is requested. This value is used for both X.509 certificate and X.509 public key
                      </xs:documentation>
                      <xs:appinfo>http://docs.oasis-open.org/ws-sx/ws-trust/200512/PublicKey</xs:appinfo>
                    </xs:annotation>
                  </xs:enumeration>
                  <xs:enumeration value="bearer">
                    <xs:annotation>
                      <xs:appinfo>http://docs.oasis-open.org/ws-sx/wstrust/200512/Bearer</xs:appinfo>
                      <xs:documentation>
                        A bearer token is requested. This key type can be used by requestors to indicate that they want a security token to be 
                        issued that does not require proof of possession, e.g., a SAML ssertion.
                      </xs:documentation>
                    </xs:annotation>
                    <!-- constraint: ONLY ALLOWED if tokenType = (SAML-v2.0 | SAML-v1.1) -->
                  </xs:enumeration>
                  <xs:enumeration value="symmetric key">
                    <xs:annotation>
                      <xs:appinfo>Deferred! http://docs.oasis-open.org/ws-sx/ws-trust/200512/SymmetricKey</xs:appinfo>
                      <xs:documentation>
                        A symmetric key token is requested. This is currently only utilized when WS-Secure Conversation is being used.
                      </xs:documentation>
                      <xs:appinfo>
                        When this option is selected a wst:KeyType element is NOT generated. Instead, other elements within the 
                        wst:RequestSecurityToken element such as wst:ComputedKeyAlgorithm, wst:KeySize, etc. will be used.
                      </xs:appinfo>
                    </xs:annotation>
                  </xs:enumeration>
                </xs:restriction>
              </xs:simpleType>
              <!-- constraint: if (proofType is NOT populated) 
                               then WARNING "Token type under Advanced Generate a proof token has not been populated. MS ADFS 
                                             implementation requires it to be populated and consistent with Token type to 
                                             request, i.e. SAML-v1.1 or SAML-v2.0 implies bearer"
              -->
            </xs:element>
            <xs:element name="source" minOccurs="0">
              <xs:complexType>
                <xs:choice>
                  <xs:element name="certificateFromSecurityConfig" type="aaa:SecurityPackageHandle">
                    <xs:annotation>
                      <xs:documentation>
                        Using username security object defined in application related security config package.
                        This allows application to hardcore the certificate token to be created.
                      </xs:documentation>
                    </xs:annotation>
                    <!-- constraint: handle specified must match certificate object in associated security config -->
                    <!-- constraint: 1) Only Present if (proofType == public-key) 
                                     2) if (useForSignature == true) then WARNING "there is already a token available via associated signature" 
                    -->
                  </xs:element>
                  <xs:element name="bstFromWorkflow" type="aaa:TokenFromWorkflowType">
                    <!-- constraint: service designer action builder must prompt the developer for a X.509 Binary Security Token (BST)-->
                    <!-- constraint: 1) Only Present if (proofType == public-key)
                                     2) Only ALLOWED if (useForSignature == false)
                    -->
                  </xs:element>
                  <xs:element name="SamlAssertionFromWorkflow" type="aaa:TokenFromWorkflowType">
                    <!-- constraint: service designer action builder must prompt the developer for a SAML assertion-->
                    <!-- constraint: 1) Only Present if (proofType == bearer) -->
                  </xs:element>
                  <xs:element name="publicKeyFromWorkflow" type="aaa:TokenFromWorkflowType">
                    <xs:annotation>
                      <xs:appinfo>Deferred</xs:appinfo>
                    </xs:annotation>
                    <!-- constraint: service designer action builder must prompt the developer for a ds:RSAKeyValue element containing
                                     both the ds:Modulus and ds:Exponent elements
                    -->
                    <!-- constraint: 1) Only Present if (proofType == public-key) 
                                     2) Only ALLOWED if (useForSignature == false)
                    -->
                  </xs:element>
                  <xs:element name="symmetricKeyFromSecurityConfig" type="aaa:SecurityPackageHandle">
                    <xs:annotation>
                      <xs:documentation>
                        Using username security object defined in application related security config package.
                        This allows application to hardcore the certificate token to be created.
                      </xs:documentation>
                      <xs:appinfo>Deferred</xs:appinfo>
                    </xs:annotation>
                    <!-- constraint: handle specified must match symmetric key object in associated security config -->
                    <!-- constraint: 1) Only Present if (proofType == symmetric-key) -->
                  </xs:element>
                </xs:choice>
              </xs:complexType>
            </xs:element>
            <xs:element name="useForSignature" type="xs:boolean" minOccurs="0">
              <xs:annotation>
                <xs:documentation>
                  Controls where the KeyInfo specified by the source will be populated.
                  If useForSignature is false then the KeyInfo will reside within the wst:UseKey element of the wst:RequestSecurityToken element.
                  If useForSignature is true then the KeyInfo will reside within BinarySecurityToken within a SecurityTokenReference (STR). This 
                  STR will eventually reside within the WS-Security Header within the SOAP header.
                </xs:documentation>
                <xs:appinfo>
                  1) If ((proofToken == public-key) AND (useForSignature == false) AND (clientAuthenticationMethod NOT populated))
                     then {
                        token can be populated in either UseKey element within RST or 
                                               in WS-Security header as STR with reference via UseKey sig attribute
                     }
                  2) if ((clientAuthenticationMethod populated) OR (useForSignature == true))
                     then only populate KeyType because there should already be a UseKey element populated.
                </xs:appinfo>
              </xs:annotation>
              <!-- constraint: 
                   1) ONLY PRESENT if proofToken == public-key)
                   2) If ((proofToken == public-key) AND (useForSignature == true) AND 
                          (clientAuthenticationMethod mechanism == use_WS-Security-Policy-Group) AND 
                          (clientAuthenticationMethod expectedTokenType == BST) 
                         )
                      then {
                          WS-Security Policy Group signature operation token type MUST be X.509;
                          X.509 certificate ProofTokenSource same as Signature X.509 key pair certificate;
                          Signature KeyInfo format == usingExistingBST
                      }
                   3) If ((proofToken == public-key) AND (useForSignature == false) AND 
                          ((clientAuthenticationMethod NOT populated)) OR ((clientAuthenticationMethod mechanism == Use_SSL/TLS))
                         )
                      then generate INFO/WARNING that the proof token is normally used to sign request: clientAuthenticationMethod mechanism == Use_WS-Security_Policy_Group.
              -->
            </xs:element>
          </xs:sequence>
        </xs:complexType>
      </xs:element>
      <xs:element name="onBehalfOf" minOccurs="0">
        <xs:annotation>
          <xs:documentation>
            In some scenarios the requestor is obtaining a token on behalf of another party. The following parameters specify the issuer
            and original requestor of the token being used as the basis of the request.
            
            The wst:OnBehalfOf element indicates that the requestor is making the request on behalf of another. The identity on whose 
            behalf the request is being made is specified by placing a security token, wsse:SecurityTokenReference element, or 
            wsa:EndpointReference element within the wst:OnBehalfOf element. The requestor may provide proof of possession of the key associated 
            with the OnBehalfOf identity by including a signature in the RST security header generated using the OnBehalfOf token that signs 
            the primary signature of the RST (i.e. endorsing supporting token concept from WS-SecurityPolicy). Additional signed supporting 
            tokens describing the OnBehalfOf context may also be included within the RST security header.
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:choice>
            <xs:element name="endpointReference" type="aaa:SamlUri">
              <xs:annotation>
                <xs:documentation>Being secured for a requestor associated with a specific WS-Security Addressing (WSA) endpoint URL</xs:documentation>
              </xs:annotation>
            </xs:element>
            <xs:element name="securityToken">
              <xs:annotation>
                <xs:documentation>Being secured for a requestor associated with the specified security token</xs:documentation>
              </xs:annotation>
              <xs:complexType>
                <xs:sequence>
                  <xs:choice>
                    <xs:element name="x509">
                      <xs:complexType>
                        <xs:choice>
                          <xs:element name="securityConfig" type="aaa:SecurityPackageHandle">
                            <xs:annotation>
                              <xs:documentation>
                                Allows the application to identify the certificate token from the associated security config.
                              </xs:documentation>
                            </xs:annotation>
                            <!-- constraint: specified certificate object handle MUST exist within application security config  -->
                          </xs:element>
                          <xs:element name="fromWorkflow" type="aaa:TokenFromWorkflowType">
                            <!-- constraint: service designer action build MUST prompt developer for workflow variable containing either X.509 base64 
                                             DER certificate or PEM encoded certifcate 
                            -->
                          </xs:element>
                        </xs:choice>
                      </xs:complexType>
                    </xs:element>
                    <xs:element name="username">
                      <xs:annotation>
                        <xs:appinfo>
                          Note: only the username needs to be populated in the username token being generated. The OPTIONAL password element within the 
                          username token does NOT need to be populated for this usage.
                        </xs:appinfo>
                      </xs:annotation>
                      <xs:complexType>
                        <xs:choice>
                          <xs:element name="securityConfig" type="aaa:SecurityPackageHandle">
                            <xs:annotation>
                              <xs:documentation>
                                Allows the application to identify the username token from the associated security config.
                              </xs:documentation>
                            </xs:annotation>
                            <!-- constraint: specified username/password object handle MUST exist within application security config  -->
                          </xs:element>
                          <xs:element name="fromWorkflow" type="aaa:TokenFromWorkflowType">
                            <!-- constraint: service designer action build MUST prompt developer for workflow variable containing the username -->
                          </xs:element>
                        </xs:choice>
                      </xs:complexType>
                    </xs:element>
                  </xs:choice>
                  <!-- deferred
                  <xs:element name="useSTR" type="xs:boolean" minOccurs="1" maxOccurs="1">
                    <xs:annotation>
                      <xs:appinfo>Need to resolve how we want to handle the need to potentially create and reference two different STRs</xs:appinfo>
                    </xs:annotation>
                  </xs:element>
                  -->
                </xs:sequence>
              </xs:complexType>
            </xs:element>
            <xs:element name="useExtractedUsername" type="aaa:InternalExtractedToken">
              <xs:annotation>
                <xs:documentation>Indicates that we are to utilize the username identified by the AAA extract identity step</xs:documentation>
              </xs:annotation>
              <!-- constraint: 1) ONLY ALLOWED if (extracted identity is (usernameFromHttpBasicAuthentication OR usernameFromSecurityHeader OR
                                                                          usernamePasswordFromWorkflow OR derivedUsernameFromSecurityHeader
                                                                         )
                                                  )
              -->
            </xs:element>
            <xs:element name="useExtractedUsernamePassword" type="aaa:InternalExtractedToken">
              <xs:annotation>
                <xs:documentation>Indicates that we are to utilize the username and password identified by the AAA extract identity step</xs:documentation>
              </xs:annotation>
              <!-- constraint: 1) ONLY ALLOWED if ((extracted identity is (usernameFromHttpBasicAuthentication OR usernameFromSecurityHeader OR
                                                                           usernamePasswordFromWorkflow
                                                                          ) OR
                                                   ((extracted identity is derivedUsernameFromSecurityHeader) AND 
                                                    (authentication mechanism is (LDAP OR keystore)
                                                   )
                                                  )
              -->
            </xs:element>
          </xs:choice>
        </xs:complexType>
      </xs:element>
      <xs:element name="toFieldPopulation" type="xs:boolean" default="true">
        <xs:annotation>
          <xs:documentation>
            Controls if the WS-Addressing To element within the SOAP Header should be populated based upon the partnerLink value.
          </xs:documentation>
          <xs:appinfo>
            Based upon what Alexander learns: SD action builder will automatically pick-up this information from the partnerLink or
            prompt the application developer to supply this information when the policy is bound to an action.
          </xs:appinfo>
        </xs:annotation>
      </xs:element>
      <xs:element name="serverUrl" type="xs:anyURI" minOccurs="0">
        <xs:annotation>
          <xs:documentation>
            For a WS-Trust server (STS), its URL is composed of three components:
            1) host name
            2) port number
            3) optional path
          </xs:documentation>
          <xs:appinfo>
            Service Designer policy editor should combine these three separately specified components into a single URL, 
            e.g., http://64.109.190.124:443/adf/ls
          </xs:appinfo>
        </xs:annotation>
      </xs:element>
      <xs:element name="authenticationType" type="aaa:AuthenticationMethodType" minOccurs="0">
        <xs:annotation>
          <xs:appinfo>Advanced - deferrable</xs:appinfo>
          <xs:documentation>
            This element indicates the type of authentication desired. It is specified as a URI. 
            This specification does not predefine classifications; these are specific to the token services.
            The relative strength of the authentication type is up to the recipient to determine. 
            Therefore, the requestors should be familiar with the recipient policies. 
            For example, this might be used to indicate which of the four U.S. government authentication levels is required.
            
            All this being said, in actual usage all I could find was the use of the SAML Authentication Method URI values.
          </xs:documentation>
        </xs:annotation>
      </xs:element>
      <!-- Note: Future work to add hooks for other RSTS elements such as SignatureAlgorithm, EncryptionAlgorithm, CanonicalizationAlgorithm, 
                 ComputedKeyAlgorithm, Encryption, ProofEncryption, KeyWrapAlgorithm, SignWith and EncryptWith elements. Note: I believe that 
                 the actual values can be derived from the clientEntropy algorithm suite selected for several of the preceding elements.
      -->
      <xs:element name="outputBindingInfo" type="aaa:OutputBindingInfoForExternalCreation" minOccurs="0">
        <!-- constraint: 1) ONLY ALLOWED if (tokenType == SAML-v2.0 OR SAML-v1.1 OR Inferred) 
                         2) a) ONLY ALLOWED if (WsTrustAuthentication is being referenced from mapIdentity)
                            b) NOT ALLOWED if (WsTrustAuthentication is being referenced from authenticateIdentity)
        -->
      </xs:element>
    </xs:sequence>
  </xs:complexType>
  <xs:complexType name="InternalExtractedToken">
    <xs:annotation>
      <xs:appinfo>
        These elements are only for internal usage! They are not intended to be user views.
        These elements are use to pass an extracted token into the create-rst extension function where they can be mapped 
        to the appropriate RST element.
        In particular, can be used to pass:
        1) username and password
        2) username only
        3) full certificate
        4) full SAML assertion
      </xs:appinfo>
    </xs:annotation>
    <xs:choice>
      <xs:sequence>
        <xs:element name="usernameInternalName" type="xs:string" fixed="int:extractedIdentityUsername"/>
        <xs:element name="passwordInternalName" type="xs:string" fixed="int:extractedIdentityPassword" minOccurs="0"/>
      </xs:sequence>
      <xs:element name="FullCertificateInternalName" type="xs:string" fixed="int:extractedIdentityFullCertificate"/>
      <xs:element name="samlAssertionInternalName" type="xs:string" fixed="int:extractedIdentitySamlAssertion">
        <!-- constraint: ONLY ALLOWED if 
        -->
      </xs:element>
    </xs:choice>
  </xs:complexType>
  <xs:complexType name="SsoChoices">
    <xs:annotation>
      <xs:documentation>Single Sign On (SSO) Options</xs:documentation>
    </xs:annotation>
    <xs:choice>
      <xs:element name="returnSsoToken" type="xs:boolean" default="false">
        <xs:annotation>
          <xs:documentation>
            Action Builder needs to indicate that SSO token should be returned from Oracle Access Manager or SiteMinder IA.
            The returned SSO token should be available to application via a Get Security Metadata action.
          </xs:documentation>
        </xs:annotation>
        <!-- constraint: NOT ALLOWED when extract identity is ssoFromCookie or ssoFromWorkflow -->
        <!-- constraint: only ALLOWED when extracted identity is usernameFromSecurityHeader, usernameFromHttpBasicAuthentication or usernameFromWorkflow -->
        <!-- constraint: returnSsoToken can only be specified true in either authentication or authorization usage but NOT in both. -->
      </xs:element>
      <xs:element name="terminateSession" type="xs:boolean" default="false">
        <xs:annotation>
          <xs:documentation>
            Indicates if the associated session will be terminated, i.e., SSO token be revoked from future usage.
          </xs:documentation>
        </xs:annotation>
        <!-- constraint: ONLY ALLOWED when extract identity is ssoFromCookie or ssoFromWorkflow -->
        <!-- constraint: NOT ALLOWED to be set in authentication mechanism if ((extracted identity is ssoFromCookie or ssoFromWorkflow) AND 
                         (use[OracleAccessManager | SiteMinder]AuthenticationParametrizations != TRUE)).
                         Note: this is because there would be no SSO token active for authorization processing. When useXxxAuthenticationParametrizations
                         is TRUE, there is no actual authentication step generated.
        -->
      </xs:element>
    </xs:choice>
  </xs:complexType>
  <xs:simpleType name="OAuthClientCredentialSourceType">
    <xs:restriction base="xs:string">
      <xs:annotation>
        <xs:documentation>Identifies where we should look for the client credentials</xs:documentation>
      </xs:annotation>
      <xs:enumeration value="HttpBasicAuthorization">
        <xs:annotation>
          <xs:documentation>
            Recommend mechanism for client to authenticate with authorization server,
            e.g., Authorization: Basic czZCaGRSa3F0MzpnWDFmQmF0M2JW
          </xs:documentation>
        </xs:annotation>
        <!-- constraint: 1) ONLY ALLOWED if ((flowType == (ClientCredentials OR ResourceOwnerPasswordCredentials OR
                                                           ResourceOwnerSamlAssertionCredentials OR RefreshToken
                                                          )
                                             ) OR
                                             ((flowType == AuthorizationCode) AND 
                                              (authorizationCodeRequestType ==accessTokenRequest)
                                             )
                                            )
        -->
      </xs:enumeration>
      <xs:enumeration value="RequestBody">
        <xs:annotation>
          <xs:documentation>
            Client name and password package in client_id and client_secret fields within body.
            Including the client credentials in the request body using the two parameters is NOT RECOMMENDED, 
            and should be limited to clients unable to directly utilize the HTTP Basic authentication scheme,
            e.g., POST /token HTTP/1.1
                  Host: server.example.com
                  Content-Type: application/x-www-form-urlencoded;charset=UTF-8
                  
                    grant_type=client_credentials&amp;client_id=s6BhdRkqt3&amp;client_secret=7Fjfp0ZBr1KtDRbnfVdmIw
          </xs:documentation>
        </xs:annotation>
        <!-- constraint: 1) ONLY ALLOWED if ((flowType == (ClientCredentials OR ResourceOwnerPasswordCredentials OR
                                                           ResourceOwnerSamlAssertionCredentials OR RefreshToken
                                                          )
                                             ) OR
                                             ((flowType == AuthorizationCode) AND 
                                              (authorizationCodeRequestType ==accessTokenRequest)
                                             )
                                            )
                         2) Generate a warning message when this option is selected that this is not recommended 
                            and are you sure that this mechanism is what you intended to utilize.
        -->
        <!-- Open issue: We need to verify the Context-Type value. I believe we can get at this from either the
                         incoming message metadata or from the workflow, i.e., we could also prompt for it.
                         Talk over with Alexander/Jingfeng.
        -->
      </xs:enumeration>
      <xs:enumeration value="SamlAssertion">
        <xs:annotation>
          <xs:documentation>
            SAML v2.0 Bearer assertion is use for Client Authentication.
            The value of "client_assertion_type" parameter MUST be
            "urn:ietf:params:oauth:grant-type:saml2-bearer".
            The value of the "client_assertion" parameter MUST contain a single SAML 2.0 Assertion. 
            The SAML Assertion XML data MUST be encoded using base64url, where the encoding adheres to 
            the definition in Section 5 of RFC4648 [RFC4648] and where the padding bits are set to zero. 
            To avoid the need for subsequent encoding steps (by "application/x-www-form-urlencoded"
            [W3C.REC-html401-19991224], for example), the base64url encoded data SHOULD NOT be line 
            wrapped and pad characters ("=") SHOULD NOT be included.
            
            For example:
              POST /token.oauth2 HTTP/1.1
              Host: authz.example.net
              Content-Type: application/x-www-form-urlencoded
              
              client_assertion_type=urn%3Aietf%3Aparams%3Aoauth%3Agrant-type%3Asaml2-bearer
              &amp;client_assertion=eyHXmms[...omitted for brevity...]eidjnDFSDklsMsmcdslALcpb24-
          </xs:documentation>
          <!-- constraint: 1) ONLY ALLOWED if ((flowType == (ClientCredentials OR ResourceOwnerPasswordCredentials OR
                                                             ResourceOwnerSamlAssertionCredentials OR RefreshToken
                                                            )
                                               ) OR
                                               ((flowType == AuthorizationCode) AND 
                                                (authorizationCodeRequestType ==accessTokenRequest)
                                               )
                                              )
          -->
          <!-- Issue: We need to verify the Context-Type value. This is checked in the REST endpoint configuration policy
                      and in WSDL.
               Open Issue: how do we enforce the different policies have all been consistency set-up. Future.
          -->
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="clientIdFromOAuthRequest">
        <xs:annotation>
          <xs:documentation>
            client_id name is coming from OAuth HTTP request body parameter.
            
            If Implicit Grant then client_id parameter, e.g.,
              GET /authorize?response_type=token&amp;client_id=s6BhdRkqt3&amp;state=xyz
                            &amp;redirect_uri=https%3A%2F%2Fclient%2Eexample%2Ecom%2Fcb HTTP/1.1
              Host: server.example.com
              
            If Authorization Code flow on a grant request then client_id parameter, e.g.,
              GET /authorize?response_type=code&amp;client_id=s6BhdRkqt3&amp;state=xyz
                            &amp;redirect_uri=https%3A%2F%2Fclient%2Eexample%2Ecom%2Fcb HTTP/1.1
              Host: server.example.com
          </xs:documentation>
        </xs:annotation>
        <!-- constraint: ONLY ALLOWED if ((flowType == ImplicitGrant) OR
                                          ((flowType == AuthorizationCode) AND (authorizationCodeRequestType == grantRequest))
                                         )
        -->
      </xs:enumeration>
      <xs:enumeration value="no-credentials">
        <!-- deferred this functionality to some future release, i.e., hide in Service Designer policy editor -->
        <!-- constraint: 1) ONLY ALLOWED if ((flowType == (ResourceOwnerPasswordCredentials OR RefreshToken OR
                                                           ResourceOwnerSameAssertionCredentials OR ClientCredentials
                                                          )
                                             ) OR
                                             ((flowType == AuthorizationCode) AND (authorizationCodeRequestType == accessTokenRequest))
                                            )
                         2) WARNING "This is legal but unusual to be supporting public clients, i.e., clients without any registration
                                     information"
                            if (OAuthClientCredentialSourceType == no-credentials)
        -->
      </xs:enumeration>
      <!-- constraint: ONLY PRESENT if (roleBeingChecked == client) -->
    </xs:restriction>
  </xs:simpleType>
  <xs:complexType name="MapIdentity">
    <xs:annotation>
      <xs:documentation>
        Define how the extracted Identity will be mapped to a different type of credential.
      </xs:documentation>
    </xs:annotation>
    <xs:choice>
      <xs:element name="createUsernameToken" type="aaa:CreateUsernameToken">
        <!-- constraint: 1) NOT PRESENT if ((extractedIdentity == nameFromOAuthAuthorizationRequest) AND
                                            (flowType == AuthorizationCode) AND
                                            (authorizationCodeRequestType == grantRequest) AND
                                            (roleBeingChecked == resourceOwner)
                                           )
                         2) NOT PRESENT if ((extractedIdentity == nameFromOAuthAuthorizationRequest) AND
                                            (flowType == (AuthorizationCode OR RefreshToken OR ClientCredential OR
                                                          ImplicitGrant OR ResourceOwnerPasswordCredential OR
                                                          ResourceOwnerSamlAssertionCredential
                                                         ) AND
                                            (authorizationCodeRequestType == accessTokenRequest)
                                           )
        -->
      </xs:element>
      <xs:element name="createSamlAssertion" type="aaa:CreateSamlAssertion">
        <!-- constraint: 1) NOT PRESENT if ((extractedIdentity == nameFromOAuthAuthorizationRequest) AND
                                            (flowType == AuthorizationCode) AND
                                            (authorizationCodeRequestType == grantRequest) AND
                                            (roleBeingChecked == resourceOwner)
                                           )
                         2) NOT PRESENT if ((extractedIdentity == nameFromOAuthAuthorizationRequest) AND
                                            (flowType == (AuthorizationCode OR RefreshToken OR ClientCredential OR
                                                          ImplicitGrant OR ResourceOwnerPasswordCredential OR
                                                          ResourceOwnerSamlAssertionCredential
                                                         ) AND
                                            (authorizationCodeRequestType == accessTokenRequest)
                                           )
                            Note: in theory could use a SAML Assertion as an access token but not being done in practice.
        -->
      </xs:element>
      <xs:element name="createOAuthGrant" type="aaa:CreateOAuthGrant">
        <!-- constraint: PRESENT AND POPULATED if ((extracted identity == nameFromOAuthAuthorizationRequest) AND
                                                   (flowType == AuthorizationCode) AND
                                                   (authorizationCodeRequestType == grantRequest) AND
                                                   (roleBeingChecked == resourceOwner)
                                                  )
        -->
      </xs:element>
      <xs:element name="createHttpBasicAuthentication" type="aaa:CreateHttpBasicAuthentication">
        <!-- constraint: 1) NOT PRESENT if ((extractedIdentity == nameFromOAuthAuthorizationRequest) AND
                                            (flowType == AuthorizationCode) AND
                                            (authorizationCodeRequestType == grantRequest) AND
                                            (roleBeingChecked == resourceOwner)
                                           )
                         2) NOT PRESENT if ((extractedIdentity == nameFromOAuthAuthorizationRequest) AND
                                            (flowType == (AuthorizationCode OR RefreshToken OR ClientCredential OR
                                                          ImplicitGrant OR ResourceOwnerPasswordCredential OR
                                                          ResourceOwnerSamlAssertionCredential
                                                         ) AND
                                            (authorizationCodeRequestType == accessTokenRequest)
                                           )
        -->
      </xs:element>
      <xs:element name="useSsoToken" type="aaa:SsoPackaging">
        <xs:annotation>
          <xs:documentation>
            The primary intention of this map mechanism is to package a SSO token returned from an external identity
            manager such as SiteMinder or OAM, into a cookie.
            As a secondary usage this allows the externally generated SSO token to be package into a OAuth access token.
            For both usages, we are using an externally generated Single Sign-On (SSO) token. i.e., why SSO is in the element name.
          </xs:documentation>
        </xs:annotation>
        <!-- constraint: 1) NOT PRESENT if ((extractedIdentity == nameFromOAuthAuthorizationRequest) AND
                                            (flowType == AuthorizationCode) AND
                                            (authorizationCodeRequestType == grantRequest) AND
                                            (roleBeingChecked == resourceOwner)
                                           )
                         2) NOT PRESENT if ((extractedIdentity == nameFromOAuthAuthorizationRequest) AND
                                            (flowType == (AuthorizationCode OR RefreshToken OR ClientCredential OR
                                                          ImplicitGrant OR ResourceOwnerPasswordCredential OR
                                                          ResourceOwnerSamlAssertionCredential
                                                         ) AND
                                            (authorizationCodeRequestType == accessTokenRequest)
                                           )
                            Note: in theory could use a SSO token as an access token but not being done in practice.
        -->
      </xs:element>
      <xs:element name="createToken">
        <xs:annotation>
          <xs:documentation>
            With this mechanism we are supporting the creation of a more abstract security token and not just a SSO token.
            Security tokens are used to prove one's identity electronically, e.g., a user trying to access their bank 
            account. The token is used in addition to or in place of a password to prove that the user is who they claim to 
            be. The token acts like an electronic key to access something.
            A single sign-on (SSO) is a property of access control of multiple related, but independent software systems. 
            With this property a user logs in once and gains access to all systems without being prompted to log in again at 
            each of them. 
            
            The primary intention of this map mechanism is to create an OAuth access token with an internally created 
            embedded JSON token.
            It can also supports the creation of an internal generated SSO token. This usage is not currently planned to 
            be utilized in our expected use cases.
          </xs:documentation>
        </xs:annotation>
        <!-- constraint: 1) NOT PRESENT if ((extracted identity == nameFromOAuthAuthorizationRequest) AND
                                            (flowType == AuthorizationCode) AND
                                            (authorizationCodeRequestType == grantRequest) AND
                                            (roleBeingChecked == resourceOwner)
                                           )
                         2) WARNING "No access token being created for OAuth flow"
                            if (((extract identity == nameFromOAuthAuthorizationRequest) AND
                                 (flowType = (AuthorizationCode OR ImplitGrant OR Refreshtoken OR
                                              ResourceOwnerPasswordCredentials or ResourceOwnerSamlAssertionCredentials
                                             )
                                 ) AND
                                 (authorizationCodeRequestType == accessTokenRequest) AND
                                 (roleBeingChecked == resourceOwner)
                                ) OR
                                ((extract identity == nameFromOAuthAuthorizationRequest) AND
                                 (flowType = ClientCredentials) AND
                                 (authorizationCodeRequestType == accessTokenRequest) AND
                                 (roleBeingChecked == client)
                                )
                               )
        -->
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="aaa:SsoPackaging">
              <xs:choice>
                <xs:element name="jsonWebToken" type="aaa:JsonWebTokenGenerationType"/>
                <!-- In principle here is nothing that prevents an OAuth application from utilizing eother a SAML Assertion or
                     an third-party generated Single Sign-On (SSO) token as an access token. It is just does not appear to being
                     done at this time. Leave as a future potential enhancement when actual customer need arises.
                -->
              </xs:choice>
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>
      <xs:element name="createTokenViaWsTrust" type="aaa:WsTrustAuthentication">
        <xs:annotation>
          <xs:appinfo>
            1) The token contained in wst:RequestedSecurityToken element of the response is saved in the WS-Security header
            2) The wst:RequestedProofToken of the wst:RequestSecurityTokenResponse needs to be made available to the application via
               a getSecurityMetadata action
          </xs:appinfo>
        </xs:annotation>
        <!-- constraint: 1) NOT PRESENT if ((extracted identity == nameFromOAuthAuthorizationRequest) AND
                                            (flowType == AuthorizationCode) AND
                                            (authorizationCodeRequestType == grantRequest) AND
                                            (roleBeingChecked == resourceOwner)
                                           )
                         2) NOT PRESENT if ((extractedIdentity == nameFromOAuthAuthorizationRequest) AND
                                            (flowType == (AuthorizationCode OR RefreshToken OR ClientCredential OR
                                                          ImplicitGrant OR ResourceOwnerPasswordCredential OR
                                                          ResourceOwnerSamlAssertionCredential
                                                         ) AND
                                            (authorizationCodeRequestType == accessTokenRequest)
                                           )
                            Note: in theory could use a SAML Assertion as an access token but not being done in practice.
                         3) NOT PRESENT if (extracted identity == tokenFromHttpOauthAuthorization)
        -->
      </xs:element>
      <xs:element name="useWsTrustAuthenticationToken">
        <!-- constraint: ONLY PRESENT if authenticate identity = (WsTrustAuthentication) -->
        <!-- constraint: ONLY ALLOWED if (tokenType of associated WS-Trust authenication == (SAML-v2.0 OR SAML-v1.1 OR Inferred)) -->
        <xs:complexType>
          <xs:sequence>
            <xs:element name="outputBindingInfo" type="aaa:OutputBindingInfoForExternalCreation" minOccurs="0"/>
          </xs:sequence>
        </xs:complexType>
        <!-- constraint: 1) NOT PRESENT if ((extracted identity == nameFromOAuthAuthorizationRequest) AND
                                            (flowType == AuthorizationCode) AND
                                            (authorizationCodeRequestType == grantRequest) AND
                                            (roleBeingChecked == resourceOwner)
                                           )
                         2) NOT PRESENT if ((extractedIdentity == nameFromOAuthAuthorizationRequest) AND
                                            (flowType == (AuthorizationCode OR RefreshToken OR ClientCredential OR
                                                          ImplicitGrant OR ResourceOwnerPasswordCredential OR
                                                          ResourceOwnerSamlAssertionCredential
                                                         ) AND
                                            (authorizationCodeRequestType == accessTokenRequest)
                                           )
                            Note: in theory could use a SAML Assertion as an access token but not being done in practice.
        -->
      </xs:element>
      <xs:element name="useSamlAttributeQueryToken">
        <!-- constraint: ONLY ALLOWED if (authorizeResource == samlAttributeQuery) -->
        <xs:complexType>
          <xs:sequence>
            <xs:element name="outputBindingInfo" type="aaa:OutputBindingInfoForExternalCreation" minOccurs="0"/>
          </xs:sequence>
        </xs:complexType>
        <!-- constraint: 1) NOT PRESENT if ((extracted identity == nameFromOAuthAuthorizationRequest) AND
                                            (flowType == AuthorizationCode) AND
                                            (authorizationCodeRequestType == grantRequest) AND
                                            (roleBeingChecked == resourceOwner)
                                           )
                         2) NOT PRESENT if ((extractedIdentity == nameFromOAuthAuthorizationRequest) AND
                                            (flowType == (AuthorizationCode OR RefreshToken OR ClientCredential OR
                                                          ImplicitGrant OR ResourceOwnerPasswordCredential OR
                                                          ResourceOwnerSamlAssertionCredential
                                                         ) AND
                                            (authorizationCodeRequestType == accessTokenRequest)
                                           )
                            Note: in theory could use a SAML Assertion as an access token but not being done in practice.
        -->
      </xs:element>
      <!-- Not Release 2.1 feature
        <xs:element name="xpath" type="aaa:EnhancedFullXPath"/>
      -->
    </xs:choice>
    <xs:attribute name="removeExtractedIdentity" type="xs:boolean" use="optional" default="false">
      <xs:annotation>
        <xs:documentation>
          Should the message content based security token used in the extract identity be removed from the input document.
          If username, X.509 (BST) or SAML security token in message then removeExtractedIdentity will apply.
        </xs:documentation>
        <!-- constraint: removeExtractedIdentity MUST BE false 
                         if (extraction mechanism == (certificateFromPeerSsl OR clientIpAddressFromTransport OR
                                                      bstFromVerifyOperation OR usernameFromHttpBasicAuthentication OR
                                                      samlArtifact OR ssoFromCookie OR ssoFromWorkflow OR   
                                                      x509CertificateFromWorkflow OR usernamePasswordFromWorkflow OR
                                                      (nameFromSamlSubject AND 
                                                       (inputBindingInfo importSource != from-WS-Security-header)
                                                      ) OR
                                                      nameFromOauthAuthorizationRequest OR tokenFromHttpOauthAuthorization OR
                                                      principleNameFromSpnegoToken
                                                     )
                            )
                         This is because the extract identity is NOT in the input document but metadata or a workflow variable.
        -->
      </xs:annotation>
    </xs:attribute>
    <!-- constraint: NOT PRESENT if ((extract identity == nameFromOAuthAuthorizationRequest) AND 
                                     (roleBeingChecked == client) AND
                                     (flowType != ClientCredentials)
                                    )
    -->
  </xs:complexType>
  <xs:complexType name="SsoPackaging">
    <xs:choice>
      <xs:element name="createSsoCookie" type="aaa:CreateCookie">
        <!-- constraint: NOT ALLOWED if (extract identity == nameFromOAuthAuthorizationRequest) -->
      </xs:element>
      <xs:element name="createOAuthAccessTokenResponse" type="aaa:AccessTokenResponseSpecificInfoType">
        <!-- constraint: ONLY ALLOWED if ((extract identity == nameFromOAuthAuthorizationRequest) AND
                                          (((flowType == ClientCredentials) AND (roleBeingChecked == client)) OR
                                           ((flowType == (AuthorizationCode OR ImplicitGrant OR RefreshToken OR
                                                          ResourceOwnerPasswordCredential OR ResourceOwnerSamlAssertionCredential
                                                         )
                                            ) AND 
                                            (roleBeingChecked == resourceOwner)
                                           )
                                          )
                                         )
        -->
      </xs:element>
    </xs:choice>
  </xs:complexType>
  <xs:complexType name="AcceptIceTokenSignatureInfo">
    <xs:sequence>
      <xs:element name="iceTokenAcceptSignatureAlgorithm" type="aaa:IceTokenAcceptSignatureAlgorithm"/>
      <xs:element name="iceTokenCertificate" type="aaa:SecurityToken">
        <!-- constraint: keyFromWorkflow NOT ALLOWED -->
      </xs:element>
      <xs:element name="iceTokenAuthenticationPolicy" type="aaa:WebServiceAuthenticationPolicy"/>
    </xs:sequence>
  </xs:complexType>
  <xs:complexType name="IceTokenAcceptSignatureAlgorithm">
    <xs:all>
      <xs:element name="rsaWithSha1" type="aaa:EmptyType" minOccurs="0"/>
    </xs:all>
  </xs:complexType>
  <xs:complexType name="AcceptIceTokenEncryptionInfo">
    <xs:sequence>
      <xs:element name="iceAcceptDataEncryptionAlgorithm" type="aaa:IceTokenAcceptDataEncryptionAlgorithm"/>
      <xs:element name="icePassphrase" type="aaa:SecurityToken">
        <!-- constraint: bstFromWorkflow NOT ALLOWED -->
      </xs:element>
    </xs:sequence>
  </xs:complexType>
  <xs:complexType name="IceTokenAcceptDataEncryptionAlgorithm">
    <xs:all>
      <xs:element name="AES128CBC" type="aaa:EmptyType" minOccurs="0"/>
      <xs:element name="AES256CBC" type="aaa:EmptyType" minOccurs="0"/>
    </xs:all>
  </xs:complexType>
  <xs:complexType name="JsonWebTokenGenerationType">
    <xs:annotation>
      <xs:documentation>
        A JSON Web Token (JWT) is a string consisting of three parts: the Encoded JWT Header, the JWT Second Part, and the 
        JWT Third Part in this specific ordering. The parts are separated by period ('.') characters with each part containing
        base64url encoded content.
        The JWT Header is a string that describes the cryptographic operations applied to the JWT. When the JWT is signed, the 
        JWT Header is the JWS Header. When the JWT is encrypted, the JWT Header is the JWE Header.
        JWT Second Part: When the JWT is signed, the JWT Second Part is the Encoded JWS Payload. When the JWT is encrypted, the 
        JWT Second Part is the Encoded JWE Encrypted Key. 
        JWT Third Part: When the JWT is signed, the JWT Third Part is the Encoded JWS Signature. When the JWT is encrypted, the 
        JWT Third Part is the Encoded JWE Ciphertext.
        
        The following are Reserved Claim Names:
        exp: (number, intDate) identifies the expiration time on or after which the token MUST NOT be accepted for processing. 
             The processing of the exp claim requires that the current date/time MUST be before the expiration date/time listed 
             in the exp claim. Implementers MAY provide for some small leeway, usually no more than a few minutes, to account 
             for clock skew. This claim is OPTIONAL.
        nbf: (number,	IntDate) identifies the time before which the token MUST NOT be accepted for processing. The processing of 
             the nbf claim requires that the current date/time MUST be after or equal to the not-before date/time listed in the 
             nbf claim. Implementers MAY provide for some small leeway, usually no more than a few minutes, to account for 
             clock skew. This claim is OPTIONAL.
        iat: (number, IntDate) identifies the time at which the JWT was issued. This claim can be used to determine the age 
             of the token. This claim is OPTIONAL.
        iss: (string, StringOrURI) identifies the principal that issued the JWT. The processing of this claim is generally
             application specific. The iss value is case sensitive. This claim is OPTIONAL.
        aud: (string, StringOrURI) identifies the audience that the JWT is intended for. The principal intended to process 
             the JWT MUST be identified with the value of the audience claim. If the principal processing the claim does 
             not identify itself with the identifier in the aud claim value then the JWT MUST be rejected. The interpretation 
             of the audience value is generally application specific. The aud value is case sensitive. This claim is OPTIONAL.
        prn: (string, StringOrURI) identifies the subject of the JWT. The processing of this claim is generally application
             specific. The prn value is case sensitive. This claim is OPTIONAL.
        jti: (string, String) provides a unique identifier for the JWT. The identifier value MUST be assigned in a manner
             that ensures that there is a negligible probability that the same value will be accidentally assigned to a 
             different data object. The jti claim can be used to prevent the JWT from being replayed. The jti value is case
             sensitive. This claim is OPTIONAL.
        typ: (string, String) is used to declare a type for the contents of this JWT Claims Set. The typ value is case 
             sensitive. This claim is OPTIONAL.  
             
        Given these reserved claims, we will populate our OAuth token as follows:
        1) exp: populated with token expiration delta + time when token was issued. If token never expires, then claim will not
                be present.
        2) nbf: populated with time token was issued.
        3) iss: populated with authorization server URL.
        4) aud: populated with resource server url/domain.
        5) prn: identify subject, i.e., resource owner name. If client credential flow then client_id.
        6) jti: populated with a unique nonce, 24 bytes.
        We will also populate the following non-reserve claims:
        a) scp: populated with the approved scope.
        b) clt: populated with client_id
      </xs:documentation>
      <xs:appinfo>
        When we generate JSON Web Token, we will automatically populate the:
          nbf with the current time - skew.
          exp with the current time + skew + OAuth expirationDelta.
      </xs:appinfo>
    </xs:annotation>
    <xs:sequence>
      <xs:element name="tokenContent">
        <xs:complexType>
          <xs:sequence>
            <xs:element name="issuer" type="xs:anyURI"/>
            <xs:element name="subject" type="aaa:AuthenticationSubjectNameIdentifierValue"/>
            <xs:element name="audience" type="aaa:SamlString"/>
            <xs:element name="claim" minOccurs="0" maxOccurs="unbounded">
              <xs:complexType>
                <xs:sequence>
                  <xs:element name="name" type="xs:NMTOKEN"/>
                  <xs:element name="value" type="aaa:SamlString"/>
                </xs:sequence>
              </xs:complexType>
            </xs:element>
          </xs:sequence>
        </xs:complexType>
      </xs:element>
      <xs:element name="jsonSignInfo" type="aaa:GenerateJsonWebSignatureInfo" minOccurs="0">
        <!-- WARNING "Ability to ensure the integrity of JSON Web token is not being enforced for an
                      assertion type of access token" 
             if (jsonSignInfo is not being populated)
        -->
      </xs:element>
      <xs:element name="jsonEncryptionInfo" type="aaa:GenerateJsonWebEncryptionInfo" minOccurs="0">
        <!-- deferred to future release -->
      </xs:element>
    </xs:sequence>
  </xs:complexType>
  <xs:complexType name="JsonWebTokenReceiveType">
    <xs:sequence>
      <xs:element name="jsonDecryptionInfo" type="aaa:AcceptJsonWebEncryptionInfo" minOccurs="0">
        <!-- deferred to future release -->
      </xs:element>
      <xs:element name="jsonVerifyInfo" type="aaa:AcceptJsonWebSignatureInfo" minOccurs="0">
        <!-- WARNING "Ability to ensure the integrity of JSON Web token is not being enforced" 
             if (jsonVerifyInfo is not being populated)
        -->
      </xs:element>
      <xs:element name="requiredVerification" type="aaa:OAuthTokenVerificationActionType" minOccurs="0">
        <xs:annotation>
          <xs:documentation>Defines semantic fields of incoming OAuth token to be validated</xs:documentation>
        </xs:annotation>
      </xs:element>
      <xs:group ref="aaa:UniquenessCheckingType" minOccurs="0"/>
      <xs:element name="contentLocations" minOccurs="0">
        <xs:annotation>
          <xs:documentation>Identifies where in the JSON Web token critical information has een saved.</xs:documentation>
          <xs:appinfo>Other fields like audience and resource owner have known existing parameters assigned.</xs:appinfo>
        </xs:annotation>
        <xs:complexType>
          <xs:sequence>
            <xs:element name="scopeLocation" type="xs:string" default="scp">
              <xs:annotation>
                <xs:documentation>Identifies the ext_attrs entity that contains access token scope</xs:documentation>
              </xs:annotation>
            </xs:element>
            <xs:element name="clientLocation" type="xs:string" default="clt">
              <xs:annotation>
                <xs:documentation>Identifies the ext_attrs entity that contains access token client identifier</xs:documentation>
              </xs:annotation>
            </xs:element>
          </xs:sequence>
        </xs:complexType>
      </xs:element>
    </xs:sequence>
  </xs:complexType>
  <xs:complexType name="GenerateJsonWebSignatureInfo">
    <xs:annotation>
      <xs:documentation>
        The following are reserve header parameter fields in the JSON Web Signature (JWS) Header:
        alg: (string, StringOrURI) 	identifies the cryptographic algorithm used to secure the JWS. A list of defined alg values:
                HS256 	HMAC using SHA-256 hash algorithm
                HS384 	HMAC using SHA-384 hash algorithm
                HS512 	HMAC using SHA-512 hash algorithm
                RS256 	RSA using SHA-256 hash algorithm
                RS384 	RSA using SHA-384 hash algorithm
                RS512 	RSA using SHA-512 hash algorithm
                ES256 	ECDSA using P-256 curve and SHA-256 hash algorithm
                ES384 	ECDSA using P-384 curve and SHA-384 hash algorithm
                ES512 	ECDSA using P-521 curve and SHA-512 hash algorithm. 
             The processing of the alg header parameter requires that the value MUST be one that is both supported and for which
             there exists a key for use with that algorithm associated with the signer of the content. The alg parameter value is
             case sensitive. This header parameter is REQUIRED.
        typ: (string, String) declare the type of the signed content. The typ value is case sensitive. This header parameter 
             is OPTIONAL.
        jku: (string, URL) JSON Web Key URL is an absolute URL that refers to a resource for a set of JSON-encoded public keys, 
             one of which corresponds to the key that was used to sign the JWS. The keys MUST be encoded as described in the 
             JSON Web Key (JWK) specification. The protocol used to acquire the resource MUST provide integrity protection. 
             An HTTP GET request to retrieve the certificate MUST use TLS RFC 2818 [RFC2818] RFC 5246 [RFC5246] with server
             authentication RFC 6125 [RFC6125]. This header parameter is OPTIONAL.
        kid: (string, String) is a hint indicating which specific key owned by the signer should be used to validate the signature.
             This allows signers to explicitly signal a change of key to recipients. The interpretation of the contents of the kid
             parameter is unspecified. This header parameter is OPTIONAL.
        x5u: (string, URL) is an absolute URL that refers to a resource for the X.509 public key certificate or certificate chain
             corresponding to the key used to sign the JWS. The identified resource MUST provide a representation of the 
             certificate or certificate chain that conforms to RFC 5280 [RFC5280] in PEM encoded form RFC 1421 [RFC1421]. The
             protocol used to acquire the resource MUST provide integrity protection. An HTTP GET request to retrieve the
             certificate MUST use TLS RFC 2818 [RFC2818] RFC 5246 [RFC5246] with server authentication RFC 6125 [RFC6125]. 
             This header parameter is OPTIONAL.
        x5t: (string, String) is a base64url encoded SHA-1 thumbprint (a.k.a. digest) of the DER encoding of an X.509 
             certificate that can be used to match the certificate. This header parameter is OPTIONAL. 
        
        Of these signature optional, we will only be supporting in this release: alg, kid and typ.
      </xs:documentation>
      <xs:appinfo>
        1) We will only implement JSON Web Tokens (JWT) with JSON Web Signature (JWS) and not JSON Web Encryption (JWE) 
           functionality.
        2) For JSON Web Signature (JWS), we will only support HMAC using SHA-256, SHA-384 and SHA-512 hash algorithm.
        3) For JSON Web Signature (JWS), we will only support the kid mechanism for identifying the symmetric key being used.
      </xs:appinfo>
    </xs:annotation>
    <xs:sequence>
      <xs:element name="jsonGenerateSignatureAlgorithm" type="aaa:JsonGenerateSignatureAlgorithm" default="hmacWithSha256"/>
      <xs:element name="jsonSymmetricKey" type="aaa:SecurityToken">
        <!-- constraint: bstFromWorkflow NOT ALLOWED -->
      </xs:element>
    </xs:sequence>
  </xs:complexType>
  <xs:complexType name="AcceptJsonWebSignatureInfo">
    <xs:sequence>
      <xs:element name="jsonAcceptSignatureAlgorithm" type="aaa:JsonAcceptSignatureAlgorithm"/>
      <xs:element name="jsonSymmetricKey" type="aaa:JsonReceiveSecurityToken"/>
      <xs:element name="authenticationPolicy" type="aaa:WebServiceAuthenticationPolicy"/>
    </xs:sequence>
  </xs:complexType>
  <xs:simpleType name="JsonGenerateSignatureAlgorithm">
    <xs:restriction base="xs:string">
      <xs:enumeration value="hmacWithSha256"/>
      <xs:enumeration value="hmacWithSha384"/>
      <xs:enumeration value="hmacWithSha512"/>
      <!-- deferred to future development
      <xs:enumeration value="rsaWithSha256"/>
      <xs:enumeration value="rsaWithSha384"/>
      <xs:enumeration value="rsaWithSha512"/>
      <xs:enumeration value="ecdsaWithSha256"/>
      <xs:enumeration value="ecdsaWithSha384"/>
      <xs:enumeration value="ecdsaWithSha512"/>
      -->
    </xs:restriction>
  </xs:simpleType>
  <xs:complexType name="JsonAcceptSignatureAlgorithm">
    <xs:all>
      <xs:element name="hmacWithSha256" type="aaa:EmptyType" minOccurs="0"/>
      <xs:element name="hmacWithSha384" type="aaa:EmptyType" minOccurs="0"/>
      <xs:element name="hmacWithSha512" type="aaa:EmptyType" minOccurs="0"/>
      <!-- deferred to future development
      <xs:element name="rsaWithSha256" type="aaa:EmptyType" minOccurs="0"/>
      <xs:element name="rsaWithSha384" type="aaa:EmptyType" minOccurs="0"/>
      <xs:element name="rsaWithSha512" type="aaa:EmptyType" minOccurs="0"/>
      <xs:element name="ecdsaWithSha256" type="aaa:EmptyType" minOccurs="0"/>
      <xs:element name="ecdsaWithSha384" type="aaa:EmptyType" minOccurs="0"/>
      <xs:element name="ecdsaWithSha512" type="aaa:EmptyType" minOccurs="0"/>
      -->
    </xs:all>
  </xs:complexType>
  <xs:complexType name="GenerateJsonWebEncryptionInfo">
    <xs:sequence>
      <xs:element name="jsonGenerateDataEncryptionAlgorithm" type="aaa:JsonGenerateDataEncryptionAlgorithm" default="AES128CBC"/>
      <xs:element name="jsonSymmetricKey" type="aaa:SecurityToken">
        <!-- constraint: bstFromWorkflow NOT ALLOWED -->
      </xs:element>
    </xs:sequence>
  </xs:complexType>
  <xs:complexType name="AcceptJsonWebEncryptionInfo">
    <xs:sequence>
      <xs:element name="jsonAcceptDataEncryptionAlgorithm" type="aaa:JsonAcceptDataEncryptionAlgorithm"/>
      <xs:element name="jsonSymmetricKey" type="aaa:JsonReceiveSecurityToken"/>
    </xs:sequence>
  </xs:complexType>
  <xs:simpleType name="JsonGenerateDataEncryptionAlgorithm">
    <xs:restriction base="xs:string">
      <xs:enumeration value="AES128CBC"/>
      <xs:enumeration value="AES256CBC"/>
      <!-- deferred
      <xs:enumeration value="AES128GCM"/>
      <xs:enumeration value="AES192GCM"/>
      <xs:enumeration value="AES256GCM"/>
      -->
    </xs:restriction>
  </xs:simpleType>
  <xs:complexType name="JsonAcceptDataEncryptionAlgorithm">
    <xs:all>
      <xs:element name="AES128CBC" type="aaa:EmptyType" minOccurs="0"/>
      <xs:element name="AES256CBC" type="aaa:EmptyType" minOccurs="0"/>
      <!-- deferred
      <xs:element name="AES128GCM" type="aaa:EmptyType" minOccurs="0"/>
      <xs:element name="AES192GCM" type="aaa:EmptyType" minOccurs="0"/>
      <xs:element name="AES256GCM" type="aaa:EmptyType" minOccurs="0"/>
      -->
    </xs:all>
  </xs:complexType>
  <xs:complexType name="OAuthTokenVerificationActionType">
    <xs:annotation>
      <xs:documentation>For all OAuth access tokens we are required to enforce the assigned lifetime.</xs:documentation>
    </xs:annotation>
    <xs:sequence>
      <xs:element name="crossCheckClientId" type="aaa:SamlString" minOccurs="0">
        <xs:annotation>
          <xs:documentation>
            If populated we will check that specified client identifier is in access token.
            Normally this will come from a proceeding AAA action that was used to authenticate the client on their
            resource server request.
          </xs:documentation>
        </xs:annotation>
        <!-- constraint: WARNING "Potential security vulnerability: Not checking that actual client is actual holder-of-token"
                         if (crossCheckClientId is not populated)
        -->
      </xs:element>
      <xs:element name="checkAudience" type="aaa:SamlString" minOccurs="0">
        <xs:annotation>
          <xs:documentation>Check that this access token was generated for expected resource server.</xs:documentation>
        </xs:annotation>
      </xs:element>
      <xs:element name="checkIssuer" type="aaa:SamlString" minOccurs="0">
        <xs:annotation>
          <xs:documentation>Check that expected authorization server generated this access token.</xs:documentation>
        </xs:annotation>
      </xs:element>
    </xs:sequence>
  </xs:complexType>
  <xs:complexType name="XmlX509EnvelopedSignatureType">
    <xs:annotation>
      <xs:documentation>XML X509 Enveloped Signature used to sign SAML response.</xs:documentation>
    </xs:annotation>
    <xs:sequence>
      <xs:element name="envelopedSignatureGenerationMethod" type="aaa:SignatureGenerationMethod" default="rsaWithSha1">
        <xs:annotation>
          <xs:documentation>What signature method will be use when generating the enveloped signature.</xs:documentation>
        </xs:annotation>
      </xs:element>
      <xs:element name="envelopedSignatureCanonicalGenerationMethod" type="aaa:CanonicalGenerationMethod" default="C14N_exclusive">
        <xs:annotation>
          <xs:documentation>What canonicalization method will we use when generating the enveloped signature SignInfo.</xs:documentation>
        </xs:annotation>
      </xs:element>
      <xs:element name="envelopedDigestGenerationMethod" type="aaa:DigestGenerationMethod" default="sha1">
        <xs:annotation>
          <xs:documentation>What digest method will we use over the enveloped data.</xs:documentation>
        </xs:annotation>
      </xs:element>
      <xs:element name="envelopedCanonicalGenerationMethod" type="aaa:CanonicalGenerationMethod" default="C14N_exclusive">
        <xs:annotation>
          <xs:documentation>What canonicalization method will we use over the enveloped data references.</xs:documentation>
        </xs:annotation>
      </xs:element>
      <xs:element name="samlRestriction" type="xs:boolean" default="false">
        <xs:annotation>
          <xs:documentation>
            Indicates if strict SAML restrictions are to be enforced on this embedded enveloped signature. XML signature 
            standards recommend that data references utilize xpointer() mechanism. However, some SAML organization believe 
            that a NULL string should be utilied.
          </xs:documentation>
        </xs:annotation>
      </xs:element>
      <xs:element name="keyPair">
        <xs:annotation>
          <xs:documentation>
            Name of an asymmetricKeyPair element. Resolution based upon value of associated "use" attribute.
            This asymmetricKeyPair element identifies either a RSA or DSA public/private key pair. The public key is 
            usually package within an X.509 certificate. The private key and associated certificate can be package in 
            the same file or in separate files.
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:sequence>
            <xs:element name="security-config-package" type="aaa:SecurityPackageHandle">
              <xs:annotation>
                <xs:documentation>
                  Using X509 key pair security object defined in application related security config package
                </xs:documentation>
              </xs:annotation>
              <!-- constraint: name specified must match abstract handle defined in associated security package.
                               Type of the security object in the security package must match X.509 PKI asymmetric key pair.
              -->
            </xs:element>
          </xs:sequence>
        </xs:complexType>
      </xs:element>
    </xs:sequence>
  </xs:complexType>
  <xs:complexType name="ExtractResource">
    <xs:annotation>
      <xs:documentation>The resource that the authenticated requester wants to access</xs:documentation>
    </xs:annotation>
    <xs:sequence>
      <xs:choice>
        <xs:element name="requestUriFromHttpOperation" type="aaa:ExtractUrlSubcomponent">
          <xs:annotation>
            <xs:documentation>
              URI immediately after HTTP operation: GET, POST or PUT extracted, 
              e.g., HTTP GET request-URI HTTP/1.1
            </xs:documentation>
          </xs:annotation>
          <!-- constraint: ALLOWED if (extract identity == tokenFromHttpOauthAuthorization) -->
        </xs:element>
        <xs:element name="urlFromWsAddressingAction" type="aaa:ExtractUrlSubcomponent">
          <xs:annotation>
            <xs:documentation>URI from WS-Addressing Action element within SOAP header extracted.</xs:documentation>
          </xs:annotation>
          <!-- constraint: NOT ALLOWED if (extract identity == tokenFromHttpOauthAuthorization) -->
        </xs:element>
        <xs:element name="namefromOuterMostRequestElement" type="aaa:EmptyType">
          <xs:annotation>
            <xs:documentation>Use the name of the operation on the outer-most/first request element as the extracted resource</xs:documentation>
          </xs:annotation>
          <!-- constraint: NOT ALLOWED if (extract identity == tokenFromHttpOauthAuthorization) -->
        </xs:element>
        <xs:element name="actionFromHttpHeader" type="aaa:ExtractUrlSubcomponent">
          <xs:annotation>
            <xs:documentation>
              Depending upon the SOAP version, the URL associated with the action will be extracted and used as
              the resource.
              
              For SOAP version 1.1, the URL in the SOAPAction element in the HTTP header will be used, e.g.,
              POST /samples/echo_service.php HTTP/1.1
              User-Agent: Axis2C/1.5.0
              SOAPAction: "uri-to-be-extracted"
              Content-Length: 225
              Content-Type: text/xml;charset=UTF-8
              Host: 127.0.0.1
              
              For SOAP version 1.2, the URL on the action attribute of the Content-Type will be extracted, e.g.,
              Content-Type: application/soap+xml;charset=UTF-8;action="uri-to-be-extracted"
            </xs:documentation>
          </xs:annotation>
          <!-- constraint: NOT ALLOWED if (extract identity == tokenFromHttpOauthAuthorization) -->
        </xs:element>
        <xs:element name="xpathFromSoapBody" type="aaa:EmptyType">
          <xs:annotation>
            <xs:documentation> 
              While primary intention is to Use XPath expression upon SOAP body to extract resource, it can be use to more
              generally get resource from workflow.
            </xs:documentation>
          </xs:annotation>
          <!-- constraint: service designer action builder must prompt for an XPath to perform this resolution when AAA policy bound to an action -->
        </xs:element>
      </xs:choice>
      <xs:element name="prefix" type="xs:string" minOccurs="0">
        <xs:annotation>
          <xs:documentation>
            Optional string that will be added in front of the extracted resource.
            This will normally only be utilized when the extract resource mechanism is namefromOuterMostRequestElement or xpathFromSoapBody
            because these resources are not normally URLs. However, most authorization services such as SiteMinder or Oracle Access Manager
            will require all resources to start from "/".
          </xs:documentation>
        </xs:annotation>
      </xs:element>
    </xs:sequence>
  </xs:complexType>
  <xs:complexType name="ExtractUrlSubcomponent">
    <xs:annotation>
      <xs:documentation>
        Supports the optional parsing of the resource URL into its components and return the identified URL component as a string. 
        The application developer can choose to utilize the entire resource URL as the extracted resource by selecting not to have
        any component or index elements.
        Detail processing rules are:
        1) For path component, an optional index may be specified to identify which part of a path is returned. If index addresses 
           outside the specified path then a BPEL fault is thrown.
        2) For the case where a path contains a double slash e.g., a//b, then the empty part of the path is ignored as if  the original path 
           was a/b. There is some ambiguity here because the interpretation of a//b is Web Server and operating system dependent.
        3) For the case when a path contains a relative part, e.g., a/b/../c or a/./c, the relative path expression is collapsed and the result 
           is equivalent to a/c
        4) For the case where the relative part would remove the leading component of the path component, the result is undefined and it will 
           yield an error.
        5) If the URL cannot be successfully parsed then a BPEL fault is thrown.
      </xs:documentation>
    </xs:annotation>
    <xs:sequence minOccurs="0">
      <xs:annotation>
        <xs:appinfo>If no component selected that component and optional index elements should not be populated.</xs:appinfo>
      </xs:annotation>
      <xs:element name="component" default="path">
        <xs:simpleType>
          <xs:restriction base="xs:string">
            <xs:enumeration value="path"/>
            <xs:enumeration value="authority"/>
            <xs:enumeration value="fragment"/>
            <xs:enumeration value="port"/>
            <xs:enumeration value="query"/>
            <xs:enumeration value="schema"/>
          </xs:restriction>
        </xs:simpleType>
      </xs:element>
      <xs:element name="index" default="-1" minOccurs="0">
        <xs:annotation>
          <xs:documentation>
            Optional parameter. If component-name == "path" then index identifies which sub-part of the path is returned. A positive integer 
            value will retrieve the "n" component of the path starting from the root. A negative integer value will retrieve the "n" component 
            starting from the leaf end of the path. It is error if the index value exceeds the number of components of the path. A zero value 
            is equivalent to not specifying an index value, i.e, retrieving the full path.
          </xs:documentation>
        </xs:annotation>
        <xs:simpleType>
          <xs:restriction base="xs:integer">
            <xs:minInclusive value="-25"/>
            <xs:maxExclusive value="25"/>
          </xs:restriction>
        </xs:simpleType>
      </xs:element>
    </xs:sequence>
  </xs:complexType>
  <xs:complexType name="AuthorizeResource">
    <xs:annotation>
      <xs:documentation>What mechanism will be used to authorize the extracted resource.</xs:documentation>
    </xs:annotation>
    <xs:choice>
      <xs:element name="ldapAuthorization" type="aaa:LdapAuthorization"/>
      <xs:element name="siteMinderAuthorization" type="aaa:SiteMinderAuthorization">
        <!-- constraint: ONLY ALLOWED if ((extracted identity == (usernameFromHttpBasicAuthenticationHeader OR usernameFromSecurityHeader OR
                                                                   usernamePasswordFromWorkflow OR ssoFromCookie OR ssoFromWorkflow OR 
                                                                   certificateFromPeerSsl OR x509CertificateFromSecurityHeader OR 
                                                                   x509CertificateFromWorkflow OR bstFromVerifyOperation OR
                                                                  )
                                           ) OR
                                           ((extracted identity == nameFromOauthAuthorizationInfo) AND 
                                            (flowType == (AuthorizationCode OR ClientCredential OR RefreshToken OR
                                                          ResourceOwnerPasswordCredential OR ResourceOwnerSamlAssertionCredential
                                                         ) 
                                            ) AND
                                            (role == client) AND
                                            (credentialSource == (HttpBasic OR requestBody))   
                                           ) OR
                                           ((extracted identity == nameFromOauthAuthorizationInfo) AND 
                                            (flowType == ResourceOwnerPasswordCredential) AND
                                            (role == resourceOwner) AND
                                            (credentialSource == requestBody)
                                           )   
                                          )
        -->
      </xs:element>
      <xs:element name="oracleAccessManagerAuthorization" type="aaa:OracleAccessManagerAuthorization">
        <!-- constraint: ONLY ALLOWED if ((extracted identity == (usernameFromHttpBasicAuthenticationHeader OR usernameFromSecurityHeader OR
                                                                   usernamePasswordFromWorkflow OR ssoFromCookie OR ssoFromWorkflow OR 
                                                                   certificateFromPeerSsl OR x509CertificateFromSecurityHeader OR 
                                                                   x509CertificateFromWorkflow OR bstFromVerifyOperation OR
                                                                  )
                                           ) OR
                                           ((extracted identity == nameFromOauthAuthorizationInfo) AND 
                                            (flowType == (AuthorizationCode OR ClientCredential OR RefreshToken OR
                                                          ResourceOwnerPasswordCredential OR ResourceOwnerSamlAssertionCredential
                                                         ) 
                                            ) AND
                                            (role == client) AND
                                            (credentialSource == (HttpBasic OR requestBody))   
                                           ) OR
                                           ((extracted identity == nameFromOauthAuthorizationInfo) AND 
                                            (flowType == ResourceOwnerPasswordCredential) AND
                                            (role == resourceOwner) AND
                                            (credentialSource == requestBody)
                                           )   
                                          )
        -->
      </xs:element>
      <xs:element name="tivoliAccessManagerAuthorization" type="aaa:TivoliAccessManagerAuthorization">
        <!-- constraint: ONLY ALLOWED if ((extracted identity == (usernameFromHttpBasicAuthenticationHeader OR usernameFromSecurityHeader OR 
                                                                  usernamePasswordFromWorkflow
                                                                 )
                                          ) OR
                                          ((extracted identity == nameFromOauthAuthorizationInfo) AND 
                                           (flowType == (AuthorizationCode OR ClientCredential OR RefreshToken OR
                                                         ResourceOwnerPasswordCredential OR ResourceOwnerSamlAssertionCredential
                                                        ) 
                                           ) AND
                                           (role == client) AND
                                           (credentialSource == (HttpBasic OR requestBody))   
                                          ) OR
                                          ((extracted identity == nameFromOauthAuthorizationInfo) AND 
                                           (flowType == ResourceOwnerPasswordCredential) AND
                                           (role == resourceOwner) AND
                                           (credentialSource == requestBody)
                                          )   
                                         )
        -->
      </xs:element>
      <xs:element name="samlAssertionAuthorization" type="aaa:SamlAssertionAuthorization">
        <xs:annotation>
          <xs:documentation>Use SAML assertion that was extracted and validated by Identity processing</xs:documentation>
        </xs:annotation>
        <!-- constraint: this is only allowed if (extract identity mechanism is nameFromSamlAttribute, nameFromSamlAuthentication, or
                         nameFromSamlSubject -->
      </xs:element>
      <xs:element name="samlAttributeQuery" type="aaa:SamlAttributeQuery">
        <xs:annotation>
          <xs:documentation>
            Generates a SAML Attribute Query Request which is send via an HTTP IA to SAML Attribute Server.
            Will check the SAML Attribute response status to ensure its successful processing.
            Will also check that the SAML assertion embedded within the response passes the following:
            1) embedded Signature is verified.
            2) Issuer, Conditions lifetime, subject name and formats are what is expected.
            3) Attribute names, value and name/value pairs are what is expected.
          </xs:documentation>
        </xs:annotation>
      </xs:element>
      <xs:element name="oracleEntitlementServerXacmlAuthorization" type="aaa:OracleEntitlementServerXacmlAuthorization">
        <!--  constraint: ONLY ALLOWED if (extract identity == (usernameFromHttpBasicAuthenticationHeader OR
                                                                usernameFromSecurityHeader OR usernamePasswordFromWorkflow
                                                               )
                                          )
        -->
      </xs:element>
      <xs:element name="oauthAccessTokenAuthorization" type="aaa:OAuthAccessTokenAuthorization">
        <!-- constraint: 1) ONLY ALLOWED if (extract identity == (tokenFromHttpOauthAuthorization))
                         2) WARNING "OAuth standard requires that access token scope covers the requested resource, 
                                     therefore, should normally extract resource and populate OAuth Access Token Authorization"
                            if ((extract identity == tokenFromHttpOauthAuthorization) AND 
                                (authorizeResource oauthAccessTokenAuthorization not populated)
                               )
        -->
      </xs:element>
    </xs:choice>
    <!-- constraint: 
        1) If AuthenticateIdentity is ldapAuthentication then ldapAuthorization and samlAssertionAuthorization allowed/present.
        2) If AuthenticateIdentity is siteMinderAuthentication then siteMinderAuthorization allowed/present.
        3) If AuthenticateIdentity is oracleAccessManagerAuthentication then oracleAccessManagerAuthorization allowed/present.
        4) If AuthenticateIdentity is tivoliAccessManagerAuthentication then tivoliAccessManagerAuthorization allowed/present.
        5) If AuthenticateIdentity is oracleEntitlementServerAuthentication then oracleEntitlementServerXacmlAuthorization allowed/present.
        6) If AuthenticateIdentity is OCSP Responder then ldapAuthorization, siteMinderAuthorization, oracleAccessManagerAuthorization allowed/present.
    -->
  </xs:complexType>
  <xs:complexType name="ValidateKerberosToken">
    <xs:sequence>
      <xs:element name="kerberosServerKeytab" type="aaa:SecurityPackageHandle">
        <xs:annotation>
          <xs:documentation>
            Identity a Kerberos Keytab file containing valid server principals.
            Actual name is a Kerberos Keytab entity in the associated application security config package.
          </xs:documentation>
        </xs:annotation>
        <!-- contraint: name MUST match a Kerberos Keytab entity. -->
      </xs:element>
      <xs:element name="authenticationPolicy" type="aaa:WebServiceAuthenticationPolicy">
        <!-- contraint: name MUST match a WebServiceAuthenticationPolicy entity with Kerberos as the token type. -->
      </xs:element>
      <xs:element name="acceptableTokenTypes" type="aaa:AcceptableKerberosTokenTypes"/>
    </xs:sequence>
  </xs:complexType>
  <xs:complexType name="AcceptableKerberosTokenTypes">
    <xs:annotation>
      <xs:documentation>Identifies what types of Kerberos tokens is acceptable to receive.</xs:documentation>
    </xs:annotation>
    <xs:sequence>
      <xs:element name="kerberosv5_AP_REQ-1.0" type="xs:boolean" default="false" minOccurs="0">
        <xs:annotation>
          <xs:documentation>
            Kerberos V1.0 token standard:
            Kerberos v5 AP-REQ as defined in the Kerberos specification. This ValueType is used when the ticket is an AP Request.
          </xs:documentation>
        </xs:annotation>
      </xs:element>
      <xs:element name="kerberosv5_AP_REQ-1.1" type="xs:boolean" default="false" minOccurs="0">
        <xs:annotation>
          <xs:documentation>
            Kerberos V1.1 token standard:
            Kerberos v5 AP-REQ as defined in the Kerberos specification. This ValueType is used when the ticket is an AP Request.
            As an attempt to simplify inter-op using Kerberos token, the draft of the WS-Security Kerberos Profile proposed to 
            only utilize this specific token encoding.
          </xs:documentation>
        </xs:annotation>
      </xs:element>
      <xs:element name="gss_Kerberosv5_AP_REQ-1.1" type="xs:boolean" default="true" minOccurs="0">
        <xs:annotation>
          <xs:documentation>
            Kerberos V1.1 token standard:
            A GSS-API Kerberos V5 mechanism token containing an KRB_AP_REQ message as defined in RFC-1964 [1964], Sec. 1.1 and
            its successor RFC-4121 [4121], Sec. 4.1. This ValueType is used when the ticket is an AP Request (ST + Authenticator).
          </xs:documentation>
        </xs:annotation>
      </xs:element>
      <xs:element name="kerberosv5_AP_REQ1510-1.1" type="xs:boolean" default="false" minOccurs="0">
        <xs:annotation>
          <xs:documentation>
            Kerberos V1.1 token standard:
            Kerberos v5 AP-REQ as defined in RFC1510. This ValueType is used when the ticket is an AP Request per RFC1510.
            Is not a validation error if unknown type of authorization options present.
            Transited-policy-checked and ok-as-delegate ticket flags not valid.
          </xs:documentation>
        </xs:annotation>
      </xs:element>
      <xs:element name="gss_Kerberosv5_AP_REQ1510-1.1" type="xs:boolean" default="false" minOccurs="0">
        <xs:annotation>
          <xs:documentation>
            Kerberos V1.1 token standard:
            A GSS-API Kerberos V5 mechanism token containing an KRB_AP_REQ message as defined in RFC-1964, Sec. 1.1 and its
            successor RFC-4121, Sec. 4.1. This ValueType is used when the ticket is an AP Request (ST + Authenticator) per RFC1510.
            Is not a validation error if unknown type of authorization options present.
            Transited-policy-checked and ok-as-delegate ticket flags not valid.
         </xs:documentation>
        </xs:annotation>
      </xs:element>
      <xs:element name="kerberosv5_AP_REQ4120-1.1" type="xs:boolean" default="false" minOccurs="0">
        <xs:annotation>
          <xs:documentation>
            Kerberos V1.1 token standard:
            Kerberos v5 AP-REQ as defined in RFC4120. This ValueType is used when the ticket is an AP Request per RFC4120
            Is an validation error if unknown type of authorization options present.
          </xs:documentation>
        </xs:annotation>
      </xs:element>
      <xs:element name="gss_Kerberosv5_AP_REQ4120-1.1" type="xs:boolean" default="false" minOccurs="0">
        <xs:annotation>
          <xs:documentation>
            Kerberos V1.1 token standard:
            A GSS-API Kerberos V5 mechanism token containing an KRB_AP_REQ message as defined in RFC-1964, Sec. 1.1 and its
            successor RFC-4121, Sec. 4.1. This ValueType is used when the ticket is an AP Request (ST + Authenticator) per RFC4120.
            Is not a validation error if unknown type of authorization options present.
         </xs:documentation>
        </xs:annotation>
      </xs:element>
    </xs:sequence>
    <!-- constraints: 
          1) WARNING "Inconsistent uniqueness mechanisms required. Non-GSS types requires usage of the WS-Security timestamp."
                     "GSS-Kerberos types could utilize either Kerberos sequence number field or WS-Security timestamp." 
             if (((kerberosv5_AP_REQ-1.0 == true) OR (kerberosv5_AP_REQ-1.1 == true) OR 
                  (kerberosv5_AP_REQ1510-1.1 == true) OR (kerberosv5_AP_REQ4120-1.1 == true)
                 ) AND
                 ((gss_Kerberosv5_AP_REQ-1.1 == true) OR (gss_Kerberosv5_AP_REQ1510-1.1 == true) OR 
                  (gss_Kerberosv5_AP_REQ4120-1.1 == true)
                 )
                )
          2) if ((kerberosv5_AP_REQ-1.0 == true) OR (kerberosv5_AP_REQ-1.1 == true) OR 
                 (kerberosv5_AP_REQ1510-1.1 == true) OR (kerberosv5_AP_REQ4120-1.1 == true)
                ) 
             then associated authentication policy MUST NOT have (checkSequenceNumberUniqueness == true)
             Note: this constraint checking can not be implemented within the SD policy editor. Will require some enhnaced deployment 
                   time assertion mechanism.
          3) if ((gss_Kerberosv5_AP_REQ-1.1 == true) OR (gss_Kerberosv5_AP_REQ1510-1.1 == true) OR 
                 (gss_Kerberosv5_AP_REQ4120-1.1 == true)
                ) 
             then associated authentication policy in security config should generate a warning message if (checkSequenceNumberUniqueness == false)
             Note: this constraint checking can not be implemented within the SD policy editor. Will require some enhanced deployment 
                   time assertion mechanism.
          4) ERROR "When SPNEGO token extracted then Kerberos Token Type must be some form of GSS-API_Kerberosv5_AP_REQ"
             if ((ExtractIdentity == principalNameFromSpnegoToken) && 
                 ((kerberosTokenType == kerberosv5_AP_REQ-1.1) OR 
                  (kerberosTokenType == kerberosv5_AP_REQ1510-1.1) OR
                  (kerberosTokenType == kerberosv5_AP_REQ4120-1.1) OR
                  (kerberosTokenType == kerberosv5_AP_REQ-1.0)
                 )
                )
    -->
  </xs:complexType>
  <xs:complexType name="LdapAuthorization">
    <xs:annotation>
      <xs:documentation>
        Authorizing users to applications/resources via LDAP is usually done by creating groups, e.g., groupOfNames objects, 
        which hold the distriguish names of entries authorized to use the specific application/resource. 
        For example, the group "cn=googleallowed,ou=Proxygroups,o=Company" that only allows the following two users to use google:
          dn=cn=Tim,ou=IT,o=Company
          dn=cn=Tom,ou=Management,o=Company
        The following filter expression could be use to authorize their access to google:
          (&amp;(objectclass=person)(cn=%extractedIdentity)(groupMembership=cn=%extractedResource,ou=ProxyGroups,o=Company)
        where the extracted Identity and Resource are ubstituted into the filter expression.
        Depending upon the LDAP Server implementation, the name and type of groups can change:
          attribute:attribute pairs for direct methods like IBM Directory, SunOne directory, Microsoft Active Directory:
            ibm-allGroups:member    for IBM Directory server
            nsRole:nsRole           for SunONE directory if groups are created with Role inside SunONE
            memberOf:member         for Microsoft Active Directory server
          objectClass:attribute pairs for indirect methods like Domino and eDirectory
            dominoGroup:member      for Domino
            groupOfNames:member     for eDirectory
        
        However, some users perfer to instead utilize a special multi-valued string attribte type in the user's LDAP entry to 
        store names of applications/resources that a user is authorized to utilize. They prefer this approach because all information
        associated with a user is in one place when the user is deleted.
        This approach allows a filter expression like:
          (&amp;objectclass=%extractedIdentity)(service=google)) 
        to determine if the specified service is allowed.
      </xs:documentation>
      <xs:appinfo>
        A potential optimization is for Action Builder to combine the LDAP Authentication request with this LDAP authorization request into a single
        LDAP request as a batch request.
      </xs:appinfo>
    </xs:annotation>
    <xs:sequence>
      <xs:element name="group-DN">
        <xs:annotation>
          <xs:documentation>
            LDAP Group Distriguished Name.
            It is the starting point of the search.
            Example groups:
             dn=cn=Tim,ou=IT-Services,o=Company
             dn=cn=Tina,ou=Management,o=Company
             where Tim and Tina are the extracted identity.
          </xs:documentation>
          <xs:appinfo>
            This distriguish name is utilized as the -b searchbase in an ldapsearch request.
            
            We will need to support the ability of the application developer to specify 
            specific places in the searchbase expression the ability to subsitute:
            1) extracted identity: replace string "%i" or "%extracted-identity"
            2) extracted resource: replace string "%r" or "%extracted-resource"
          </xs:appinfo>
        </xs:annotation>
        <xs:simpleType>
          <xs:restriction base="xs:string">
            <xs:minLength value="1"/>
            <xs:whiteSpace value="collapse"/>
            <!-- todo: add pattern restriction for supporting DN with parameter substitution -->
          </xs:restriction>
        </xs:simpleType>
      </xs:element>
      <xs:element name="group-attribute" minOccurs="0">
        <xs:annotation>
          <xs:documentation>
            LDAP Group Attribute.
            This is an optional attribute used to restrict the retrieved attribute information.
            If group attribute is not present, then all attributes are returned
          </xs:documentation>
          <xs:appinfo>
            In an ldapsearch request, the group attribute is append after the filter expression.
          </xs:appinfo>
        </xs:annotation>
        <xs:simpleType>
          <xs:restriction base="xs:string">
            <xs:minLength value="1"/>
            <xs:whiteSpace value="collapse"/>
            <!-- todo: add pattern restriction for supporting DN with parameter substitution -->
          </xs:restriction>
        </xs:simpleType>
      </xs:element>
      <xs:element name="search-scope" default="subtree">
        <xs:annotation>
          <xs:documentation>Specify the scope of the search</xs:documentation>
          <xs:appinfo>This maps to -s base|one|sub|children parameter on an ldapsearch request</xs:appinfo>
        </xs:annotation>
        <xs:simpleType>
          <xs:restriction base="xs:string">
            <xs:enumeration value="subtree">
              <xs:annotation>
                <xs:documentation>Specifies that the search matches the input and any descendents.</xs:documentation>
              </xs:annotation>
            </xs:enumeration>
            <xs:enumeration value="base">
              <xs:annotation>
                <xs:documentation>Specifies that the search matches only the input itself.</xs:documentation>
              </xs:annotation>
            </xs:enumeration>
            <xs:enumeration value="one-level">
              <xs:annotation>
                <xs:documentation>Specifies that the search matches the search input and any object one-level below.</xs:documentation>
              </xs:annotation>
            </xs:enumeration>
          </xs:restriction>
        </xs:simpleType>
      </xs:element>
      <xs:element name="search-filter" default="(objectClass=*)">
        <xs:annotation>
          <xs:documentation>
            LDAP search filter to allow for customized LDAP searches. 
            LDAP filter syntax is defined in RFC 2254 "The String Representation of LDAP Search Filters", December 1997.            
          </xs:documentation>
          <xs:appinfo>
            As an extension to the LDAP filter syntax that the application developer is specifying, we will need to support the 
            ability of the application developer to specify specific places in the filter expression that we are to subsitute:
            1) extracted identity: replace string "%i" or "%extracted-identity"
            2) extracted resource: replace string "%r" or "%extracted-resource"
            3) LDAP group attribute: replace string "%g" or "%group-attribute"
          </xs:appinfo>
        </xs:annotation>
        <xs:simpleType>
          <xs:restriction base="xs:string">
            <xs:minLength value="3"/>
            <xs:whiteSpace value="collapse"/>
            <!-- todo: add pattern to restrict what can be entered into filter string -->
          </xs:restriction>
        </xs:simpleType>
        <!-- constraint: if %r or %extracted-resource present in filter expression then resourceExtract mechanism must be defined. -->
      </xs:element>
      <!-- deferred to future potential optimzation
      <xs:element name="passwordAttrName" type="aaa:ResultAttrType" default="UserPassword" minOccurs="0">
        <xs:annotation>
          <xs:documentation>
            Name of the directory attribute that holds the username password.
            The name of the searchResponse - searchResultEntry - attr element containing the password associated with this username.

            constraint: this element should only be allowed/visible if the extractedIdentity mechanism is derivedUsernameTokenFromSecurityHeader and 
            identity authentication mechanism is NOT LDAP.
          </xs:documentation>
        </xs:annotation>
      </xs:element>
      -->
      <xs:element name="serverUrl" type="xs:anyURI" minOccurs="0">
        <xs:annotation>
          <xs:documentation>
            Allows AAA Policy writer to bind LDAP IA to a specific backend server.
            This is very useful when automatically using the same AAA policy in multiple places so that they are all bound to same LDAP server.
          </xs:documentation>
          <!-- This element will be mapped to two advanced fields: server host name and port in service designer -->
        </xs:annotation>
      </xs:element>
    </xs:sequence>
    <!-- constraint: When this policy is being bound to an action, Service Designer will need to ask the developer for the following information:
        1) LDAP server address
        2) LDAP server port number. Can be defaulted to 389. 636 for when LDAP over SSL/TLS. Future]
        3) LDAP administator Distinguished Name. This can be default to the LDAP acf config file associated with generated parntnerLink.
        4) LDAP administrator Password. This can be default to the LDAP acf config file associated with generated parntnerLink.
        5) NOT ALLOWED when: 
          a) extract identity is certificateAttributeFromSecurityHeader, certificateFromPeerSsl, 
             x509CertificateFromSecurityHeader, x509CertificateFromWorkflow, bstFromVerifyoperation and
             certificateAttribute is NOT subjectName with extractMostSpecificComponentFromSubjectName set to false.
          b) extract identity is nameFromSamlSubject, nameFromSamlAuthentication or nameFromSamlAttribute.
          c) extract identity is samlArtifact.
          d) extract identity is clientIpAddressFromTransport.
          e) extract identity is principleFromKerberosToken.
    -->
  </xs:complexType>
  <xs:complexType name="SiteMinderAuthorization">
    <xs:annotation>
      <xs:documentation>
        A Netegrity SiteMinder request will be generated to verify that the extracted resource is authorized.
      </xs:documentation>
    </xs:annotation>
    <xs:choice>
      <xs:element name="useSiteMinderAuthenticationParametrizations" type="aaa:EmptyType">
        <xs:annotation>
          <xs:documentation>
            Indicates that SiteMinder Authorization request should use the same values as specified in the associated SiteMinder Authentication
            in the Identity Processing section.
            A separate performance optimization is that Action Builder should not generate the SiteMinder Authentication request because this SiteMinder
            Authorization request functionality will automatically implement the functionality of the SiteMinder Authentication request.
          </xs:documentation>
        </xs:annotation>
        <!-- constraint: only allowed if identity authentication mechanism is SiteMinder -->
      </xs:element>
      <xs:sequence>
        <xs:element name="resource" type="aaa:SiteMinderResourceType"/>
        <xs:element name="action" type="aaa:SiteMinderActions" default="Get"/>
        <xs:element name="serverUrl" type="aaa:SiteMinderServerUrl" minOccurs="0">
          <xs:annotation>
            <xs:documentation>
              Advance SiteMinder server parameterization.
              It is very useful for the AAA Policy generator to specify this when the policy will be utilized in multiple places
              because it allows policy generator to bind all back-end SiteMinder server to the same SiteMinder IA.
            </xs:documentation>
            <xs:appinfo>Should pre-populate this element with value from associated SiteMinder authentication element</xs:appinfo>
          </xs:annotation>
          <!-- constraint: SiteMinder authentication and authorization serverUrl must have same values -->
        </xs:element>
        <xs:element name="ssoOptions" type="aaa:SsoChoices" minOccurs="0">
          <!-- constraint: if extract identity is ssoFromCookie and cookie name is not SMSESSION then generate a warning -->
        </xs:element>
      </xs:sequence>
    </xs:choice>
  </xs:complexType>
  <xs:complexType name="SiteMinderResourceType">
    <xs:annotation>
      <xs:documentation>Defines the resource to be passed to SiteMinder authentication mechanism</xs:documentation>
    </xs:annotation>
    <xs:choice>
      <xs:element name="use-extracted-resource" type="xs:NMTOKEN" fixed="internal-name:AuthorizationResource">
        <xs:annotation>
          <xs:documentation>Use the extracted resource.</xs:documentation>
        </xs:annotation>
        <!-- constraint: only allowed if ResourceExtraction mechanism has been specified -->
      </xs:element>
      <xs:element name="staticValue" default="/">
        <xs:annotation>
          <xs:documentation>Allow application to hardcode resource value</xs:documentation>
        </xs:annotation>
        <xs:simpleType>
          <xs:restriction base="xs:anyURI">
            <xs:minLength value="1"/>
          </xs:restriction>
        </xs:simpleType>
      </xs:element>
      <xs:element name="inputFromWorkflow" type="xs:string">
        <xs:annotation>
          <xs:appinfo>Service Designer should populate the string value to: SiteMinder_Resource</xs:appinfo>
          <xs:documentation>
            Application developer will supply resource value from workflow when AAA policy bound to action.
          </xs:documentation>
        </xs:annotation>
      </xs:element>
    </xs:choice>
    <xs:attribute name="type" use="required" fixed="anyURI">
      <xs:annotation>
        <xs:appinfo>Not to be displayed. Must be populated by policy editor.</xs:appinfo>
      </xs:annotation>
    </xs:attribute>
  </xs:complexType>
  <xs:simpleType name="SiteMinderActions">
    <xs:annotation>
      <xs:documentation>
        Currently, only Web Agent related actions can be used for authetnication or authorization requests.
        
        Rules with a Web Agent action either allow or deny access to the resource(s) specified by a rule when one of the HTTP actions 
        specified in the rule occur. When a rule that specifies Allow Access fires, if a user authenticates successfully, SiteMinder allows 
        the user to access the specified resource. If a rule specifies Deny Access, SiteMinder denies access to the successfully 
        authenticated user. Deny access rules may be added to policies to provide an additional layer of security by rejecting specific 
        individuals or groups who should not have access to a resource. Allow Access is the default. Deny access rules take precedence 
        over allow access rules. If a deny access rule and an allow access rule fire when a user attempts to access a resource, the 
        presence of the deny access rule overrides all allow access rules.
      </xs:documentation>
    </xs:annotation>
    <xs:restriction base="xs:string">
      <xs:enumeration value="Get">
        <xs:annotation>
          <xs:documentation>Retrieves a resource for viewing via HTTP.</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="Post">
        <xs:annotation>
          <xs:documentation>Supports legacy HTTP actions.</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="Put">
        <xs:annotation>
          <xs:documentation>Posts information supplied by a user via HTTP.</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <!-- Do not believe that we can ever support these in our use case:
      <xs:enumeration value="ProcessSOAP">
        <xs:annotation>
          <xs:documentation>
            Supports incoming XML messages wrapped with a SOAP envelope.
            This action is only supported when TransactionMinder has been purchased.
          </xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="ProcessXML">
        <xs:annotation>
          <xs:documentation>
            Supports incoming raw XML messages (not wrapped with a SOAP envelope.
            This action is only supported when TransactionMinder has been purchased.
          </xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      -->
      <!-- following enumerations associated with other class of actions: Authentication Events, Authorization Event & ImpersonateUser Events,
           i.e., Affiliate Agents. Affiliate Agents are SiteMinder Agents that communicate with SiteMinder Web Agents installed on the Web 
           servers of a portal Web site. Affiliate Agent rules are very simple, since they do not protect the resources of an affiliate Web site. 
           The Affiliate Agent processes responses sent from the portal site, so that applications on the affiliate Web site may take advantage of 
           the information gathered about users on the SiteMinder protected portal Web site. 
           Affiliate Agent actions are only available (in place of Web Agent actions) for realms associated with an Affiliate Agent. There is only 
           one possible action: Visit. 
           Bottom line: do not see any use case for SOAE interaction with Afflicate Agents, i.e., will not support at this time.
      Authentication Events:
      <xs:enumeration value="OnAuthAccept"/>
      <xs:enumeration value="OnAuthAttempt"/>
      <xs:enumeration value="OnAuthChallenge"/>
      <xs:enumeration value="OnAuthReject"/>
      Authorization Events:
      <xs:enumeration value="OnAuthUserNotFound"/>
      <xs:enumeration value="OnAccessAccept"/>
      <xs:enumeration value="OnAccessReject"/>
      ImpersonateUser Events:
      <xs:enumeration value="ImpersonateStart"/>
      <xs:enumeration value="ImpersonateStartUser"/>
      -->
    </xs:restriction>
  </xs:simpleType>
  <xs:complexType name="OracleAccessManagerAuthorization">
    <xs:annotation>
      <xs:documentation>
        An Oracle Access Manager request will be generated to verify that the extracted resource is authorized.
      </xs:documentation>
    </xs:annotation>
    <xs:choice>
      <xs:element name="useOracleAccessManagerAuthenticationParametrizations" type="aaa:EmptyType">
        <xs:annotation>
          <xs:documentation>
            Indicates that Oracle Access Manager Authorization request should use the same values as specified in the associated Oracle Access 
            Manager Authentication in the Identity Processing section.
            A separate performance optimization is that Action Builder should not generate the Oracle Access Manager Authentication request because 
            this Oracle Access Manager Authorization request functionality will automatically implement the functionality of the Oracle Access 
            Manager Authentication request.
          </xs:documentation>
        </xs:annotation>
        <!-- constraint: only allowed if identity authentication mechanism is Oracle Access Manager -->
      </xs:element>
      <xs:sequence>
        <xs:element name="resource" type="aaa:OracleAccessManagerResourceType"/>
        <xs:element name="method" type="aaa:OracleAccessManagerMethods" default="Get"/>
        <xs:element name="oracleInstallationDirectory" type="xs:anyURI" minOccurs="0">
          <xs:annotation>
            <xs:documentation>
              Allows AAA Policy writer to bind Oracle Access Manager IA to a specific backend server.
              This is very useful when automatically using the same AAA policy in multiple places so that they are all bound to same OAM server.
            </xs:documentation>
            <xs:appinfo>Should pre-populate this element with value from associated Oracle Access Manager authentication element</xs:appinfo>
          </xs:annotation>
          <!-- constraint: Oracle Access Manager authentication and authorization oracleInstallationDirectory must have same values -->
        </xs:element>
        <xs:element name="ssoOptions" type="aaa:SsoChoices" minOccurs="0">
          <!-- constraint: if extract identity is ssoFromCookie and cookie name is not ObSSOCookie then generate a warning -->
        </xs:element>
      </xs:sequence>
    </xs:choice>
  </xs:complexType>
  <xs:complexType name="OracleAccessManagerResourceType">
    <xs:annotation>
      <xs:documentation>Defines the resource to be passed to Oracle Access Manager authentication mechanism</xs:documentation>
    </xs:annotation>
    <xs:choice>
      <xs:element name="use-extracted-resource" type="xs:NMTOKEN" fixed="internal-name:AuthorizationResource">
        <xs:annotation>
          <xs:documentation>Use the extracted resource.</xs:documentation>
        </xs:annotation>
        <!-- constraint: only allowed if ResourceExtraction mechanism has been specified -->
      </xs:element>
      <xs:element name="staticValue" default="/">
        <xs:annotation>
          <xs:documentation>Allow application to hardcode resource value</xs:documentation>
        </xs:annotation>
        <xs:simpleType>
          <xs:restriction base="xs:anyURI">
            <xs:minLength value="1"/>
          </xs:restriction>
        </xs:simpleType>
      </xs:element>
      <xs:element name="inputFromWorkflow" type="xs:string">
        <xs:annotation>
          <xs:appinfo>Service Designer should populate the string value to: Oracle-Access-Manager_Resource</xs:appinfo>
          <xs:documentation>
            Application developer will supply resource value from workflow when AAA policy bound to action.
          </xs:documentation>
        </xs:annotation>
      </xs:element>
    </xs:choice>
    <xs:attribute name="type" use="required" fixed="anyURI">
      <xs:annotation>
        <xs:appinfo>Not to be displayed. Must be populated by policy editor.</xs:appinfo>
      </xs:annotation>
    </xs:attribute>
  </xs:complexType>
  <xs:simpleType name="OracleAccessManagerMethods">
    <xs:annotation>
      <xs:documentation/>
    </xs:annotation>
    <xs:restriction base="xs:string">
      <xs:enumeration value="Get">
        <xs:annotation>
          <xs:documentation>Retrieves a resource for viewing via HTTP.</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="Post">
        <xs:annotation>
          <xs:documentation>Posts information supplied by a user via HTTP.</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
    </xs:restriction>
  </xs:simpleType>
  <xs:complexType name="TivoliAccessManagerAuthorization">
    <xs:annotation>
      <xs:documentation>
        An Tivoli Access Manager request will be generated to verify that the extracted resource is authorized.
        
        If the application developer does not specfy a default action, then the resourceActionMap element must be populated.
        Since the application specified resourceActionMap XPath expressions specified may not match all valid resources,
        this will only be discovered at runtime that their is a missing resourceActionMap rule.
        It is the APPLICATION DEVELOPER RESPONSIBILITY to ENSURE that ALL VALID RESOURCES WILL AT LEAST ACTION SPECIFIED!
        
        Additionally, Service Designer policy editor can only perform coarse verification that the specified XPath expressions are 
        valided, e.g., balance quotes, panathesis, etc.
      </xs:documentation>
    </xs:annotation>
    <xs:sequence>
      <xs:element name="resource" type="aaa:TivoliAccessManagerResourceType">
        <xs:annotation>
          <xs:appinfo>Service Designer policy editor should default field to use-extracted-resource</xs:appinfo>
        </xs:annotation>
      </xs:element>
      <xs:element name="defaultAction" type="aaa:TivoliAccessManagerActions" default="T" minOccurs="0"/>
      <xs:element name="resourceActionMap" type="aaa:TivoliResourceActionMap" minOccurs="0" maxOccurs="unbounded"/>
      <xs:element name="tivoliAccessManagerConfigUrl" type="aaa:TivoliAccessManagerConfigUrl" minOccurs="0">
        <xs:annotation>
          <xs:appinfo>Should pre-populate this element with value from associated Tivoli Access Manager authentication element</xs:appinfo>
        </xs:annotation>
        <!-- constraint: Tivoli Access Manager authentication and authorization tivoliAccessManagerConfigUrl must have same values -->
      </xs:element>
      <!-- constraint: either or both defaultAction or resourceActionMap elements must be populated -->
    </xs:sequence>
    <!-- from some examples this does not appear to map sense like for SiteMinder or OAM
    <xs:choice>
      <xs:element name="useTivoliAccessManagerAuthenticationParametrizations" type="aaa:EmptyType">
        <xs:annotation>
          <xs:documentation>
            Indicates that Tivoli Access Manager Authorization request should use the same values as specified in the associated Tivoli Access 
            Manager Authentication in the Identity Processing section.
            A separate performance optimization is that Action Builder should not generate the Tivoli Access Manager Authentication request because 
            this Tivoli Access Manager Authorization request functionality will automatically implement the functionality of the Tivoli Access 
            Manager Authentication request.
          </xs:documentation>
        </xs:annotation>
      </xs:element>
    -->
    <!--  does not appear to be map sense
    </xs:choice>
    -->
    <!-- constraint: only allowed if identity authentication mechanism is Tivoli Access Manager -->
  </xs:complexType>
  <xs:complexType name="TivoliAccessManagerResourceType">
    <xs:annotation>
      <xs:documentation>Defines the resource to be passed to Tivoli Access Manager authentication mechanism</xs:documentation>
    </xs:annotation>
    <xs:choice>
      <xs:element name="use-extracted-resource" type="xs:NMTOKEN" fixed="internal-name:AuthorizationResource">
        <xs:annotation>
          <xs:documentation>Use the extracted resource.</xs:documentation>
        </xs:annotation>
        <!-- constraint: only allowed if ResourceExtraction mechanism has been specified -->
      </xs:element>
      <xs:element name="staticValue" type="xs:anyURI" default="/">
        <xs:annotation>
          <xs:documentation>Allow application to hardcode resource value</xs:documentation>
        </xs:annotation>
      </xs:element>
      <xs:element name="inputFromWorkflow" type="xs:string">
        <xs:annotation>
          <xs:appinfo>Service Designer should populate the string value to: Tivoli-Access-Manager_Resource</xs:appinfo>
          <xs:documentation>
            Application developer will supply resource value from workflow when AAA policy bound to action.
          </xs:documentation>
        </xs:annotation>
      </xs:element>
    </xs:choice>
    <xs:attribute name="type" use="required" fixed="anyURI">
      <xs:annotation>
        <xs:appinfo>Not to be displayed. Must be populated by policy editor.</xs:appinfo>
      </xs:annotation>
    </xs:attribute>
  </xs:complexType>
  <xs:complexType name="TivoliResourceActionMap">
    <xs:annotation>
      <xs:documentation>
        Allows a AAA policy to use different ACL actions during authorization based on the requested resource.
        
        Application developer can use XPath expression upon extracted resource to identify ZERO OR MORE specific actions that
        the Tivoli Access Manager authorization request should check that this user has permission to access the specified resource.
        These actions are in addition to the default action.
      </xs:documentation>
    </xs:annotation>
    <xs:sequence>
      <xs:element name="resourceRegExpressionMatch">
        <xs:simpleType>
          <xs:restriction base="xs:string">
            <xs:minLength value="1"/>
          </xs:restriction>
        </xs:simpleType>
      </xs:element>
      <xs:element name="action" type="aaa:TivoliAccessManagerActions" maxOccurs="unbounded"/>
    </xs:sequence>
  </xs:complexType>
  <xs:simpleType name="TivoliAccessManagerActions">
    <xs:annotation>
      <xs:documentation>
      </xs:documentation>
    </xs:annotation>
    <xs:restriction base="xs:string">
      <xs:enumeration value="T">
        <xs:annotation>
          <xs:documentation>Description: Traverse, Category: Base; permission lets you control access to whole branches of resources efficiently</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="A">
        <xs:annotation>
          <xs:documentation>Description: Add, Category: Base</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="a">
        <xs:annotation>
          <xs:documentation>Description: Attach an ACL or POP. Category: Base</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="B">
        <xs:annotation>
          <xs:documentation>
            Description: Bypass protected object policies (POP), Category: Base. 
            Causes any POP policy associated with the object to be overridden, for example, any time-of-day restriction applicable is 
            not applied. Policy administrators need this permission in order to administer policy on objects that are subject to time-of-day 
            access restrictions or havewarning audit level enabled.
          </xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="b">
        <xs:annotation>
          <xs:documentation>Description: Browse object space and see object names, Category: Base.</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="c">
        <xs:annotation>
          <xs:documentation>Description: Control or modify an ACL, Category: Base.</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="d">
        <xs:annotation>
          <xs:documentation>Description: Delete an object, Category: Generic.</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="[PDMQ]D">
        <xs:annotation>
          <xs:documentation>
            Description: TAMBI Dequeue. 
            When this action is populated into the actual action list for TAM by the extension function it will need to be populated with the 
            following string: "[PDMQ]D". When the TAMBI action [PDMQ]E is also required, these two actions should be packaged as a single action 
            string: "[PDMQ]ED".
          </xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="[PDMQ]E">
        <xs:annotation>
          <xs:documentation>
            Description: TAMBI Enqueue. 
            When this action is populated into the actual action list for TAM by the extension function it will need to be populated with the 
            following string: "[PDMQ]E". When the TAMBI action [PDMQ]D is also required, these two actions should be packaged as 
            a single action string: "[PDMQ]ED".
          </xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="g">
        <xs:annotation>
          <xs:documentation>Description: Delegate, Category: Base</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="l">
        <xs:annotation>
          <xs:documentation>Description: List directory, Category: Application, Resource Type: file</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="m">
        <xs:annotation>
          <xs:documentation>Description: Modify an objects attributes, Category: Generic</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="N">
        <xs:annotation>
          <xs:documentation>Description: Create, Category: Base, Resource Type: file</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="R">
        <xs:annotation>
          <xs:documentation>Description: Bypass check for authorization rules, Category: Base.</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="r">
        <xs:annotation>
          <xs:documentation>Description: Read, Category: Application, Resource Type: file</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="s">
        <xs:annotation>
          <xs:documentation>Description: Server Administration, Category: Generic.</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="t">
        <xs:annotation>
          <xs:documentation>Description: Trace, Category: Base.</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="v">
        <xs:annotation>
          <xs:documentation>Description: View the attributes of an object, Category: Generic</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="W">
        <xs:annotation>
          <xs:documentation>Description: Password, Category: Base.</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="x">
        <xs:annotation>
          <xs:documentation>Description: Execute, category: Application, Resource Type: file and Sudo</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
    </xs:restriction>
  </xs:simpleType>
  <xs:simpleType name="TivoliAccessManagerConfigUrl">
    <xs:annotation>
      <xs:documentation>
        Allows AAA Policy writer to bind Tivoli Access Manager IA to a specific Tivoli Access Manager runtime application.
        IBM installation procedure maps all the configuration information into a single fixed name jar and associated configuration file.
        In particular, the configuration file:
          configURL - a URL reference to configuration data. The caller must have permission to access and read this URL. 
          This URL is the same as the one specified to the com.tivoli.pd.jcfg.SvrSslCfg configuration program. (from IBM Tivoli documentation)
          
        This implies that there can only be a single TAM IA with a single set of configuration values in use at any time, i.e., single IA.
        
        We will map the pathname to the configuration file as:
          tivoliam://path-to-configuration-file
      </xs:documentation>
    </xs:annotation>
    <xs:restriction base="xs:anyURI"/>
  </xs:simpleType>
  <xs:complexType name="SamlAttributeAssertionAuthorization">
    <xs:sequence>
      <xs:element name="mustMatchAtLeastOneName" type="aaa:SamlAttributeMatchNameType" minOccurs="0"/>
      <xs:element name="mustMatchAllNames" type="aaa:SamlAttributeMatchNameType" minOccurs="0"/>
      <xs:element name="mustMatchAllNameValues" type="aaa:SamlAttributeMatchNameValueType" minOccurs="0"/>
      <xs:element name="mustMatchAtLeastOneNameValue" type="aaa:SamlAttributeMatchNameValueType" minOccurs="0"/>
    </xs:sequence>
  </xs:complexType>
  <xs:complexType name="SamlAssertionAuthorization">
    <xs:sequence>
      <xs:element name="mustMatchAtLeastOneName" type="aaa:SamlMatchNameType" minOccurs="0"/>
      <xs:element name="mustMatchAllNames" type="aaa:SamlMatchNameType" minOccurs="0"/>
      <xs:element name="mustMatchAllNameValues" type="aaa:SamlMatchNameValueType" minOccurs="0"/>
      <xs:element name="mustMatchAtLeastOneNameValue" type="aaa:SamlMatchNameValueType" minOccurs="0"/>
    </xs:sequence>
  </xs:complexType>
  <xs:complexType name="SamlAttributeMatchNameType">
    <xs:sequence>
      <xs:element name="AttributeStatement-Attribute-AttributeValue" type="xs:boolean" default="false" minOccurs="0">
        <!-- constraint: SAML v1.0, 1.1 & 2.0 -->
      </xs:element>
      <xs:element name="Attribute-Name-Attrib" type="xs:boolean" default="false" minOccurs="0">
        <!-- constraint: SAML v1.0, 1.1 & 2.0 -->
      </xs:element>
      <xs:element name="AttributeStatement-Attribute-FriendlyName-Attrib" type="xs:boolean" default="false" minOccurs="0">
        <!-- constraint: SAML v2.0 only -->
      </xs:element>
    </xs:sequence>
  </xs:complexType>
  <xs:complexType name="SamlMatchNameType">
    <xs:sequence>
      <xs:element name="Authorization-Decision-Attrib" type="xs:boolean" default="false" minOccurs="0">
        <!-- constraint: SAML v1.0, 1.1 & 2.0 -->
      </xs:element>
      <xs:element name="Authorization-Resource-Attrib" type="xs:boolean" default="false" minOccurs="0">
        <!-- constraint: SAML v1.0, 1.1 & 2.0; type: anyURI -->
      </xs:element>
      <xs:element name="Authorization-Action" type="xs:boolean" default="false" minOccurs="0">
        <!-- constraint: SAML v1.0, 1.1 & 2.0 -->
      </xs:element>
      <xs:element name="AttributeStatement-Attribute-AttributeValue" type="xs:boolean" default="false" minOccurs="0">
        <!-- constraint: SAML v1.0, 1.1 & 2.0 -->
      </xs:element>
      <xs:element name="Attribute-Name-Attrib" type="xs:boolean" default="false" minOccurs="0">
        <!-- constraint: SAML v1.0, 1.1 & 2.0 -->
      </xs:element>
      <xs:element name="AttributeStatement-Attribute-FriendlyName-Attrib" type="xs:boolean" default="false" minOccurs="0">
        <!-- constraint: SAML v2.0 only -->
      </xs:element>
    </xs:sequence>
  </xs:complexType>
  <xs:complexType name="SamlAttributeMatchNameValueType">
    <xs:sequence>
      <xs:element name="AttributeStatement-Attribute-AttributeValue" type="aaa:SamlString" minOccurs="0" maxOccurs="unbounded">
        <!-- type should be SamlAppExtPt but for this release we will only support checking first level value -->
        <!-- constraint: SAML v1.0, 1.1 & 2.0; type: anyType -->
      </xs:element>
      <xs:element name="Attribute-Name-Attrib" type="aaa:SamlString" minOccurs="0" maxOccurs="unbounded">
        <!-- constraint: SAML v1.0, 1.1 & 2.0; type: string -->
      </xs:element>
      <xs:element name="AttributeStatement-Attribute-FriendlyName-Attrib" type="aaa:SamlString" minOccurs="0" maxOccurs="unbounded">
        <!-- constraint: SAML v2.0 only; type: string -->
      </xs:element>
      <xs:element name="AttributeStatement-Attribute-NameValue-Pair" type="aaa:AttributeNameValuePair" minOccurs="0" maxOccurs="unbounded"/>
    </xs:sequence>
  </xs:complexType>
  <xs:complexType name="SamlMatchNameValueType">
    <xs:sequence>
      <xs:element name="Authorization-Decision-Attrib" type="aaa:DecisionType" minOccurs="0">
        <!-- constraint: SAML v1.0, 1.1 & 2.0; type: string with restriction, DecisionType -->
      </xs:element>
      <xs:element name="Authorization-Resource-Attrib" minOccurs="0">
        <xs:complexType>
          <xs:choice>
            <xs:element name="useExtractedResource" type="xs:NMTOKEN" fixed="internal-name:use-extracted-resource">
              <xs:annotation>
                <xs:documentation>
                  Compare the extracted resource with the resource URI in the SAML assertion authorization statement
                </xs:documentation>
              </xs:annotation>
              <!-- constraint: only allowed if ResourceExtraction mechanism has been specified -->
            </xs:element>
            <xs:element name="staticValue" type="xs:anyURI">
              <xs:annotation>
                <xs:documentation>Allow application to hardcode the name of the resouce</xs:documentation>
              </xs:annotation>
            </xs:element>
            <xs:element name="inputFromWorkflow" type="xs:string">
              <xs:annotation>
                <xs:documentation>
                  Application developer will supply resource URI from workflow when AAA policy bound to action.
                </xs:documentation>
              </xs:annotation>
            </xs:element>
          </xs:choice>
        </xs:complexType>
        <!-- constraint: SAML v1.0, 1.1 & 2.0; type: anyURI -->
      </xs:element>
      <xs:element name="Authorization-Action" type="aaa:SamlString" minOccurs="0" maxOccurs="unbounded">
        <!-- constraint: SAML v1.0, 1.1 & 2.0; type: string -->
      </xs:element>
      <xs:element name="AttributeStatement-Attribute-AttributeValue" type="aaa:SamlString" minOccurs="0" maxOccurs="unbounded">
        <!-- type should be SamlAppExtPt but for this release we will only support checking first level value -->
        <!-- constraint: SAML v1.0, 1.1 & 2.0; type: anyType -->
      </xs:element>
      <xs:element name="Attribute-Name-Attrib" type="aaa:SamlString" minOccurs="0" maxOccurs="unbounded">
        <!-- constraint: SAML v1.0, 1.1 & 2.0; type: string -->
      </xs:element>
      <xs:element name="AttributeStatement-Attribute-FriendlyName-Attrib" type="aaa:SamlString" minOccurs="0" maxOccurs="unbounded">
        <!-- constraint: SAML v2.0 only; type: string -->
      </xs:element>
      <xs:element name="AttributeStatement-Attribute-NameValue-Pair" type="aaa:AttributeNameValuePair" minOccurs="0" maxOccurs="unbounded"/>
    </xs:sequence>
  </xs:complexType>
  <xs:complexType name="AttributeNameValuePair">
    <xs:annotation>
      <xs:documentation>Check that both a specific attri bute name and value are present</xs:documentation>
    </xs:annotation>
    <xs:sequence>
      <xs:element name="Attribute-Name-Attrib" type="aaa:SamlString">
        <!-- constraint: SAML v1.0, 1.1 & 2.0; type: string -->
      </xs:element>
      <xs:element name="AttributeStatement-Attribute-AttributeValue" type="aaa:SamlString">
        <!-- type should be SamlAppExtPt but for this release we will only support checking first level value -->
        <!-- constraint: SAML v1.0, 1.1 & 2.0; type: anyType -->
      </xs:element>
    </xs:sequence>
  </xs:complexType>
  <xs:simpleType name="SamlAuthorizationEntities">
    <xs:restriction base="xs:string">
      <xs:enumeration value="AttributeStatement-Attribute-AttributeValue">
        <xs:annotation>
          <xs:appinfo>Since this an be of "anyType", I can not see anysimple solution but using canonlicization on this data before comparing values.</xs:appinfo>
        </xs:annotation>
        <!-- constraint: SAML v1.0, 1.1 & 2.0; type: anyType -->
      </xs:enumeration>
      <xs:enumeration value="Authorization-Action">
        <xs:annotation>
          <xs:documentation>
            Maps to AuthzDecisionStatement-Action in SAML v2.0, and AuthorizationDecisionStatement-Action in SAML V1.0 and 1.1
          </xs:documentation>
        </xs:annotation>
        <!-- constraint: SAML v1.0, 1.1 & 2.0; type: string -->
      </xs:enumeration>
      <xs:enumeration value="Authorization-Resource-Attrib">
        <xs:annotation>
          <xs:documentation>
            Maps to AuthzDecisionStatement-Resource attribute in SAML v2.0, and 
            AuthorizationDecisionStatement-Resource attribute in SAML V1.0 and 1.1
          </xs:documentation>
        </xs:annotation>
        <!-- constraint: SAML v1.0, 1.1 & 2.0; type: anyURI -->
      </xs:enumeration>
      <xs:enumeration value="Authorization-Decision-Attrib">
        <xs:annotation>
          <xs:documentation>
            Maps to AuthzDecisionStatement-Decision attribute in SAML v2.0, and 
            AuthorizationDecisionStatement-Decision attribute in SAML V1.0 and 1.1
          </xs:documentation>
        </xs:annotation>
        <!-- constraint: SAML v1.0, 1.1 & 2.0; type: string with restriction, DecisionType -->
      </xs:enumeration>
      <xs:enumeration value="Attribute-Name-Attrib">
        <xs:annotation>
          <xs:documentation>
            Maps to AttributeStatement-Attribute-Name attribute in SAML v2.0, and 
            AttributeStatement-Attribute-AttributeName attribute in SAML V1.0 and 1.1
          </xs:documentation>
        </xs:annotation>
        <!-- constraint: SAML v1.0, 1.1 & 2.0; type: string -->
      </xs:enumeration>
      <xs:enumeration value="AttributeStatement-Attribute-FriendlyName-Attrib">
        <!-- constraint: SAML v2.0 only; type: string -->
      </xs:enumeration>
      <!-- deferred
      <xs:enumeration value="AttributeStatement-Attribute-AttributeNamespace-Attrib">
        <xs:annotation><xs:documentation>constraint: SAML v1.0 and 1.1 only; type: anyURI</xs:documentation></xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="AttributeStatement-Attribute-NameFormat-Attrib">
        <xs:annotation><xs:documentation>constraint: SAML v2.0 only; type: anyURI with restrictions, NameFormatType</xs:documentation></xs:annotation>
      </xs:enumeration>
      -->
    </xs:restriction>
  </xs:simpleType>
  <xs:complexType name="v1dotxAttributeQuery">
    <xs:annotation>
      <xs:documentation>Contains information to generate V1.0 and V1.1 SAML Attribute Query</xs:documentation>
    </xs:annotation>
    <xs:sequence>
      <xs:element name="Subject-NameIdentifier" type="aaa:AuthenticationSubjectNameIdentifierValue"/>
      <xs:element name="Subject-NameIdentifier-NameQualifier-Attribute" type="aaa:SamlString" minOccurs="0">
        <xs:annotation>
          <xs:appinfo>Constraint: Service Designer should populate the value for inputFromWorkflow to: SAML-assertion_Subject_NameIdentifier_NameQualifier</xs:appinfo>
        </xs:annotation>
      </xs:element>
      <xs:element name="Subject-NameIdentifier-Format-Attribute" type="aaa:NameIdFormatType" default="urn:oasis:names:tc:SAML:1.1:nameid-format:unspecified"/>
      <xs:element name="Attribute" minOccurs="0" maxOccurs="unbounded">
        <xs:annotation>
          <xs:documentation>
            Allows application developer to specify how a SAML Attribute element should be generated from its individual pieces.
          </xs:documentation>
        </xs:annotation>
        <!-- constraint: REQUIRED either ((one or more Attribute elements) OR (AttributesFromWorkflow element)) must be populated -->
        <xs:complexType>
          <xs:sequence>
            <xs:element name="AttributeName" type="aaa:SamlString"/>
            <xs:element name="AttributeNamespace" type="aaa:SamlAttributeNamespaceUri"/>
            <xs:element name="AttributeValue" type="aaa:SamlAppExtPt" minOccurs="0" maxOccurs="unbounded"/>
          </xs:sequence>
        </xs:complexType>
      </xs:element>
      <xs:element name="AttributesFromWorkflow" type="aaa:AttributesFromWorkflowType" minOccurs="0">
        <xs:annotation>
          <xs:documentation>
            Allows application developer to build one or more SAML Attribute elements in their workflow and have them package within the
            SAML Attribute Query being generated.
            Application is totally responsible for ensuring that the SAML Attribute elements being supplied are valid within the SAML 
            assertion being generated, e.g., all prefixes are defined.
          </xs:documentation>
        </xs:annotation>
      </xs:element>
    </xs:sequence>
  </xs:complexType>
  <xs:complexType name="SamlAttributeQuery">
    <xs:annotation>
      <xs:documentation>
        SAML Attribute Query is composed of three major sub-components:
        1) SAML Attribute Query generation
        2) Verify SAML Attribute Response embedded SAML Assertion.
        3) Verify SAML Attribute meets application requirements
      </xs:documentation>
    </xs:annotation>
    <xs:sequence>
      <!-- Need to revise SamlAssertionAuthorization for attribute query response only having attribute data -->
      <xs:element name="attributeQueryRequest">
        <xs:annotation>
          <xs:documentation>Contains information needed to populate the SAML Attribute Query Request</xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:sequence>
            <xs:choice>
              <xs:element name="v1dotx" type="aaa:v1dotxAttributeQuery"/>
              <xs:element name="v2dot0" type="aaa:v2dot0AttributeQuery"/>
            </xs:choice>
            <xs:element name="signatureInfo" type="aaa:SamlSignatureInfo" minOccurs="0">
              <xs:annotation>
                <xs:documentation>
                  Optional signature information for an embedded signature within the SAML Attribute Query
                </xs:documentation>
              </xs:annotation>
            </xs:element>
            <xs:element name="encryptionInfo" type="aaa:EncryptionInfo" minOccurs="0">
              <xs:annotation>
                <xs:documentation>
                  Optional encryption information for embedded NameID, BaseID and Attribute elements within the SAML Attribute Query
                </xs:documentation>
              </xs:annotation>
            </xs:element>
            <xs:element name="wsSecurityPolicyGroup" type="xs:string" minOccurs="0">
              <xs:annotation>
                <xs:documentation>
                  Optional WS-Security Policy Group that is to be applied to the SAML Attribute query request and response that will be sent.
                  On the request, this policy will normally be used to generate a WS-Security signature over the SAML Attribute Query request message.
                  On the response, this policy will normally be used to generate a WS-Security verify over the SAML Attribute Query response.
                </xs:documentation>
              </xs:annotation>
              <!-- constraint: name specified must match a WS-Security Group policy known to SD associated with this application -->
            </xs:element>
            <xs:element name="serverUrl" type="xs:anyURI" minOccurs="0">
              <xs:annotation>
                <xs:documentation>
                  Allows AAA Policy writer to bind LDAP IA to a specific backend SAML Attribute server.
                  This is very useful when automatically using the same AAA policy in multiple places so that they are all bound to same 
                  SAML Attribute server.
                </xs:documentation>
                <!-- This element will be mapped to two advanced fields: server host name and port in service designer. -->
              </xs:annotation>
            </xs:element>
          </xs:sequence>
        </xs:complexType>
      </xs:element>
      <xs:element name="verifyAttributeQueryResponseAssertion" type="aaa:VerifyDecryptInitialValidateSamlAssertion"/>
      <xs:element name="checkAttributes" type="aaa:SamlAttributeAssertionAuthorization"/>
    </xs:sequence>
  </xs:complexType>
  <xs:complexType name="v2dot0AttributeQuery">
    <xs:annotation>
      <xs:documentation>Contains information to generate V2.0 SAML Attribute Query</xs:documentation>
    </xs:annotation>
    <xs:sequence>
      <xs:element name="NameID-NameQualifier-Attribute" type="aaa:SamlString" minOccurs="0"/>
      <!-- deferred
          <xs:element name="NameID-SPNameQualifier-Attribute" type="aaa:SamlString" minOccurs="0"/>
          -->
      <xs:element name="NameID-Format-Attribute" type="aaa:SamlNameIdFormat" minOccurs="0"/>
      <!-- deferred 
          <xs:element name="NameID-SPProvidedID-Attribute" type="aaa:SamlString" minOccurs="0"/>
          -->
      <xs:element name="NameID">
        <xs:annotation>
          <xs:documentation>Identifies the intended subject of the SAML Attribute Query</xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="aaa:AuthenticationSubjectNameIdentifierValue">
              <xs:sequence>
                <xs:element name="encryptID" type="xs:boolean" default="false" minOccurs="0">
                  <xs:annotation>
                    <xs:documentation>Indicates if associated NameID is to be encrypted.</xs:documentation>
                  </xs:annotation>
                  <!-- constraint: if encrypt is TRUE then encryptionInfo must be populated -->
                </xs:element>
              </xs:sequence>
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>
      <xs:element name="queryIssuer" type="aaa:SamlString" minOccurs="0">
        <xs:annotation>
          <xs:documentation>BAE 2.0 standard requires SAML Attribute Query Issuer to be populated</xs:documentation>
        </xs:annotation>
      </xs:element>
      <xs:element name="Destination" type="aaa:SamlUri" minOccurs="0">
        <xs:annotation>
          <xs:documentation>
            A URI reference indicating the address to which this request has been sent. This is useful to prevent malicious 
            forwarding of requests to unintended recipients, a protection that is required by some protocol bindings. If it is 
            present, the actual recipient MUST check that the URI reference identifies the location at which the message was 
            received. If it does not, the request MUST be discarded. Some protocol bindings may require the use of this attribute.
          </xs:documentation>
          <xs:appinfo>
            This information gets package within an attribute that is part of samlp:AttributeQuery.
          </xs:appinfo>
        </xs:annotation>
      </xs:element>
      <xs:element name="Consent" type="aaa:ConsentType" default="urn:oasis:names:tc:SAML:2.0:consent:unspecified" minOccurs="0"/>
      <xs:element name="Attribute" minOccurs="0" maxOccurs="unbounded">
        <xs:annotation>
          <xs:documentation>
            Allows application developer to specify how a SAML Attribute element should be generated from its individual pieces.
          </xs:documentation>
        </xs:annotation>
        <!-- constraint: if (((one or more Attribute elements) OR (AttributesFromWorkflow element)) not be populated) 
                         then WARNING that we will be requesting that all associated attributes are to be retrieved.
        -->
        <xs:complexType>
          <xs:sequence>
            <xs:element name="Name-attribute" type="aaa:SamlString"/>
            <xs:element name="NameFormat-attribute" type="aaa:NameFormatType" minOccurs="0"/>
            <xs:element name="FriendlyName-attribute" type="aaa:SamlString" minOccurs="0"/>
            <!-- deferred until someone shows actual need for this
            <xs:element name="AnyAttribute" type="aaa:SamlString" minOccurs="0" maxOccurs="unbounded">
              <xs:annotation>
                <xs:documentation>Standard allows application to supply any attribute name/value here.</xs:documentation>
              </xs:annotation>
            </xs:element>
            -->
            <xs:element name="AttributeValue" type="aaa:SamlAppExtPt" minOccurs="0" maxOccurs="unbounded"/>
            <xs:element name="encryptAttribute" type="xs:boolean" default="false" minOccurs="0">
              <xs:annotation>
                <xs:documentation>Indicates if associated Attribute is to be encrypted</xs:documentation>
              </xs:annotation>
            </xs:element>
          </xs:sequence>
        </xs:complexType>
      </xs:element>
      <xs:element name="AttributesFromWorkflow" type="aaa:AttributesFromWorkflowType" minOccurs="0">
        <xs:annotation>
          <xs:documentation>
            Allows application developer to build one or more SAML Attribute elements in their workflow and have them package within the
            SAML Attribute Query being generated.
            Application is totally responsible for ensuring that the SAML Attribute elements being supplied are valid within the SAML 
            assertion being generated, e.g., all prefixes are defined.
          </xs:documentation>
        </xs:annotation>
      </xs:element>
    </xs:sequence>
  </xs:complexType>
  <xs:complexType name="OracleEntitlementServerXacmlAuthorization">
    <xs:annotation>
      <xs:documentation>
        An Oracle Entitlement Server XACML request will be generated to verify that the extracted resource is authorized.
      </xs:documentation>
    </xs:annotation>
    <xs:sequence>
      <xs:element name="resource" type="aaa:OracleEntitlementServerXacmlResourceType"/>
      <xs:element name="action" type="aaa:OracleEntitlementServerXacmlAction"/>
      <xs:element name="environmentSetting" type="aaa:OracleEntitlementServerXacmlEnvironmentSetting"/>
    </xs:sequence>
    <xs:attribute name="writeTransactionLog" type="xs:boolean" default="false"/>
    <xs:attribute name="cacheLifeTime" type="xs:unsignedInt" default="3">
      <xs:annotation>
        <xs:documentation>
          Application can choose to cache the OES authorization result or not. The default cache life time (timeout) is 3 seconds.
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:complexType>
  <xs:complexType name="OracleEntitlementServerXacmlResourceType">
    <xs:annotation>
      <xs:documentation>Defines the resource to be passed to XACML authentication mechanism</xs:documentation>
    </xs:annotation>
    <xs:choice>
      <xs:element name="use-extracted-resource" type="xs:NMTOKEN" fixed="internal-name:AuthorizationResource">
        <xs:annotation>
          <xs:documentation>Use the extracted resource.</xs:documentation>
        </xs:annotation>
        <!-- constraint: only allowed if ResourceExtraction mechanism has been specified -->
      </xs:element>
      <xs:element name="staticValue" type="xs:anyURI" default="/">
        <xs:annotation>
          <xs:documentation>Allow application to hardcode resource value</xs:documentation>
        </xs:annotation>
      </xs:element>
      <xs:element name="inputFromWorkflow" type="xs:string">
        <xs:annotation>
          <xs:appinfo>Service Designer should populate the string value to: XACML_Resource</xs:appinfo>
          <xs:documentation>
            Application developer will supply resource value from workflow when AAA policy bound to action.
          </xs:documentation>
        </xs:annotation>
      </xs:element>
    </xs:choice>
    <xs:attribute name="type" use="required" fixed="anyURI">
      <xs:annotation>
        <xs:appinfo>Not to be displayed. Must be populated by policy editor.</xs:appinfo>
      </xs:annotation>
    </xs:attribute>
  </xs:complexType>
  <xs:complexType name="OracleEntitlementServerXacmlAction">
    <xs:choice>
      <xs:element name="inputFromWorkflow" type="xs:string">
        <xs:annotation>
          <xs:documentation>Get the action from BEPL workflow variable.</xs:documentation>
        </xs:annotation>
      </xs:element>
      <xs:element name="staticValue" type="xs:string">
        <xs:annotation>
          <xs:documentation>Allow application to hardcode resource value</xs:documentation>
        </xs:annotation>
      </xs:element>
    </xs:choice>
  </xs:complexType>
  <xs:complexType name="OracleEntitlementServerXacmlEnvironmentSetting">
    <xs:sequence>
      <xs:element name="environment" type="aaa:Environment" minOccurs="0" maxOccurs="unbounded"/>
    </xs:sequence>
  </xs:complexType>
  <xs:complexType name="Environment">
    <xs:annotation>
      <xs:documentation>Allow application to specify the environments of XACML operation. They are optional.</xs:documentation>
    </xs:annotation>
    <xs:attribute name="id">
      <xs:annotation>
        <xs:documentation>ID is unique for environment</xs:documentation>
      </xs:annotation>
      <xs:simpleType>
        <xs:restriction base="xs:string">
          <xs:minLength value="1"/>
        </xs:restriction>
      </xs:simpleType>
    </xs:attribute>
    <xs:attribute name="type" type="aaa:OracleEntitlementServerEnvironmentType"/>
  </xs:complexType>
  <xs:simpleType name="OracleEntitlementServerEnvironmentType">
    <xs:annotation>
      <xs:documentation>
         Specify types in XACML environment setting. Oracle Entitlements Server supports 5 types: string, integer, date, time, and ip.
      </xs:documentation>
    </xs:annotation>
    <xs:restriction base="xs:string">
      <xs:enumeration value="date"/>
      <xs:enumeration value="integer"/>
      <xs:enumeration value="ip"/>
      <xs:enumeration value="string"/>
      <xs:enumeration value="time"/>
    </xs:restriction>
  </xs:simpleType>
  <xs:complexType name="OAuthAccessTokenAuthorization">
    <xs:sequence>
      <xs:element name="scopeResourceRule" type="aaa:ScopeResourceRule" maxOccurs="unbounded">
        <xs:annotation>
          <xs:documentation>
            PCRE (Regular expression) identifying that this scope rule is present in access token.
          </xs:documentation>
        </xs:annotation>
      </xs:element>
    </xs:sequence>
  </xs:complexType>
  <xs:complexType name="ScopeResourceRule">
    <xs:sequence>
      <xs:element name="scopeMatch">
        <xs:annotation>
          <xs:documentation>
            PCL Regular expression identifying that this scope rule is present in access token.
          </xs:documentation>
        </xs:annotation>
        <xs:simpleType>
          <xs:restriction base="xs:string">
            <xs:minLength value="1"/>
          </xs:restriction>
        </xs:simpleType>
      </xs:element>
      <xs:element name="resourceMatch">
        <xs:annotation>
          <xs:documentation>
            PCRE (Regular expression) identifying that resource is covered by associated scope.
          </xs:documentation>
        </xs:annotation>
        <xs:simpleType>
          <xs:restriction base="xs:string">
            <xs:minLength value="1"/>
          </xs:restriction>
        </xs:simpleType>
      </xs:element>
    </xs:sequence>
  </xs:complexType>
  <xs:complexType name="MapResource">
    <xs:annotation>
      <xs:documentation>Currently not being utilized in R2.2</xs:documentation>
    </xs:annotation>
    <xs:choice>
      <xs:element name="urlInWsAddressingAction" type="aaa:SamlUri">
        <xs:annotation>
          <xs:documentation>Write URI to WS-Addressing Action element within SOAP header.</xs:documentation>
        </xs:annotation>
      </xs:element>
    </xs:choice>
  </xs:complexType>
  <xs:complexType name="CreateUsernameToken">
    <xs:annotation>
      <xs:documentation>Create a WS-Security security token.</xs:documentation>
    </xs:annotation>
    <xs:sequence>
      <xs:element name="keyFormat">
        <xs:complexType>
          <xs:sequence>
            <xs:choice>
              <xs:element name="passwordText" type="aaa:EmptyType">
                <xs:annotation>
                  <xs:documentation>
                    Password is in plain text. If confidentiality is require then either separate WS-Security encryption
                    of username security token, or transport layer security, e.g., SSL/TLS.
                  </xs:documentation>
                </xs:annotation>
              </xs:element>
              <xs:element name="passwordDigest" type="aaa:EmptyType">
                <xs:annotation>
                  <xs:documentation>
                    Password embedded into digest value based upon: SHA1([nonce |] [creationTime |] password) 
                  </xs:documentation>
                </xs:annotation>
              </xs:element>
              <xs:element name="keyDerivation">
                <xs:annotation>
                  <xs:documentation>Only username in token plus information need to derive key using password</xs:documentation>
                </xs:annotation>
                <xs:complexType>
                  <xs:all>
                    <xs:element name="numberOfIterations" default="1000">
                      <xs:annotation>
                        <xs:documentation>Higher number increases cost to attacker.</xs:documentation>
                      </xs:annotation>
                      <xs:simpleType>
                        <xs:restriction base="xs:short">
                          <xs:minInclusive value="1"/>
                          <xs:maxExclusive value="20000"/>
                        </xs:restriction>
                      </xs:simpleType>
                    </xs:element>
                  </xs:all>
                </xs:complexType>
              </xs:element>
              <!-- deferred
              <xs:element name="none" type="aaa:EmptyType" nillable="true">
                <xs:annotation>
                  <xs:documentation>
                    Indicates that no password element is to be populated in the username token being created.
                    A username token without a password element is very unusual. This type of token is normally only
                    utilized as part of the generation of a WS-Trust request where it is used to identify the intented
                    requester in a OnBehalfOf element or for the source in the client authentication method.
                  </xs:documentation>
                </xs:annotation>
              </xs:element>
              -->
            </xs:choice>
            <xs:element name="usernamePasswordSource" type="aaa:MapUsernameSecurityToken"/>
            <xs:element name="wsuIdPrefix" type="aaa:WsuIdPrefix" default="str_" minOccurs="0">
              <xs:annotation>
                <xs:documentation>
                  We create security token with a unique wsu:Id which that consists of a prefix-uuid.
                  Applications can change the prefix to make it simplier to find a specific reference when multiple security
                  tokens are present. A simple XPath expression using a startwith or contains can be used to find the 
                  desired security token.
                </xs:documentation>
              </xs:annotation>
            </xs:element>
          </xs:sequence>
        </xs:complexType>
      </xs:element>
    </xs:sequence>
    <xs:attribute name="generateNonce" type="xs:boolean" default="true"/>
    <xs:attribute name="generateCreationTime" type="xs:boolean" default="true"/>
    <xs:attribute name="actor" type="aaa:ActorType" use="optional"/>
    <!-- constraint: Only ALLOWED if ((extract identity is principalNameFromKerberosToken with (extract primary is true)) AND (authentication identity is (LDAP OR Keystore))) -->
  </xs:complexType>
  <xs:complexType name="CreateHttpBasicAuthentication">
    <xs:annotation>
      <xs:documentation>
        Create the a base64 digest encoding of username ":" password associated HTTP basic authentication.
        This base64 digest  must be saved in he workflow, i.e., BEPL variable. This is necessary because
        the HTTP basic authentication information is part of the metadata and not the message content.
        The AAA processing does not have access to the future metadata to be passed onto the back-end system.
        Therefore, it is the responsibility of the application to take the generated HTTP basic authentication value and copy it to the 
        appropriate metadata invoke operation.
      </xs:documentation>
    </xs:annotation>
    <xs:all>
      <xs:element name="usernamePasswordSource" type="aaa:MapUsernameSecurityToken"/>
    </xs:all>
    <!-- constraint: Only ALLOWED if ((extract identity is principalNameFromKerberosToken with (extract primary is true)) AND (authentication identity is (LDAP OR Keystore))) -->
    <!--  constraint: Service Designer require to prompt developer for output data in the workflow when this AAA policy is bind to a specific action. -->
  </xs:complexType>
  <xs:complexType name="CreateCookie">
    <xs:annotation>
      <xs:documentation>
        Creates a Cookie with a security token in it. The security token normally packaged will be a Single Sign-On token.
      </xs:documentation>
    </xs:annotation>
    <xs:sequence>
      <xs:element name="setCookieFormatString">
        <xs:annotation>
          <xs:documentation>
            A string describing what should be contain in the Set-Cookie to be generated.
            
            A typical Set-Cookie should be of the following form:
              Set-Cookie: name=value; [expires=date;] path=pathname; domain=domainname; [secure]
            where
              name: The name of the cookie.
              value: The value associated with the cookie.
              expires: The date that, when reached, invalidates the cookie. The date must be given in the following 
                format: Wdy, DD-Mon-YYYY HH:MM:SS GMT. If an expiration date is not specifically defined, the cookies will
                expire at the end of the session (when the browser is closed) by default. If the cookie's expiration date 
                is set to the current date/time or any date/time already passed, the cookie will be immediately expired and
                deleted. 
                Note: Because of how poorly many users date/time is maintained, most implementations do not want to specify
                an explict expiration time on their SSO cookie. Expiration processing will be performed when the cookie is authenticated.
              Path: The path attribute defines a subset of directories in a domain for which the cookie is valid. The path
                will default to the root directory ("/") unless otherwise defined.
              Domain: The domain for which the cookie is valid. A domain string of ".aol.com" would define "www.aol.com," 
                "webmaster.info.aol.com," and in fact all sub-domains of aol.com as valid domains for the cookie. Be aware 
                that a domain setting must have at least two periods. A cookie can only be read and modified by an object in
                the valid domain and path defined in the cookie when it was created. The domain path can not be set to send
                cookies to a domain outside of the domain where the server creating the cookie resides. The domain attribute
                is set to the domain of the document sending the cookie by default.
              Secure: The secure attribute is Boolean. If the attribute is defined, there must be a secure https connection
                present in order for the cookie to be sent. If the attribute is not defined, the cookie will not require a
                secure connection to be sent.
          </xs:documentation>
          <xs:appinfo>
            We support the application developer defining a printf like format string where the following %x
            will be used to represent the substitution:
              %t: actual SSO Token
              %r: extracted resource
              %d: domain returned by SSO token creation mechanism
              %u: username. SiteMinder usage sometime utilizes SM_USER=joe.employee
                
            For Oracle Access Manager:
              ObSSOCookie=%t; path=%r; domain=%d;
            For SiteMinder:
              SMSESSION=%t; path=%r; domain=%d;
          </xs:appinfo>
        </xs:annotation>
        <!-- constraint: if %r or %extracted-resource present in filter expression then resourceExtract mechanism must be defined. -->
        <xs:simpleType>
          <xs:restriction base="xs:string">
            <xs:minLength value="2"/>
            <xs:maxLength value="4000"/>
          </xs:restriction>
        </xs:simpleType>
      </xs:element>
      <xs:element name="ssoSource" fixed="use-retrieved-SSO-token">
        <xs:simpleType>
          <xs:restriction base="xs:string">
            <xs:enumeration value="use-retrieved-SSO-token"/>
          </xs:restriction>
        </xs:simpleType>
      </xs:element>
      <xs:element name="path" type="aaa:CookiePathType"/>
      <xs:element name="domain" type="aaa:CookieDomainType"/>
    </xs:sequence>
  </xs:complexType>
  <xs:complexType name="CookiePathType">
    <xs:annotation>
      <xs:documentation>Defines Path (resource) to be used in SSO cookie</xs:documentation>
    </xs:annotation>
    <xs:choice>
      <xs:element name="use-extracted-resource" type="xs:NMTOKEN" fixed="internal-name:cookiePath">
        <xs:annotation>
          <xs:documentation>Use the extracted resource.</xs:documentation>
        </xs:annotation>
        <!-- constraint: only allowed if ResourceExtraction mechanism has been specified -->
      </xs:element>
      <xs:element name="staticValue" type="xs:anyURI" default="/">
        <xs:annotation>
          <xs:documentation>Allow application to hardcode resource value</xs:documentation>
        </xs:annotation>
      </xs:element>
      <xs:element name="inputFromWorkflow" type="xs:anyURI">
        <xs:annotation>
          <xs:appinfo>Service Designer should populate the string value to: sso_cookie_path</xs:appinfo>
          <xs:documentation>
            Application developer will supply resource value from workflow when AAA policy bound to action.
          </xs:documentation>
        </xs:annotation>
      </xs:element>
    </xs:choice>
    <xs:attribute name="type" use="required" fixed="string">
      <xs:annotation>
        <xs:appinfo>Not to be displayed. Must be populated by policy editor.</xs:appinfo>
      </xs:annotation>
    </xs:attribute>
  </xs:complexType>
  <xs:complexType name="CookieDomainType">
    <xs:annotation>
      <xs:documentation>Defines Path (resource) to be used in SSO cookie</xs:documentation>
    </xs:annotation>
    <xs:choice>
      <xs:element name="use-retrieved-domain" type="xs:NMTOKEN" fixed="internal-name:cookiePath">
        <xs:annotation>
          <xs:documentation>Use the retrieved domain.</xs:documentation>
        </xs:annotation>
        <!-- constraint: only allowed if authentication or authorization is SiteMinder mechanism creating SSO token -->
      </xs:element>
      <xs:element name="staticValue" type="xs:anyURI" default="/">
        <xs:annotation>
          <xs:documentation>Allow application to hardcode resource value</xs:documentation>
        </xs:annotation>
        <!-- constraint: Must contain at least two "." -->
      </xs:element>
      <xs:element name="inputFromWorkflow" type="xs:anyURI">
        <xs:annotation>
          <xs:appinfo>Service Designer should populate the string value to: internal-name:cookiePath</xs:appinfo>
          <xs:documentation>
            Application developer will supply resource value from workflow when AAA policy bound to action.
          </xs:documentation>
        </xs:annotation>
      </xs:element>
    </xs:choice>
    <xs:attribute name="type" use="required" fixed="string">
      <xs:annotation>
        <xs:appinfo>Not to be displayed. Must be populated by policy editor.</xs:appinfo>
      </xs:annotation>
    </xs:attribute>
  </xs:complexType>
  <xs:simpleType name="HttpAuthorizationCredentialType">
    <xs:annotation>
      <xs:documentation>
        The type-of-credential specified on the HTTP Authorization: field.
              Authorization: type-of-credential credential
        In general, it would be some know string such as Bearer, Mac, OAuth, Basic, Digest, etc. However, it could be a
        completely arbitrary string that is unique to the authorization server and resource server.
      </xs:documentation>
    </xs:annotation>
    <xs:union>
      <xs:simpleType>
        <xs:restriction base="xs:string">
          <xs:enumeration value="Bearer"/>
          <xs:enumeration value="Oauth"/>
          <!-- deferred to future release 
          <xs:enumeration value="Mac"/>
          <xs:enumeration value="Basic"/>
          <xs:enumeration value="Digest"/>
          -->
        </xs:restriction>
      </xs:simpleType>
      <xs:simpleType>
        <xs:restriction base="xs:string"/>
      </xs:simpleType>
    </xs:union>
  </xs:simpleType>
  <xs:simpleType name="OAuthSourceType">
    <xs:restriction base="xs:string">
      <xs:annotation>
        <xs:appinfo>SAML assertion are fully support via </xs:appinfo>
      </xs:annotation>
      <xs:enumeration value="SSO-token"/>
      <!--
      <xs:enumeration value="internally-generate-token">
        <xs:annotation>
          <xs:documentation>
            Instructs us to use an internally generate access token.
            This fundamentally assumes that we are operating as both the authorizarion server and the resource server.
          </xs:documentation>
          <xs:appinfo>
            For maximum scalability, I would have us package the following information:
            1) token encoding version: internal identifier that we use to know the type of encryption and packaging that 
               is being utilized. This is just future proofing us so that we can evolve how we are doing things.
            2) symmetric key name used: could be handle of symmetric key object in security config being used to 
               encrypt access token. Needed so that application can periodically change their keys or because key was
               compromised. We could obfuscate the symmetric key name to make things more opaque.
            3) user identity: May not be populate depending upon the flowType, e.g., Client Credential flow.
            4) client identity: 
            5) issue at time: GMT.
            6) expiration time delta: time in seconds.
            This entire entity except for the token encoding version and the symmetric key name would then be encrypted and 
            base64 encoded. This would create an opague blob that only we should be able to decrypt and utilize.
             
            Security Concerns: fundamental opaqueness is based upon bulk encryption algorithm that we are utilizing. 
            Because of fundamental vulnerabilies of CBC-based bulk ciphers we will want to move eventually to a 
            GCM-based cipher that would also ensure the integrity of the data. 
            Using GCM would eliminate need for signature.
          </xs:appinfo>
        </xs:annotation>
      </xs:enumeration>
      -->
    </xs:restriction>
  </xs:simpleType>
  <xs:complexType name="CreateOAuthGrant">
    <xs:annotation>
      <xs:appinfo>
        Our intention is to utilize a SAML Bearer Assertion to contain all the grant information. This SAML Assertion will be
        signed to ensure that the grant has not been modified by an attacker. The entire assertion can be encrypted to protect
        any confidential information within the grant.
        
        We will base64(url-encode(SAML assertion)) and package it into the Authorization Response as the code/grant, e.g.,
          HTTP/1.1 302 Found
          Location: https://client.example.com/cb?code=SplxlOBeZQQYbYS6WxSbIA'state=xyz
        
        The SAML Assertion will be populated according to the following rules:
        1) SAML v2.0 Assertion
        2) Issuer must be set to authorization server url
        3) Issuer Format attribute must be set to: urn:oasis:names:tc:SAML:2.0:nameid-format:unspecified
        4) Audience (Conditions AudienceRestriction) must be set to authorization server url
        5) SubjectConfirmationData Method MUST be set to: urn:oasis:names:tc:SAML:2.0:cm:bearer
        6) Subject must be populated with extracted identity resource owner name
           a) If resource owner credential is name and password then name.
           b) If resource owner credential is SAML assertion then SAML Subject
        7) AuthnContextClassRef must be set.
           a) If resource owner credential is name and password
              then set to urn:oasis:names:tc:SAML:2.0:ac:classes:PasswordProtectedTransport
           b) If resource owner credential is SAML assertion then set to urn:oasis:names:tc:SAML:2.0:ac:classes:SPKI
        8) Recipient (SubjectConfirmation SubjectConfirmationData) must be set to the authorization server URI.
        9) Attribute Statement must have the following Attribute elements populated:
           a) client_id. Value set to client name if client credential name/password. If client credential SAML
              Assertion then SAML Subject.
           b) redirect_uri: from incoming authorization request.
           c) scope: revised scope. Value: optional. Scope returned with access token
                     can differ from scope recieved from client on authorization request. On 
                     Authorization Code flow, resource owner may restrict scope when getting their 
                     credentials/authorization for proposed scope. On Resource Owner and Client
                     credential flows, policy/application code performing scope restriction.
           d) ssoToken: SSO token returned by external Identity manager authentication, e.g.,
              SiteMinder or OAM. Value: optional.
        10) SAML Signature (signatureInfo element) must be populated. 
            a) signGenerationMethod must be set to: rsaWithSha256
            b) digestGenerationMethod must be set to: sha256
            c) canonicalGenerationMethod must be set to: C14N_exclusive
            d) keyPair security-config-package must be populated from this grant structure
            e) caPath: must be populated from this grant structure (Optional)
        11) SAML Encryption (encryptionInfo) may be optionally populated. If any confidential information is contained 
            within SAML assertion then SAML encryption should be used to encrypt the entire assertion.
            a) generateDataEncryptionMethod must be set to: aes128
            b) encryptKeyInfo x509 element:
               i) generateKeyTransportMethod method must be set to: rsa-oaep
               ii) generateKeyTransport RsaOAEPDigestMethod must be set to: sha256
               iii) keyRecipientPair recipientKey must be set from this grant structure
        12) generalAssertionInfo maxExpirationTime must be set to grantExpirationTime
      </xs:appinfo>
    </xs:annotation>
    <xs:sequence>
      <xs:element name="grantInfrastructure" type="aaa:CommonGrantRefreshTokenType">
        <xs:annotation>
          <xs:documentation>Information that is required because of our implementation of a grant.</xs:documentation>
        </xs:annotation>
      </xs:element>
      <xs:element name="grantExpirationTime" default="20" minOccurs="0">
        <xs:annotation>
          <xs:documentation>
            OAuth 2.0 standard call for the authorization code (grant) to be utilized shortly after it is
            issued to mitigate leakage of grant to an attacker. The maximum expiration time recommended is
            10 minutes.
          </xs:documentation>
          <xs:appinfo>Units: time in seconds.</xs:appinfo>
        </xs:annotation>
        <xs:simpleType>
          <xs:restriction base="xs:unsignedInt">
            <xs:minInclusive value="1"/>
            <xs:maxInclusive value="600"/>
          </xs:restriction>
        </xs:simpleType>
      </xs:element>
    </xs:sequence>
  </xs:complexType>
  <xs:complexType name="CommonGrantRefreshTokenType">
    <xs:sequence>
      <xs:element name="authorizationServer" type="aaa:SamlUri">
        <xs:annotation>
          <xs:documentation>
            URI uniquely identifying the authorization server or the service provider controlling domain.
          </xs:documentation>
          <xs:appinfo>
            For the refresh token and authorization code flow when creating an access token, we could potentially
            use the authorization server name from the grant and refresh token as the issuer. Requiring the 
            authorization server/issue to be supplied on each access token creation is:
            1) a more general solution because an application could have different issues for the grant and refresh token uses
            2) more uniform in that all access token creation require the same information to be supplied.
          </xs:appinfo>
        </xs:annotation>
        <!-- constraint: 1) MUST be POPULATED if (authorizationCodeRequestType == accessTokenRequest)
                                                 ==> reference from createToken or useToken or createSamlAssertion
                         2) MUST be POPULATED if (authorizationCodeRequestType == grantRequest) 
                                                 ==> referenced from CreateOAuthGrant
        -->
      </xs:element>
      <xs:element name="scope" type="aaa:ScopeType" minOccurs="0">
        <xs:annotation>
          <xs:documentation>
            Defines the scope value that will be package into the access token being generated for the following
            types of OAuth flows: ClientCredential, ResourceOwnerPasswordCredential, ResourceOwnerSamlAssertionCredential, ImplicitGrant
            and RefreshToken.
            
            For an OAuth AuthorizationCode flow, the scope is normally tha same as in the grant, i.e., what the resource owner
            explicitly approved with the authorization server as part of grant generation. However, there are some number of 
            situations where an authorization server may want to generate the refresh token that differs from the grant.
          </xs:documentation>
        </xs:annotation>
        <!-- constraint: 1) Only ALLOWED if ((referenced from AccessTokenResponseSpecificInfoType, i.e., creating refresh token)
                                             (extract identity == nameFromOAuthAuthorizationRequest) AND 
                                             (flowType = (ClientCredential OR ResourceOwnerPasswordCredential OR
                                                          ResourceOwnerSamlAssertionCredential OR RefreshToken OR
                                                          AuthorizationCode
                                                         )
                                             )
                                            )
                         2) WARNING "Potentially changing/restricting scope that was approved in grant" 
                                    if ((flowType == (RefreshToken OR AuthorizationCode)) AND 
                                        (createOAuthAccessTokeResponse scope != useExtractedScope)
                                       )
                         3) MUST be POPULATED if (referenced from CreateOAuthGrant)
        -->
      </xs:element>
      <xs:element name="signatureInfo">
        <xs:complexType>
          <xs:sequence>
            <xs:element name="signatureKeyPair" type="aaa:CreateKeyPairSecurityToken">
              <xs:annotation>
                <xs:documentation>Asymmetric Key Pair to be used to sign returned grant/code.</xs:documentation>
              </xs:annotation>
            </xs:element>
            <xs:element name="caPath" type="aaa:CreateCaPathSecurityToken" minOccurs="0"/>
          </xs:sequence>
        </xs:complexType>
      </xs:element>
      <xs:element name="encryptionKey" type="aaa:SecurityToken" minOccurs="0">
        <xs:annotation>
          <xs:documentation>X.509 certificate to be used to encrypt returned grant/code.</xs:documentation>
        </xs:annotation>
        <!-- constraint: 1) ONLY PRESENT the following options: security-config-package, bstFromWorkflow OR
                                                                securityObjectNameFromWorkflow
                         2) MUST be POPULATED if external generated SSO being package within grant as potential access token.
        -->
      </xs:element>
    </xs:sequence>
  </xs:complexType>
  <xs:complexType name="CreateSamlAssertion">
    <xs:annotation>
      <xs:documentation>Defined everyting required for us to generate a SAML Assertion.</xs:documentation>
    </xs:annotation>
    <xs:sequence>
      <xs:element name="assertionInfo" type="aaa:SourceAssertionInfo"/>
      <xs:element name="signatureInfo" type="aaa:SamlSignatureInfo" minOccurs="0"/>
      <xs:element name="encryptionInfo" type="aaa:EncryptionInfo" minOccurs="0"/>
      <xs:element name="outputBindingInfo" type="aaa:OutputBindingInfoForInternalCreation" minOccurs="0"/>
    </xs:sequence>
  </xs:complexType>
  <xs:complexType name="OutputBindingInfoForExternalCreation">
    <xs:complexContent>
      <xs:extension base="aaa:OutputBindingInfoBaseType">
        <xs:sequence>
          <xs:element name="QueryResponse" type="aaa:QueryResponseTypeForExternalCreateSamlAssertion" minOccurs="0">
            <!-- constraint: ONLY PRESENT if (exportSource == (to-ESG-HTTP-Authorization-saml2-bearer OR
                                                               to-ESG-HTTP-Authorization-saml2-hok-ssl OR
                                                               to-SAML-response
                                                              )
                                             ) 
            -->
          </xs:element>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:complexType name="OutputBindingInfoForInternalCreation">
    <xs:complexContent>
      <xs:extension base="aaa:OutputBindingInfoBaseType">
        <xs:sequence>
          <xs:element name="QueryResponse" type="aaa:QueryResponseTypeForInternalCreateSamlAssertion" minOccurs="0">
            <!-- constraint: ONLY PRESENT if (exportSource == (to-ESG-HTTP-Authorization-saml2-bearer OR 
                                                               to-ESG-HTTP-Authorization-saml2-hok-ssl OR
                                                               to-SAML-response
                                                              )
                                             ) 
            -->
          </xs:element>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:complexType name="OutputBindingInfoBaseType">
    <xs:annotation>
      <xs:documentation>
        Contains information required to save the token, i.e., SAML assertion, being created. Different binding mechanisms
        may require different encoding mechanism/procedures.
      </xs:documentation>
      <xs:appinfo>Currently only required for REST bindings.</xs:appinfo>
    </xs:annotation>
    <xs:sequence minOccurs="0">
      <xs:annotation>
        <xs:appinfo>
          A SAML assertion that is package within a SAML Query response is normally Deflated and then Base64 encoded.
          The Base 64 encoding is required because the compression mechanism can cause binary values to be generated.
          Additionally, the base64 encoding will remove linefeeds and whitespaces that can cause problems when they
          appear with the HTTP header.
          See Bindings for the OASIS Security Assertion Markup Language (SAML) V2.0 OASIS Standard, 15 March 2005
          for processing details.
        </xs:appinfo>
      </xs:annotation>
      <xs:element name="exportDestination" default="to-WS-Security-header">
        <xs:annotation>
          <xs:documentation>This element identifies where the SAML Assertion to be processed is located.</xs:documentation>
          <xs:appinfo>Am defaulting this element so that existing AAA policies will NOT require any retrofit.</xs:appinfo>
        </xs:annotation>
        <xs:simpleType>
          <xs:restriction base="xs:string">
            <xs:enumeration value="to-WS-Security-header">
              <xs:annotation>
                <xs:documentation>
                  SAML assertion being generated will be saved in WS-Security header within the SOAP header of the 
                  revised input document
                </xs:documentation>
              </xs:annotation>
            </xs:enumeration>
            <xs:enumeration value="to-OAuth2-Access-Token-Response">
              <xs:annotation>
                <xs:documentation>
                  Create HTTP body of a successful OAuth 2.0 Access Token Response, i.e., successful authorization server
                  response message body.
                  
                  An OAuth 2.0 access token response contains the following information:
                  access_token: Required field. This is the actual access token issued by the authorizarion server.
                    It could be automatically generated by us or be a SSO token generated by a previous specified
                    authentication mechanism, e.g., SiteMinder, Oracle Access Manager, etc.
                  token_type: Required. The type of type issued. If the flowType specified on the extract identity
                    is either SAML assertion v2.0 bearer or MAC then the token_type should be Bearer or MAC respectively.
                    Otherwise, the application will need to identify the token_type.
                  expires_in: Optional. The lifetime in seconds of the access token.
                  refresh_token: Optional. 
                  scope: Optional. The authorization server uses the scope response parameter to inform the client
                    of the scope of the access token issued.
                    The value of the scope parameter is expressed as a list of space-delimited, case sensitive
                    strings. The strings are defined by the authorization server. If the value contains multiple
                    space-delimited strings, their order does not matter, and each string adds an additional
                    access range to the requested scope.
                    The authorization server MAY fully or partially ignore the scope requested by the client based
                    on the authorization server policy or the resource owner's instructions. If the issued access
                    token scope is different from the one requested by the client, the authorization server
                    SHOULD include the scope response parameter to inform the client of the actual scope granted.
                  
                    HTTP/1.1 200 OK
                    Content-Type: application/json;charset=UTF-8
                    Cache-Control: no-store
                    Pragma: no-cache
                    
                    {
                      "access_token":"2YotnFZFEjr1zCsicMWpAA",
                      "token_type":"example",
                      "expires_in":3600,
                      "example_parameter":"example_value"
                    }
                    
                  The resulting SAML assertion could be package to be passed to a resource server in one of the 
                  following encoding formats (See Section 2.2 of The OAuth 2.0 Authorization Protocol: Bearer 
                  Tokens draft-ietf-oauth-v2-bearer):
                  1) Within the HTTP Authorization header field, e.g.,
                     GET /resource HTTP/1.1
                     Host: server.example.com
                     Authorization: Bearer &lt;base64(saml-assertion)&gt;
                  2) Within the HTTP body, e.g.,
                     POST /resource HTTP/1.1
                     Host: server.example.com
                     Content-Type: application/x-www-form-urlencoded
                     
                     access_token=&lt;base64(saml-assertion)&gt; 
                  3) Within URI Query Parameter, e.g.,
                     GET /resource?access_token=vF9dft4qmT HTTP/1.1
                     Host: server.example.com
                </xs:documentation>
                <xs:appinfo>
                  The content encoding of the response can be specified by the client via the optional format parameter
                  on the incoming request. Legal values are:
                    urlencoded
                    json
                    xml
                  The default is json. 
                  
                  1) Will generate a XML fragment that contains all the different components of the response.
                     This fragment will be used to build actual HTTP response by action builder generated mediation code.
                </xs:appinfo>
              </xs:annotation>
              <!-- constraint: 1) MUST be SELECTED if ((extractIdentity == nameFromOAuthAuthorizationRequest) AND
                                                       (authorizationCodeRequestType == accessTokenRequest)
                                                      )
                               2) NOT ALLOWED if NOT((extractIdentity == nameFromOAuthAuthorizationRequest) AND
                                                     (authorizationCodeRequestType == accessTokenRequest)
                                                    )
                               3) ONLY ALLOWED if ((assertionInfo == v2dot0Info) AND 
                                                   (SubjectConfirmation Method == urn:oasis:names:tc:SAML:2.0:cm:bearer)
                                                  )
              -->
            </xs:enumeration>
            <xs:enumeration value="to-ESG-HTTP-Authorization-saml2-bearer">
              <xs:annotation>
                <xs:documentation>
                  A base64(inflate(SAML assertion)) will be written to a workflow variable that is accessible to the
                  appliation via get-security-metadata action.
                  The SAML assertion will be deflated and base64 encoded and then packaged within a string looking like:
                    saml2-bearer &lt;base64(deflate(encapsulateWithQueryResponse(saml-assertion)))&gt; 
                  This will be package within a HTTP Authorization field.
                  This is an Intel Expressway proprietary encoding. The SAML assertion should be a bearer assertion.
                </xs:documentation>
              </xs:annotation>
              <!-- constraint: 1) generate ERROR if assertionInfo.v2dot0Info.Subject.SubjectConfirmation.Method MUST be of
                                  2.0, 1.1 or 1.0 type Bearer.
                               2) generate WARNING if assertionInfo.v2dot0Info.Subject.SubjectConfirmation.Method is either
                                  1.1 or 1.0 type Bearer.
              -->
            </xs:enumeration>
            <xs:enumeration value="to-ESG-HTTP-Authorization-saml2-hok-ssl">
              <xs:annotation>
                <xs:documentation>
                  A base64(inflate(SAML assertion)) will be written to a workflow variable that is accessible to the appliation via
                  get-security-metadata action.
                  The SAML query response will be deflated and base64 encoded and then packaged within a string looking like:
                    saml2-hok-ssl &lt;base64(deflate(encapsulateWithQueryResponse(saml-assertion)))&gt; 
                  This will be package within a HTTP Authorization field.
                  The SAML assertion should be a holder-of-key assertion whose credential will be valided via the authenticated
                  peer certificate from the associated SSL/TLS session.
                </xs:documentation>
              </xs:annotation>
              <!-- constraint: 1) generate ERROR if assertionInfo.v2dot0Info.Subject.SubjectConfirmation.Method MUST be of
                                  2.0, 1.1 or 1.0 type Holder-of-key.
                               2) generate WARNING if assertionInfo.v2dot0Info.Subject.SubjectConfirmation.Method is either
                                  1.1 or 1.0 type Holder-of-key.
              -->
            </xs:enumeration>
            <xs:enumeration value="to-workflow">
              <xs:annotation>
                <xs:documentation>General mechanism to allow application to save SAML assertion from anywhere.</xs:documentation>
              </xs:annotation>
            </xs:enumeration>
            <xs:enumeration value="to-SAML-response">
              <xs:annotation>
                <xs:documentation>
                  A base64(SAML assertion) that has been embedded within a SAML response structure will be written to a workflow
                  variable that is accessible to the appliation via get-security-metadata action:
                      base64(deflated(XML-enveloped-signature(build-saml-query-response(saml-assertion)))).
                  The SAML assertion may be optionally deflated based upon associated policy setting.
                </xs:documentation>
                <xs:appinfo>
                  The exported SAML assertion will be base64 encoded. It will only be deflated if the application developer sets 
                  the application settings to deflate.
                </xs:appinfo>
              </xs:annotation>
            </xs:enumeration>
          </xs:restriction>
        </xs:simpleType>
      </xs:element>
      <xs:element name="deflate" type="xs:boolean" default="true" minOccurs="0">
        <xs:annotation>
          <xs:documentation> 
            Indicates if the resulting token (entire SAML assertion) is to be deflated, i.e, compressed according to RFC1951.
          </xs:documentation>
        </xs:annotation>
        <!-- constraint: 1) ONLY PRESENT if (exportDestination == (to-ESG-HTTP-Authorization-saml2-bearer OR
                                                                   to-ESG-HTTP-Authorization-saml2-hok-ssl OR
                                                                   to-workflow OR to-SAML-response
                                                                  )
                                            )
                         2) MUST be SET TRUE if (exportDestination == (to-ESG-HTTP-Authorization-saml2-bearer OR
                                                                       to-ESG-HTTP-Authorization-saml2-hok-ssl
                                                                      )
                                                )
                         3) NOT PRESENT/ALLOWED if (exportDestination == (to-WS-Security-header OR to-access-token OR
                                                                          to-OAuth2-Access-Token-Response
                                                                         )
                                                   )
        -->
      </xs:element>
      <xs:element name="base64Encode" type="xs:boolean" default="true" minOccurs="0">
        <xs:annotation>
          <xs:documentation> 
            Indicates if the resulting token (entire SAML Assertion) is to be base64 URL encoded according to RFC 2045.
          </xs:documentation>
        </xs:annotation>
        <!-- constraint: 1) ONLY PRESENT if (exportDestination == (to-ESG-HTTP-Authorization-saml2-bearer OR
                                                                   to-ESG-HTTP-Authorization-saml2-hok-ssl OR
                                                                   to-workflow
                                                                  )
                                            )
                         2) MUST be SET TRUE if (exportDestination == (to-ESG-HTTP-Authorization-saml2-bearer OR 
                                                                       to-ESG-HTTP-Authorization-saml2-hok-ssl OR
                                                                       to-OAuth2-Access-Token-Response OR 
                                                                       to-SAML-response
                                                                      )
                                                )
                         3) NOT PRESENT/ALLOWED if (exportDestination == to-WS-Security-header)
                         4) MUST be SET to TRUE if (deflate == true) 
        -->
      </xs:element>
      <xs:element name="accessTokenResponseSpecificInfo" type="aaa:AccessTokenResponseSpecificInfoType" minOccurs="0">
        <!-- constraint: ONLY PRESENT if (exportDestination == to-OAuth2-Access-Token-Response) -->
      </xs:element>
      <xs:element name="actor" type="aaa:ActorType" minOccurs="0">
        <!-- constraint: ONLY PRESENT if (exportDestination == to-WS-Security-header) -->
      </xs:element>
    </xs:sequence>
  </xs:complexType>
  <xs:complexType name="AccessTokenResponseSpecificInfoType">
    <xs:annotation>
      <xs:documentation>
        Contains all the information to fully populate an OAuth access token response message.
        See The OAuth 2.0 Authorization Protocol draft-ietf-oauth-v2-22, Hammer-Lahav, E., Recordon, D., 
        Hardt, D., September 22, 2011.
        
        An OAuth 2.0 access token response contains the following information:
        access_token: Required field. This is the actual access token issued by the authorizarion server.
            It could be automatically generated by us or be a SSO token generated by a previous specified
            authentication mechanism, e.g., SiteMinder, Oracle Access Manager, etc.
        token_type: Required. The type of type issued. If the flowType specified on the extract identity
            is either SAML assertion v2.0 bearer or MAC then the token_type should be Bearer or MAC respectively.
            Otherwise, the application will need to identify the token_type.
        expires_in: Optional. The lifetime in seconds of the access token.
        refresh_token: Optional. 
        scope: Optional. The authorization server uses the scope response parameter to inform the client
            of the scope of the access token issued.
            The value of the scope parameter is expressed as a list of space-delimited, case sensitive
            strings. The strings are defined by the authorization server. If the value contains multiple
            space-delimited strings, their order does not matter, and each string adds an additional
            access range to the requested scope.
            The authorization server MAY fully or partially ignore the scope requested by the client based
            on the authorization server policy or the resource owner's instructions. If the issued access
            token scope is different from the one requested by the client, the authorization server
            SHOULD include the scope response parameter to inform the client of the actual scope granted.
      </xs:documentation>
      <xs:appinfo>
        1) Do not have any plans to support client passing in scope and the authorization 
           server utilizing this data.
        2) Do not plan to allow application the ability to package scope information in the access token
           response being generated.
        Bottom line: let keep things as simple as possible until we have a better understanding of actual usage.
      </xs:appinfo>
    </xs:annotation>
    <xs:sequence>
      <xs:element name="accessTokenType" type="aaa:HttpAuthorizationCredentialType" default="Bearer">
        <xs:annotation>
          <xs:appinfo>
            This is the type-of-credentials field that will be part of the HTTP request to the resource server that 
            includes the access token, e.g.,
              Authorization: type-of-credential credential
          </xs:appinfo>
        </xs:annotation>
      </xs:element>
      <xs:element name="expirationDelta" type="aaa:ExpirationLifetimeType">
        <xs:annotation>
          <xs:documentation>
            Time in second before this access token expires, i.e., becomes invalid.
            Zero indicates that access token should never expire.
          </xs:documentation>
        </xs:annotation>
      </xs:element>
      <xs:sequence minOccurs="0">
        <!-- constraint: 1) ONLY PRESENT if (flowType == (AuthorizationCode OR ResourceOwnerPasswordCredential OR
                                                          ResourceOwnerSamlAssertionCredential OR RefreshToken OR
                                                          ClientCredential
                                                         )
                                            )
                         2) WARNING "No create refresh token, normally will create a new Refresh Token flow that is 
                                     enforcing uniqueness, i.e., refresh token rotation being performed"
                            if ((flowType == RefreshToken) AND 
                                (nameFromOAuthAuthoziationRequest refresh token checkUniqueness == true) AND
                                (create refresh token NOT populated)
                               )
                         3) WARNING "Client Credential flows SHOULD NOT include a refresh token in their response"
                            if (flowType == ClientCredential)
                         4) NOT PRESENT if (flowType == ImplicitGrant)
                         5) WARNING "There is no normal reason to generate a refresh token if the incoming refresh token is 
                                     not being discarded: checking for uniqueness."
                            if ((flowType == RefreshToken) AND (refresh token checkUniqueness == false) AND
                                (create refresh token populated)
                               )
        -->
        <xs:element name="refreshInfrastructure" type="aaa:CommonGrantRefreshTokenType">
          <xs:annotation>
            <xs:documentation>Information need for our implementation to build a refresh token.</xs:documentation>
            <xs:appinfo>
              Our intention is to utilize a SAML Bearer Assertion to contain all the refresh information. This SAML Assertion will be
              signed to ensure that the refresh token has not been modified by an attacker. The entire assertion can be encrypted 
              to protect any confidential information within the refresh token.
              
              We will base64(url-encode(SAML assertion)) and package it into the access token response Response as the 
              refresh token, e.g.,
                HTTP/1.1 200 OK
                Content-Type: application/json;charset=UTF-8
                Cache-Control: no-store
                Pragma: no-cache
                
                {
                  "access_token":"2YotnFZFEjr1zCsicMWpAA",
                  "token_type":"example",
                  "expires_in":3600,
                  "refresh_token":"tGzv3JOkF0XG5Qx2TlKWIA",
                }
                
              The SAML Assertion will be populated according to the following rules:
              1) SAML v2.0 Assertion
              2) Issuer must be set to authorization server url
              3) Issuer Format attribute must be set to: urn:oasis:names:tc:SAML:2.0:nameid-format:unspecified
              4) Audience (Conditions AudienceRestriction) must be set to REFRESH_ONLY.
              5) SubjectConfirmationData Method MUST be set to: urn:oasis:names:tc:SAML:2.0:cm:bearer
              6) Subject must be populated with extracted identity resource owner name
                 a) If resource owner credential is name and password then name.
                 b) If resource owner credential is SAML assertion then SAML Subject
              7) AuthnContextClassRef must be set.
                 a) If resource owner credential is name and password
                    then set to urn:oasis:names:tc:SAML:2.0:ac:classes:PasswordProtectedTransport
                 b) If resource owner credential is SAML assertion then set to urn:oasis:names:tc:SAML:2.0:ac:classes:SPKI
              8) Recipient (SubjectConfirmation SubjectConfirmationData) must be set to the authorization server URI.
              9) Attribute Statement must have the following Attribute elements populated:
                 a) client_id. Value set to client name if client credential name/password. If client credential SAML
                    Assertion then SAML Subject.
                 b) redirect_uri: from incoming authorization request.
                 c) scope: revised scope. Value: optional. Scope returned with access token
                           can differ from scope recieved from client on authorization request. On 
                           Authorization Code flow, resource owner may restrict scope when getting their 
                           credentials/authorization for proposed scope. On Resource Owner and Client
                           credential flows, policy/application code performing scope restriction.
                 d) resource owner credential: Only required if an external Identity Manager, e.g., SiteMinder or OAM, 
                      generated SSO token is being used as the access token. Note: could get away with original SSO token 
                      if Identity Manager supports SSO token refresh option. Otherwise would have to regenerate new SSO token
                      creation request using user actual credentials. (Deferred to FUTURE)
              10) SAML Signature (signatureInfo element) must be populated. 
                  a) signGenerationMethod must be set to: rsaWithSha256
                  b) digestGenerationMethod must be set to: sha256
                  c) canonicalGenerationMethod must be set to: C14N_exclusive
                  d) keyPair security-config-package must be populated fot this refresh token structure
                  e) caPath: must be populated from this refresh structure (Optional)
              11) SAML Encryption (encryptionInfo) may be optionally populated. If any confidential information is contained 
                  within SAML assertion then SAML encryption should be used to encrypt the entire assertion.
                  a) generateDataEncryptionMethod must be set to: aes128
                  b) encryptKeyInfo x509 element:
                     i) generateKeyTransportMethod method must be set to: rsa-oaep
                     ii) generateKeyTransport RsaOAEPDigestMethod must be set to: sha256
                     iii) keyRecipientPair recipientKey must be set for this refresh structure
              12) generalAssertionInfo maxExpirationTime must be set to refreshTokenLifeTime
            </xs:appinfo>
          </xs:annotation>
        </xs:element>
        <xs:element name="refreshTokenLifeTime" type="aaa:ExpirationLifetimeType" minOccurs="0">
          <xs:annotation>
            <xs:documentation>
              Indicates how long a refresh token is valid. The refreshTokenLifeTime value must be greater than the access
              token expiration time. The OAuth standards do not contain any mention of a maximum lifetime for a refresh 
              token, i.e., it could live forever. Zero indicates a forever lifetime, i.e., until revoked. 
              
              Time in seconds.
            </xs:documentation>
            <xs:appinfo>
              For our implementation, a refresh token will be a special type of grant (SAML assertion).
              Everytime a refresh token is utilized, we will regenerate another refresh token with
              a reduced expiration time. We will also enforce SAML uniqueness checking to ensure that
              both the client and an attacker can not both reuse the same refresh token. 
              If refresh token flow then should utilize expiration time from incoming refresh token
            </xs:appinfo>
          </xs:annotation>
          <!-- constraint: 1) ONLY ALLOWED if (generateRefreshToken == true)
                           2) NOT PRESENT if (flowType == ResfreshToken)
                           3) WARNING "Refresh Token lifetime is normally equal or greater than access token expiration time"
                              if (refreshTokenLifeTime < expirationDelta)
          -->
        </xs:element>
      </xs:sequence>
      <xs:element name="scope" type="aaa:ScopeType" minOccurs="0">
        <xs:annotation>
          <xs:documentation>
            Defines the scope value that will be package into the access token being generated for the following
            types of OAuth flows: ClientCredential, ResourceOwnerPasswordCredential, ResourceOwnerSamlAssertionCredential,
            ImplicitGrant and RefreshToken.
            
            For an OAuth AuthorizationCode flow, the scope must come from the grant, i.e., what the resource owner explicitly
            approved with the authorization server as part of grant generation.
          </xs:documentation>
        </xs:annotation>
        <!-- constraint: 1) MUST be PRESENT if ((extract identity == nameFromOAuthAuthorizationRequest) AND 
                                                (flowType = (ClientCredential OR ResourceOwnerPasswordCredential OR
                                                             ResourceOwnerSamlAssertionCredential OR ImplicitGrant OR 
                                                             RefreshToken
                                                            )
                                                )
                                               )
                         2) Any value for scope ALLOWED 
                            if ((extract identity == nameFromOAuthAuthorizationRequest) AND 
                                (flowType = AuthorizationCode) AND
                                (refreshIntrastructure is populated)
                               )
                         3) Only (scope == useExtractedScope) ALLOWED 
                            if ((extract identity == nameFromOAuthAuthorizationRequest) AND 
                                (flowType = AuthorizationCode) AND
                                (refreshIntrastructure is NOT populated) AND
                                (OAuthVersion equal or later than OAuth2-draft-23)
                               )
                         4) Any value for scope ALLOWED 
                            if ((extract identity == nameFromOAuthAuthorizationRequest) AND 
                                (flowType = AuthorizationCode) AND
                                (refreshIntrastructure is NOT populated) AND
                                (OAuthVersion equal or earlier than OAuth2-draft-22)
                               )
                         5) ERROR "access token scope MUST be subset of scope defined in refresh token scope/grant" 
                            if ((generateRefreshToken == true) AND (scope NOT SUBSET(refreshInfrastructure scope)))
                            Note: can only issue this error message in Service Designer policy editor when static values used,
                                  otherwise this is a runtime error. We could consider generating a warning message when this is
                                  runtime condition.
        -->
      </xs:element>
      <xs:element name="webHostClientResourceRedirectUri" type="aaa:SamlUri" minOccurs="0">
        <xs:annotation>
          <xs:documentation>
            This URI identifies the external entity that is used by the user agent to returns a web page
            (typically an HTML document with an embedded script) capable of accessing the full redirection 
            URI including the fragment retained by the user-agent, and extracting the access token (and other
            parameters) contained in the fragment. 
            The user-agent executes the script provided by the web-hosted client resource locally, which 
            extracts the access token and passes it to the client.
          </xs:documentation>
        </xs:annotation>
        <!-- constraint: MUST be POPULATED if ((extracted identity == nameFromOAuthAuthorizationRequest) AND
                                               (flowType == ImplicitGrant) AND
                                               (roleBeingChecked == resourceOwner)
                                              )
        -->
      </xs:element>
      <xs:sequence minOccurs="0">
        <xs:element name="accessTokenRevocationRegistration" type="aaa:InvokedService">
          <xs:annotation>
            <xs:documentation>
              Identifies Application workflow that will process this access/refresh token generation. This gives the application 
              the ability to make this access token and the optionally associated refresh token available for potential revocation.
              The mechanism for deciding to revoke an issued/unexpired access token or refresh token is outside the scope of
              normal OAuth protocol processing. It is totally under the control of the larger application implementation.
            </xs:documentation>
          </xs:annotation>
        </xs:element>
        <xs:element name="applicationSpecificRegistrationOptions" type="xs:string">
          <xs:annotation>
            <xs:documentation>
              This field allows a developer to associate application specific registration options/restrictions with their
              AAA policy. This allows the application to develop a single OAuth revocation mechanism that could be used with
              multiple usages.
              
              For example, the application may want to enforce additional checking that only a single access token is 
              issued/valid with its specified scope to a specific client. In the multiple access token usage case:
              it assumes that on the initial access token creation a refresh token is issued. The refresh token 
              supports the following scopes: email, voip, and contracts. Three access tokens need to be created, one for each 
              sub-service, i.e., one for each scope. The initial request creates an access token for contract. The following 
              requests using the refresh token creates access tokens for the email and voip services.
              
              Another possible usage could be that the application is concern that clients may be compromised, i.e., losing either 
              the access token or refresh token that was issued to them to an attacker. It can discover this, by automatically
              revoking the previous issued access token when a new access token is issued. If the client/resource server report the
              loss-of-access/revocation, then the application administrator knows that sometime is going on, i.e., client 
              compromised or client service poorly implemented.
            </xs:documentation>
          </xs:annotation>
        </xs:element>
      </xs:sequence>
    </xs:sequence>
  </xs:complexType>
  <xs:complexType name="InvokedService">
    <xs:choice>
      <xs:element name="useExternalService" type="aaa:SamlUri">
        <xs:annotation>
          <xs:documentation>
            Identifies external application workflow (external service) that will process this access/refresh token generation.
          </xs:documentation>
        </xs:annotation>
      </xs:element>
      <!-- deferred to future
      <xs:element name="useInternalService">
        <xs:annotation>
          <xs:documentation>Identifies an internal service, i.e., embedded database implementation</xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:sequence/>
        </xs:complexType>
      </xs:element>
      -->
    </xs:choice>
  </xs:complexType>
  <xs:complexType name="ScopeType">
    <xs:choice>
      <xs:element name="staticValue">
        <xs:simpleType>
          <xs:restriction base="xs:string">
            <xs:minLength value="1"/>
          </xs:restriction>
        </xs:simpleType>
      </xs:element>
      <xs:element name="inputFromWorkflow" type="xs:string">
        <xs:annotation>
          <xs:documentation>
                  This value uniquely identify this user supplied data instance.
                  
                  This value is used to identify to the developer what information needs to be resolved.
                  This value is also used as the name string in the name/value pair on the extension function optional parameter.
                </xs:documentation>
        </xs:annotation>
      </xs:element>
      <xs:element name="useExtractedScope" type="aaa:EmptyType">
        <xs:annotation>
          <xs:documentation>
                  Instructs us to:
                  1) if (AuthorizationCode flow grant request) then we should package scope from incoming request header.
                  2) if (AuthorizationCode flow access token request) then we should use scope extract from supplied grant. 
                </xs:documentation>
        </xs:annotation>
        <!-- constraint: 1) ONLY ALLOWED if ((flowType == AuthorizationCode) AND (roleBeingChecked == resource_owner)) 
                         2) Error if ()
        -->
      </xs:element>
    </xs:choice>
    <xs:attribute name="type" use="required" fixed="string">
      <xs:annotation>
        <xs:appinfo>Not to be displayed. Must be populated by policy editor.</xs:appinfo>
      </xs:annotation>
      <xs:simpleType>
        <xs:restriction base="xs:string"/>
      </xs:simpleType>
    </xs:attribute>
  </xs:complexType>
  <xs:complexType name="QueryResponseTypeForExtraction">
    <xs:annotation>
      <xs:documentation>
        Information that is needed to check the decapsulate of a SAML Assertion within a SAML authentication query response. 
      </xs:documentation>
      <xs:appinfo>
        Note: the SAML Attribute query response can not be used directly here because this usage calls for a SAML Authentication query 
        response packaging ==&gt; we have to repackage the returned SAML assertion into a different SAML query response structure.
      </xs:appinfo>
    </xs:annotation>
    <xs:complexContent>
      <xs:extension base="aaa:QueryResponseBaseType">
        <xs:sequence>
          <xs:element name="checkResponseIssuer" minOccurs="0">
            <xs:complexType>
              <xs:choice>
                <xs:element name="responseIssuer" type="aaa:SamlString"/>
                <xs:element name="sameAsSamlAssertionIssuer" type="aaa:EmptyType"/>
              </xs:choice>
            </xs:complexType>
          </xs:element>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:complexType name="QueryResponseTypeForExternalCreateSamlAssertion">
    <xs:annotation>
      <xs:documentation>
        Information that is needed to encapsulate a SAML Assertion that was produced by someone else, e.g., WS-Trust Server (STS)
        or SAML Attribute Query server, within SAML authentication query response. 
      </xs:documentation>
      <xs:appinfo>
        Note: the SAML Attribute query response can not be used directly here because this usage calls for a SAML Authentication query 
        response packaging ==&gt; we have to repackage the returned SAML assertion into a different SAML query response structure.
      </xs:appinfo>
    </xs:annotation>
    <xs:complexContent>
      <xs:extension base="aaa:QueryResponseBaseType">
        <xs:sequence>
          <xs:element name="responseIssuer" type="aaa:SamlString" minOccurs="0"/>
          <xs:element name="InResponseTo" type="aaa:SamlNCName" minOccurs="0"/>
          <xs:element name="envelopedSignature" type="aaa:XmlX509EnvelopedSignatureType" minOccurs="0">
            <!-- constraint: ONLY ALLOWED if (exportDestination == to_Saml_response) -->
          </xs:element>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:complexType name="QueryResponseTypeForInternalCreateSamlAssertion">
    <xs:annotation>
      <xs:documentation>
        Information that is needed to encapsulate a SAML Assertion that was produced by us, e.g., map identity create SAML assertion. 
      </xs:documentation>
      <xs:appinfo>
        Note: the SAML Attribute query response can not be used directly here because this usage calls for a SAML Authentication query 
        response packaging ==&gt; we have to repackage the returned SAML assertion into a different SAML query response structure.
      </xs:appinfo>
    </xs:annotation>
    <xs:complexContent>
      <xs:extension base="aaa:QueryResponseBaseType">
        <xs:sequence>
          <xs:element name="responseIssuer" type="xs:boolean" default="false">
            <xs:annotation>
              <xs:documentation>Identifies the entity that generated the response message.</xs:documentation>
              <xs:appinfo>If enabled then use same issuer identified in the create SAML assertion</xs:appinfo>
            </xs:annotation>
          </xs:element>
          <xs:element name="InResponseTo" type="aaa:SamlNCName" minOccurs="0"/>
          <xs:element name="envelopedSignature" type="aaa:XmlX509EnvelopedSignatureType" minOccurs="0">
            <!-- constraint: ONLY ALLOWED if (exportDestination == to_Saml_response) -->
          </xs:element>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:complexType name="QueryResponseBaseType">
    <xs:annotation>
      <xs:documentation>Information needed for the generating a SAML Query Response</xs:documentation>
    </xs:annotation>
    <xs:sequence>
      <xs:element name="Destination" type="aaa:SamlUri" minOccurs="0">
        <xs:annotation>
          <xs:documentation>
            A URI reference indicating the address to which this response is being sent. This is useful to prevent malicious 
            forwarding of requests to unintended recipients, a protection that is required by some protocol bindings. If it is 
            present, the actual recipient MUST check that the URI reference identifies the location at which the message was 
            received. If it does not, the response MUST be discarded. Some protocol bindings may require the use of this attribute.
          </xs:documentation>
          <xs:appinfo>
            This information gets package within an attribute that is part of samlp:Response elements.
          </xs:appinfo>
        </xs:annotation>
      </xs:element>
      <xs:element name="Consent" type="aaa:ConsentType" default="urn:oasis:names:tc:SAML:2.0:consent:unspecified" minOccurs="0"/>
    </xs:sequence>
    <!-- constraint: ONLY PRESENT if (exportDestination == (to-ESG-HTTP-Authorization-saml2-bearer OR to-ESG-HTTP-Authorization-saml2-hok-ssl)) -->
  </xs:complexType>
  <xs:simpleType name="ConsentType">
    <xs:annotation>
      <xs:documentation>
        Indicates whether or not (and under what conditions) consent has been obtained from a principal in the sending of this request.
        If no Consent value is provided, the identifier urn:oasis:names:tc:SAML:2.0:consent:unspecified is in effect.
      </xs:documentation>
    </xs:annotation>
    <xs:restriction base="xs:string">
      <xs:enumeration value="urn:oasis:names:tc:SAML:2.0:consent:unspecified">
        <xs:annotation>
          <xs:documentation>No claim as to principal consent is being made.</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="urn:oasis:names:tc:SAML:2.0:consent:obtained">
        <xs:annotation>
          <xs:documentation>Indicates that a principals consent has been obtained by the issuer of the message.</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="urn:oasis:names:tc:SAML:2.0:consent:prior">
        <xs:annotation>
          <xs:documentation>
            Indicates that a principals consent has been obtained by the issuer of the message at some point prior to the action 
            that initiated the message.
          </xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="urn:oasis:names:tc:SAML:2.0:consent:current-implicit">
        <xs:annotation>
          <xs:documentation>
            Indicates that a principals consent has been implicitly obtained by the issuer of the message during the action that 
            initiated the message, as part of a broader indication of consent. Implicit consent is typically more proximal to the 
            action in time and presentation than prior consent, such as part of a session of activities.
          </xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="urn:oasis:names:tc:SAML:2.0:consent:current-explicit">
        <xs:annotation>
          <xs:documentation>
            Indicates that a principals consent has been explicitly obtained by the issuer of the message during the action that 
            initiated the message.
          </xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="urn:oasis:names:tc:SAML:2.0:consent:unavailable">
        <xs:annotation>
          <xs:documentation>Indicates that the issuer of the message did not obtain consent.</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="urn:oasis:names:tc:SAML:2.0:consent:inapplicable">
        <xs:annotation>
          <xs:documentation>
            Indicates that the issuer of the message does not believe that they need to obtain or report consent.
          </xs:documentation>
        </xs:annotation>
      </xs:enumeration>
    </xs:restriction>
  </xs:simpleType>
  <xs:complexType name="EncryptionInfo">
    <xs:annotation>
      <xs:documentation>
        Contains the following type of information:
        1) Acceptable methods, etc.
        2) Identifies the X.509 key pair or symmetric secret to be utilized.
         
        All SAML encrypted entities: EncryptedID, EncryptedAssertion and EncryptedAttribute, consist of an EncryptedData 
        element and an optional EncryptedKey element.
        When an EncryptedKey element is used, the KeyInfo element within EncryptedData SHOULD reference the
        EncryptedKey element using a RetrievalMethod element of Type http://www.w3.org/2001/04/xmlenc#EncryptedKey.
        When the encrypted element is being 'multicast' to multiple recipients, and the key used to encrypt the message must
        be in turn encrypted individually and independently for each of the multiple recipients, the CarriedKeyName element 
        SHOULD be used to assign a common name to each of the EncryptedKey elements so that a KeyName can be
        used from within the EncryptedData element's KeyInfo element.            
         
        Note: the operational code will automatically map different targetElements to the appropriate type SAML encryption
        entity: EncryptedID, EncryptedAssertion, EncryptedAttribute based upon a application specified flag associated with
        the associated explicit entity: NameID/BaseID, Attribute or Assertion.
      </xs:documentation>
    </xs:annotation>
    <xs:sequence>
      <xs:element name="generateDataEncryptionMethod">
        <xs:simpleType>
          <xs:restriction base="xs:string">
            <xs:enumeration value="aes128"/>
            <xs:enumeration value="aes192"/>
            <xs:enumeration value="aes256"/>
            <xs:enumeration value="aes128Gcm"/>
            <xs:enumeration value="aes192Gcm"/>
            <xs:enumeration value="aes256Gcm"/>
            <xs:enumeration value="des3"/>
            <xs:enumeration value="arc4"/>
          </xs:restriction>
        </xs:simpleType>
      </xs:element>
      <xs:element name="encryptKeyInfo" type="aaa:EncryptSamlKeyInfoType"/>
    </xs:sequence>
    <!-- constraint: ONLY ALLOWED when SAML Version is 2.0 -->
    <!-- constraint: (one or more NameID, Attribute) or Assertion entities MUST be specify that they are to be encrypted -->
  </xs:complexType>
  <xs:complexType name="EncryptSamlKeyInfoType">
    <xs:choice>
      <xs:element name="symmetric">
        <xs:complexType>
          <xs:sequence>
            <xs:element name="keyRecipientPair" type="aaa:KeyRecipientPair" maxOccurs="unbounded"/>
          </xs:sequence>
        </xs:complexType>
        <!-- constraint: only static symmetric key from assocaited security config package allowed -->
      </xs:element>
      <xs:element name="x509">
        <xs:complexType>
          <xs:sequence>
            <xs:element name="generateKeyTransportMethod">
              <xs:complexType>
                <xs:attribute name="method" use="required">
                  <xs:simpleType>
                    <xs:restriction base="xs:string">
                      <xs:enumeration value="rsa-v1.5"/>
                      <xs:enumeration value="rsa-oaep"/>
                    </xs:restriction>
                  </xs:simpleType>
                </xs:attribute>
                <xs:attribute name="RsaOaepDigestMethod" type="aaa:DigestGenerationMethod" use="optional" default="sha1">
                  <!-- constraint: only allowed when generateKeyTransportMethod == rsa-oaep -->
                </xs:attribute>
                <xs:attribute name="RsaOaepGenerateRandomString" type="xs:boolean" use="optional" default="false">
                  <!-- constraint: only allowed when generateKeyTransportMethod == rsa-oaep -->
                </xs:attribute>
              </xs:complexType>
            </xs:element>
            <xs:element name="keyRecipientPair" type="aaa:KeyRecipientPair" maxOccurs="unbounded"/>
          </xs:sequence>
        </xs:complexType>
      </xs:element>
    </xs:choice>
  </xs:complexType>
  <xs:complexType name="KeyRecipientPair">
    <xs:sequence>
      <xs:element name="recipientKey" type="aaa:SecurityToken"/>
      <xs:element name="recipient" type="aaa:SamlUri" minOccurs="0"/>
      <!-- constraint: MUST be specified when multiple keys (certificate/symmetric) are specified -->
      <!-- constraint: WARNING is specified when only one key (certificate/symmetric) is specified and recepicent is populated -->
    </xs:sequence>
  </xs:complexType>
  <xs:complexType name="SamlSignatureInfo">
    <xs:annotation>
      <xs:documentation>
        If present then contains information required to generate enveloped signature over entire SAML assertion.
        SAML standard only supported signature using X.509 certificate ro public key. Therefore, most of the normal signature
        parametrization is not needed/not present here.
      </xs:documentation>
    </xs:annotation>
    <xs:sequence>
      <xs:element name="signatureGenerationMethod" type="aaa:SignatureGenerationMethod" default="rsaWithSha1">
        <xs:annotation>
          <xs:documentation>What signature method will be use when generating a SAML assertion signature</xs:documentation>
        </xs:annotation>
      </xs:element>
      <xs:element name="digestGenerationMethod" type="aaa:DigestGenerationMethod" default="sha1">
        <xs:annotation>
          <xs:documentation>What digest method will we use when generating a SAML assertion signature</xs:documentation>
        </xs:annotation>
      </xs:element>
      <xs:element name="canonicalGenerationMethod" type="aaa:CanonicalGenerationMethod" default="C14N_exclusive">
        <xs:annotation>
          <xs:documentation>What canonicalization method will we use when generating a SAML assertion signature</xs:documentation>
        </xs:annotation>
      </xs:element>
      <xs:element name="keyPair" type="aaa:CreateKeyPairSecurityToken">
        <xs:annotation>
          <xs:documentation>
            Name of an asymmetricKeyPair element. Resolution based upon value of associated "use" attribute.
            This asymmetricKeyPair element identifies either a RSA or DSA public/private key pair. The public key is usually package 
            within an X.509 certificate. The private key and associated certificate can be package in the same file or in separate files.
            Depending upon the type of PKI encoding being used, the full Certificate Authority path from the leaf certificate upto the root
            Certification Authority can also be included within the actual file. When this occurs, the following caPAth element is not 
            required to be specified.
              
            This element is used to populate the near-end private key, near-end certificate [and CA Path] for signature generation and decryption.
            For signature generation, the near-end private key is used in the actual cryptographic operation. 
            For signature generation, the near-end certificate and caPath may be package into the keyinfo of the actual message being send 
            because we will assume keyInfo format=Certificate. 
            For signature generation, any CA Path certificates that are present in the specified x509KeyPair will not be utilized in this release.
            Only explicitly defined caPath certificates will be supported.
          </xs:documentation>
        </xs:annotation>
      </xs:element>
      <xs:element name="caPath" type="aaa:CreateCaPathSecurityToken" minOccurs="0">
        <xs:annotation>
          <xs:documentation>
            Name of a caPath element.
            This element identifies a list of untrusted Certificate Authorities.
            It can be specified in two possible formats (See "Web Services Security X.509 Certificate Token Profile 1.1 OASIS Standard
            Specification, 1 February 2006" for details.
            1) one or more PEM format Certificate Authorities certificates concatenated in the same physical file. The order of certificates is 
               such that the subject of the first certificate is the issuer of the second certificate, etc. Additionally, the certificate path 
               excludes the end-entity certficate. This format is implied by a BinarySecurityToken with its attribute ValueType"#X509PKIPathv1".
               See ITU-T Rec.X.509 (2000)/Cor.1 (10/2001 E) for details.
            2) PKCS7 bag. This format is implied by a BinarySecurityToken with its attribute ValueType="#PKCS7".
             
            In signature generation, this caPath should be physically packaged within the actual message being sent.
          </xs:documentation>
        </xs:annotation>
      </xs:element>
    </xs:sequence>
  </xs:complexType>
  <xs:complexType name="SourceAssertionInfo">
    <xs:annotation>
      <xs:documentation>
        Identifies the different SAML Assertion elements and attributes that the application wants generated along 
        with any application specific information that is needed to populate their value. 
        We will automatically populate the following entity based upon the SAML version.
        elements: AssertionID, AssertIDReference, AuthenticationStatement.
        attributes: major version, minor version, AuthenticationInstant, AuthnStatement AuthnInstant.
      </xs:documentation>
    </xs:annotation>
    <xs:choice>
      <xs:element name="v1dotxInfo" type="aaa:V1dotXSourceInfo"/>
      <xs:element name="v2dot0Info" type="aaa:V2dot0SourceInfo"/>
    </xs:choice>
  </xs:complexType>
  <xs:complexType name="V1dotXSourceInfo">
    <xs:annotation>
      <xs:documentation>SAML Version 1.0 and 1.1 Information need to populate SAML Assertion to be generated.</xs:documentation>
    </xs:annotation>
    <xs:sequence>
      <xs:element name="generalAssertionInfo" type="aaa:GeneralAssertionInfo"/>
      <!-- deferred
      <xs:element name="Advice" type="aaa:Advice-1dotx" minOccurs="0"/>
      -->
      <xs:element name="Conditions" type="aaa:ConditionsInfo-1dotx" minOccurs="0"/>
      <!-- deferred
      <xs:element name="SubjectStatement" type="aaa:SubjectStatementInfo" minOccurs="0" maxOccurs="unbounded"/>
      -->
      <xs:element name="AuthenticationStatement" type="aaa:AuthenticationStatementInfo" minOccurs="0" maxOccurs="unbounded"/>
      <!-- deferred
      <xs:element name="AuthorizationDecisionStatement" type="aaa:AuthorizationDecisionStatementInfo" minOccurs="0" maxOccurs="unbounded"/>
      <xs:element name="AttributeStatement" type="aaa:AttributeStatementV1dotx" minOccurs="0" maxOccurs="unbounded"/>
      -->
    </xs:sequence>
  </xs:complexType>
  <xs:complexType name="V2dot0SourceInfo">
    <xs:annotation>
      <xs:documentation>SAML Version 2.0 Information need to populate SAML Assertion to be generated.</xs:documentation>
    </xs:annotation>
    <xs:sequence>
      <xs:element name="generalAssertionInfo" type="aaa:GeneralAssertionInfo-2dot0"/>
      <xs:element name="Subject" type="aaa:SubjectInfo" minOccurs="0"/>
      <xs:element name="Conditions" type="aaa:ConditionsInfo-2dot0" minOccurs="0"/>
      <!-- deferred
      <xs:element name="Advice" type="aaa:Advice-2dot0" minOccurs="0"/>
      -->
      <xs:element name="AuthnStatement" type="aaa:AuthnStatementInfo" minOccurs="0" maxOccurs="unbounded"/>
      <xs:element name="AttributeStatement" type="aaa:AttributeStatementV2dot0" minOccurs="0" maxOccurs="unbounded">
        <!-- constraint: ONLY ALLOWED if ((extract identity == nameFromOAuthAuthorizationRequest) AND 
                                          (authorizationCodeRequestType == grantRequest) AND
                                          (roleBeingChecked == resource_owner)
                                         )
        -->
      </xs:element>
      <!-- deferred
      <xs:element name="AuthzDecisionStatement" type="aaa:AuthzDecisionStatementInfo" minOccurs="0" maxOccurs="unbounded"/>
      -->
    </xs:sequence>
  </xs:complexType>
  <xs:complexType name="GeneralAssertionInfo">
    <xs:sequence>
      <xs:element name="Issuer" type="aaa:SamlString">
        <xs:annotation>
          <xs:appinfo>Constraint: Service Designer should populate the value for inputFromWorkflow to: SAML-assertion_Issuer</xs:appinfo>
        </xs:annotation>
      </xs:element>
      <xs:element name="skew" default="10" minOccurs="0">
        <xs:annotation>
          <xs:documentation>
            Time in seconds that SAML assertion generator and consuming system clock needs to support.
            NotBefore set to current time - skew.
            NoOnOrAfter set to current time + skew + maximum_expiration_time.
          </xs:documentation>
        </xs:annotation>
        <xs:simpleType>
          <xs:restriction base="xs:unsignedInt">
            <xs:maxInclusive value="360">
              <xs:annotation>
                <xs:documentation>maximum allowed value is 6 minute = 360 seconds</xs:documentation>
              </xs:annotation>
            </xs:maxInclusive>
          </xs:restriction>
        </xs:simpleType>
      </xs:element>
      <xs:element name="maxExpirationTime" type="aaa:ExpirationLifetimeType" minOccurs="0">
        <xs:annotation>
          <xs:documentation>
            Time in seconds that SAML assertion generaqtor allows for consumer to use assertion.
            NoOnOrAfter set to current time + skew + maximum_expiration_time.
          </xs:documentation>
        </xs:annotation>
      </xs:element>
      <xs:element name="Statement" type="aaa:SamlAppExtPt" minOccurs="0" maxOccurs="unbounded">
        <xs:annotation>
          <xs:appinfo>Constraint: Service Designer should populate the value for inputFromWorkflow to: SAML-assertion_Statement</xs:appinfo>
        </xs:annotation>
      </xs:element>
    </xs:sequence>
  </xs:complexType>
  <xs:complexType name="GeneralAssertionInfo-2dot0">
    <xs:complexContent>
      <xs:extension base="aaa:GeneralAssertionInfo">
        <xs:sequence>
          <xs:element name="IssuerNameQualifierAttribute" type="aaa:SamlString" minOccurs="0">
            <xs:annotation>
              <xs:documentation>
                The security or administrative domain that qualifies the name. This attribute provides a means
                to federate names from disparate user stores without collision.
              </xs:documentation>
            </xs:annotation>
          </xs:element>
          <xs:element name="IssuerFormatAttribute" type="aaa:NameIdFormatType" minOccurs="0">
            <xs:annotation>
              <xs:documentation>
                A URI reference representing the classification of string-based identifier information.
              </xs:documentation>
            </xs:annotation>
          </xs:element>
          <!-- deferred
          <xs:element name="IssuerSPNameQualifierAttribute" type="aaa:SamlString" minOccurs="0">
            <xs:annotation>
              <xs:documentation>
                Further qualifies a name with the name of a service provider or affiliation of providers. 
                This attribute provides an additional means to federate names on the basis of the relying party 
                or parties.
              </xs:documentation>
            </xs:annotation>
          </xs:element>
          <xs:element name="SPProvidedID" type="aaa:SamlString" minOccurs="0">
            <xs:annotation>
              <xs:documentation>
                A name identifier established by a service provider or affiliation of providers for the entity, 
                if different from the primary name identifier given in the content of the element. This attribute
                provides a means of integrating the use of SAML with existing identifiers already in use by a
                service provider.
              </xs:documentation>
            </xs:annotation>
          </xs:element>
          -->
          <xs:element name="encryptAssertion" type="xs:boolean" default="false" minOccurs="0">
            <xs:annotation>
              <xs:documentation>Indicates that entire Assertion is to be encrypted</xs:documentation>
            </xs:annotation>
            <!-- constraint: if encyptAssertion is TRUE then the encryptID must be FALSE -->
          </xs:element>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:complexType name="SubjectStatementInfo">
    <xs:annotation>
      <xs:documentation>
        SubjectStatement_element -&gt; Subject_element information in SAML 1.0 and 1.1
      </xs:documentation>
      <xs:appinfo>Not used in restrictive AAA SAML authentication assertion</xs:appinfo>
    </xs:annotation>
    <xs:sequence>
      <xs:element name="Subject-NameIdentifier-NameQualifier-Attribute" type="aaa:SamlString" minOccurs="0"/>
      <xs:element name="Subject-NameIdentifier-Format-Attribute" type="aaa:NameIdFormatType" minOccurs="0"/>
      <xs:element name="Subject-NameIdentifier" type="aaa:SamlString" minOccurs="0"/>
      <xs:element name="Subject-SubjectConfirmation" type="aaa:SubjectConfirmationType" minOccurs="0"/>
    </xs:sequence>
  </xs:complexType>
  <xs:complexType name="SubjectInfo">
    <xs:annotation>
      <xs:documentation>
        Subject_element information in SAML 2.0.
        When a SubjectConfirmation element is being defined, we should automatically generate the following SubjectConfirmationData entities:
        1) NotBefore attribute: current time - skew
        2) NotOnOrAfter attribute: current time +skew + maximum_expiration-time
      </xs:documentation>
    </xs:annotation>
    <xs:sequence>
      <xs:choice>
        <xs:sequence>
          <xs:element name="NameID-NameQualifier-Attribute" type="aaa:SamlString" minOccurs="0"/>
          <!-- deferred
          <xs:element name="NameID-SPNameQualifier-Attribute" type="aaa:SamlString" minOccurs="0"/>
          -->
          <xs:element name="NameID-Format-Attribute" type="aaa:SamlNameIdFormat" minOccurs="0"/>
          <!-- deferred 
          <xs:element name="NameID-SPProvidedID-Attribute" type="aaa:SamlString" minOccurs="0"/>
          -->
          <xs:element name="NameID">
            <xs:annotation>
              <xs:documentation>Identifies the intended subject of the SAML Authentication Assertion</xs:documentation>
            </xs:annotation>
            <xs:complexType>
              <xs:complexContent>
                <xs:extension base="aaa:AuthenticationSubjectNameIdentifierValue">
                  <xs:sequence>
                    <xs:element name="encryptID" type="xs:boolean" default="false" minOccurs="0">
                      <xs:annotation>
                        <xs:documentation>Indicates if associated NameID is to be encrypted.</xs:documentation>
                      </xs:annotation>
                      <!-- constraint: if encryptID is TRUE then encryptionInfo must be populated -->
                      <!-- constraint: if encryptID is TRUE then the encyptAssertion must be FALSE -->
                    </xs:element>
                  </xs:sequence>
                </xs:extension>
              </xs:complexContent>
            </xs:complexType>
          </xs:element>
          <xs:element name="SubjectConfirmation" type="aaa:SubjectConfirmationType" minOccurs="0">
            <!-- constraint: if Subject-NameID is not populated then Subject-SubjectConfirmation MUST be populated -->
          </xs:element>
        </xs:sequence>
        <!-- deferred
        <xs:sequence>
          <xs:element name="BaseID-NameQualifier-Attribute" type="wssec:SamlString" minOccurs="0"/>
          <xs:element name="BaseID-SPNameQualifier-Attribute" type="wssec:SamlString" minOccurs="0"/>
          <xs:element name="BaseID" type="wssec:SamlString"/>
        </xs:sequence>
        -->
      </xs:choice>
    </xs:sequence>
  </xs:complexType>
  <xs:complexType name="AuthenticationStatementInfo">
    <xs:sequence>
      <xs:element name="Subject-NameIdentifier" type="aaa:AuthenticationSubjectNameIdentifierValue"/>
      <xs:element name="Subject-NameIdentifier-NameQualifier-Attribute" type="aaa:SamlString" minOccurs="0">
        <xs:annotation>
          <xs:appinfo>Constraint: Service Designer should populate the value for inputFromWorkflow to: SAML-assertion_Subject_NameIdentifier_NameQualifier</xs:appinfo>
        </xs:annotation>
      </xs:element>
      <xs:element name="Subject-NameIdentifier-Format-Attribute" type="aaa:NameIdFormatType" default="urn:oasis:names:tc:SAML:1.1:nameid-format:unspecified"/>
      <xs:element name="AuthenticationMethod-Attribute" type="aaa:AuthenticationMethodType" default="urn:oasis:names:tc:SAML:1.0:am:password"/>
      <xs:element name="Subject-SubjectConfirmation" type="aaa:V1_SubjectConfirmationType" minOccurs="0">
        <!-- constraint: if Subject-NameIdentifier is not populated then Subject-SubjectConfirmation MUST be populated -->
      </xs:element>
      <xs:element name="SubjectLocality-IPAddress-Attribute" type="aaa:AuthenticationLocalityIpAddressValue" minOccurs="0"/>
      <!-- deferred -->
      <xs:choice minOccurs="0" maxOccurs="unbounded">
        <xs:element name="SubjectLocality-DNSAddress-Attribute" type="aaa:SamlString"/>
        <xs:element name="AuthorityBinding-AuthorityKind-Attribute" type="xs:QName"/>
        <xs:element name="AuthorityBinding-Location-Attribute" type="aaa:SamlUri"/>
        <xs:element name="AuthorityBinding-Binding-Attribute" type="aaa:SamlUri"/>
      </xs:choice>
    </xs:sequence>
  </xs:complexType>
  <xs:complexType name="AuthnStatementInfo">
    <xs:annotation>
      <xs:documentation>
        SAML V2.0 AuthnStatement.
     </xs:documentation>
      <xs:appinfo>
        We will automatically populate the following SAML v2.0 AuthnStatement entities:
        1) SessionNotOnOrAfter attribute: Current time + skew + maximum_expiration_time
        2) AuthnInstant attribute: current time.
     </xs:appinfo>
    </xs:annotation>
    <xs:sequence>
      <xs:element name="SubjectLocality-Address-Attribute" type="aaa:AuthenticationLocalityIpAddressValue" minOccurs="0"/>
      <xs:element name="AuthnContext-AuthnContextClassRef" type="aaa:AuthenticationMethodType"/>
      <!-- deferred
      <xs:element name="SubjectLocality-DNSName-Attribute" type="aaa:SamlString" minOccurs="0"/>
      <xs:element name="AuthnContext-AuthenticatingAuthority" type="aaa:SamlUri" minOccurs="0" maxOccurs="unbounded"/>
      <xs:choice>
        <xs:element name="AuthnContext-AuthnContextClassDecl" type="aaa:SamlAppExtPt" minOccurs="0"/>
        </xs:element>
        <xs:element name="AuthnContext-AuthnContextClassDeclRef" type="aaa:SamlUri" minOccurs="0"/>
      </xs:choice>
      -->
    </xs:sequence>
  </xs:complexType>
  <xs:complexType name="AuthenticationSubjectNameIdentifierValue">
    <xs:annotation>
      <xs:documentation>
        Allows an application to specify either:
        1) a hardcored string that is know at policy defination time, or
        2) a BEPL variable associated an input parameter associated with the AAA action.
      </xs:documentation>
    </xs:annotation>
    <xs:choice>
      <xs:element name="staticValue" type="xs:string">
        <xs:annotation>
          <xs:documentation>Allow application to hardcode SAML Assertion when SOAE acting as full proxy for authenticated user</xs:documentation>
        </xs:annotation>
      </xs:element>
      <xs:element name="automaticallyGenerated">
        <xs:annotation>
          <xs:documentation>
            Allows application to automatically encode extracted identity into SAML Assertion being created, i.e., mapping incoming 
            credential format to a different outgoing credential format.
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:sequence>
            <xs:element name="distinguishedNamePrefix" type="aaa:DistinguishedNameType">
              <xs:annotation>
                <xs:documentation>This string will be used to prefix the extracted identity</xs:documentation>
              </xs:annotation>
            </xs:element>
            <xs:element name="distinguishedNamePostfix" type="aaa:DistinguishedNameType">
              <xs:annotation>
                <xs:documentation>This string will be used to postfix the extracted identity.</xs:documentation>
              </xs:annotation>
            </xs:element>
            <xs:element name="generatedInternalWorkflowParameter">
              <xs:annotation>
                <xs:documentation>
                  This value uniquely identify this user supplied data instance.
                  
                  Action builder will package the extracted identifier between the distinguished prefix and postfix strings.
                  generatedInternalWorkflowParamater is used as the name string in the name/value pair on the extension function optional parameter.
                  The value will be the concatenated string.
                </xs:documentation>
              </xs:annotation>
              <!-- constraint: Should not be user visible. -->
              <xs:simpleType>
                <xs:restriction base="xs:NMTOKEN">
                  <xs:enumeration value="Authentication-Subject-NameIdentifier-Use-Authenticated">
                    <!-- constraint: NOT ALLOWED if (extracted identity is ssoFromCookie or ssoFromWorkflow) -->
                    <!-- constraint: NOT ALLOWED if 
                                    ((extracted identity is (certificateAttributeFromSecurityHeader or x509CertificateFromSecurityHeader or 
                                      certificateFromPeerSsl or bstFromVerifyOperation or x509CertificateFromWorkflow)
                                     ) AND 
                                     (certificate attribute type is (SKI or fullCertificate or Md5Fingerprint or generatedSKI 
                                       or generatedShortSKI or issueSerialNumber)
                                     )
                                    ) 
                         Note: X509 certificate only allowed when certificate attribute is subject name and Sha1Fingerprint (Sha1Thumbprint).
                    -->
                    <!-- constraint: NOT ALLOWED if (authenticateIdentity is checkX509CertificateChainOfTrust -->
                    <!-- constraint: 
                         WARNING "multiple SAML assertion based upon same extracted name being created" if ((extract identity is 
                         nameFromSamlAuthentication) AND (remove token is false)) 
                    -->
                    <!-- constraint: NOT ALLOWED if (authenticateIdentity is principalNameFromKerberosToken) -->
                  </xs:enumeration>
                  <xs:enumeration value="Authentication-Subject-NameIdentifier-Use-Extracted">
                    <!-- constraint: NOT ALLOWED if (extracted identity is ssoFromCookie or ssoFromWorkflow) -->
                    <!-- constraint: NOT ALLOWED if 
                                    ((extracted identity is (certificateAttributeFromSecurityHeader or x509CertificateFromSecurityHeader or 
                                      certificateFromPeerSsl or bstFromVerifyOperation or x509CertificateFromWorkflow)
                                     ) AND 
                                     (certificate attribute type is (SKI or fullCertificate or Md5Fingerprint or generatedSKI 
                                       or generatedShortSKI or issueSerialNumber)
                                     )
                                    ) 
                         Note: X509 certificate only allowed when certificate attribute is subject name and Sha1Fingerprint (Sha1Thumbprint).
                    -->
                    <!-- constraint: 
                         WARNING "multiple SAML assertion based upon same extracted name being created" if (extract identity is nameFromSamlAuthentication) 
                    -->
                  </xs:enumeration>
                  <xs:enumeration value="Authentication-Subject-NameIdentifier-Use-RetrievedSso-UserDN">
                    <!-- constraint: ONLY ALLOWED if (extracted identity is ssoFromCookie or ssoFromWorkflow) and ((authentication mechanism is SiteMinder) or (authorization mechanism is SiteMinder)) -->
                    <!-- constraint: 
                         WARNING "multiple SAML assertion based upon same extracted name being created" if ((extract identity is 
                         nameFromSamlAuthentication) AND (remove token is false)) 
                    -->
                  </xs:enumeration>
                  <xs:enumeration value="Authentication-Subject-NameIdentifier-Use-RetrievedSso-Username">
                    <!-- constraint: ONLY ALLOWED if (extracted identity is ssoFromCookie or ssoFromWorkflow) and ((authentication mechanism is SiteMinder) or (authorization mechanism is SiteMinder)) -->
                    <!-- constraint: 
                         WARNING "multiple SAML assertion based upon same extracted name being created" if ((extract identity is 
                         nameFromSamlAuthentication) AND (remove token is false)) 
                    -->
                  </xs:enumeration>
                  <xs:enumeration value="Authentication-Subject-NameIdentifier-Use-RetrievedSso-Identity">
                    <!-- constraint: ONLY ALLOWED if (extracted identity is ssoFromCookie or ssoFromWorkflow) and ((authentication mechanism is OAM) or (authorization mechanism is OAM)) -->
                  </xs:enumeration>
                </xs:restriction>
              </xs:simpleType>
            </xs:element>
          </xs:sequence>
        </xs:complexType>
      </xs:element>
    </xs:choice>
    <xs:attribute name="type" use="required" fixed="string">
      <xs:annotation>
        <xs:appinfo>Not to be displayed. Must be populated by policy editor.</xs:appinfo>
      </xs:annotation>
      <xs:simpleType>
        <xs:restriction base="xs:string"/>
      </xs:simpleType>
    </xs:attribute>
  </xs:complexType>
  <xs:complexType name="AuthenticationLocalityIpAddressValue">
    <xs:annotation>
      <xs:documentation/>
    </xs:annotation>
    <xs:choice>
      <xs:element name="use-incoming-client-ip-address" type="xs:NMTOKEN" fixed="internal-name:client-ip-address-from-incoming-metadata">
        <xs:annotation>
          <xs:appinfo>
            We will automatically extract the client IP-address from the incoming HTTP IS metadata and insert it into SAML assertion.
          </xs:appinfo>
        </xs:annotation>
        <!-- constraint: Only intended when input server is HTTP. However, not sure that this constraint is enforceable by service designer policy editor/action builder? -->
      </xs:element>
      <xs:element name="use-retrieved-sso-ip-address" type="xs:NMTOKEN" fixed="internal-name:ip-address-from-retrieved-sso-token">
        <xs:annotation>
          <xs:appinfo>
            We will automatically extract the IP-address from the SiteMinder or OAM IA response message and insert it into SAML assertion.
          </xs:appinfo>
        </xs:annotation>
        <!-- constraint: Only ALLOWED when (extract identity is ssoFromCookie or ssoFromWorkflow) and (authentication or authorization mechanism is SiteMinder or OAM) -->
      </xs:element>
      <xs:element name="staticValue" type="xs:anyURI">
        <xs:annotation>
          <xs:documentation>Allow application to hardcode SAML Assertion when SOAE acting as full proxy for authenticated user</xs:documentation>
        </xs:annotation>
        <!-- not sure that this makes any sense. How do we know what IP address we will actually use for sending? -->
      </xs:element>
      <xs:element name="inputFromWorkflow" type="xs:string">
        <xs:annotation>
          <xs:appinfo>Constraint: Service Designer should populate the value for inputFromWorkflow to: SAML-assertion_Authentication_Locality_IP-Address</xs:appinfo>
          <xs:documentation>
            Application developer will supply data from workflow when AAA policy bound to action.
          </xs:documentation>
        </xs:annotation>
      </xs:element>
    </xs:choice>
    <xs:attribute name="type" use="required" fixed="string">
      <xs:annotation>
        <xs:appinfo>Not to be displayed. Must be populated by policy editor.</xs:appinfo>
      </xs:annotation>
      <xs:simpleType>
        <xs:restriction base="xs:string"/>
      </xs:simpleType>
    </xs:attribute>
  </xs:complexType>
  <xs:complexType name="AuthorizationDecisionStatementInfo">
    <xs:annotation>
      <xs:appinfo>Not utilizied in restricted AAA SAML authentication assertion</xs:appinfo>
    </xs:annotation>
    <xs:sequence>
      <xs:element name="Resource-Attribute" type="aaa:SamlUri"/>
      <xs:element name="Decision-Attribute" type="aaa:DecisionType"/>
      <xs:element name="Subject-NameIdentifier-NameQualifier-Attribute" type="aaa:SamlString" minOccurs="0"/>
      <xs:element name="Subject-NameIdentifier-Format-Attribute" type="aaa:NameIdFormatType" minOccurs="0"/>
      <xs:element name="Subject-NameIdentifier" type="aaa:SamlString" minOccurs="0"/>
      <xs:element name="Subject-SubjectConfirmation" type="aaa:SubjectConfirmationType" minOccurs="0"/>
      <xs:element name="Action" type="aaa:ActionType" maxOccurs="unbounded"/>
    </xs:sequence>
  </xs:complexType>
  <xs:complexType name="AuthzDecisionStatementInfo">
    <xs:sequence>
      <xs:element name="Resource-Attribute" type="aaa:SamlUri"/>
      <xs:element name="Decision-Attribute" type="aaa:DecisionType"/>
      <xs:element name="Action" type="aaa:ActionType" maxOccurs="unbounded"/>
    </xs:sequence>
  </xs:complexType>
  <xs:complexType name="ActionType">
    <xs:sequence>
      <xs:element name="Action-NameSpace-Attribute" type="aaa:SamlUri" minOccurs="0"/>
      <xs:element name="value" type="aaa:SamlString">
        <xs:annotation>
          <xs:documentation>This is the value of the Action element instance</xs:documentation>
        </xs:annotation>
      </xs:element>
    </xs:sequence>
  </xs:complexType>
  <xs:complexType name="Advice-1dotx">
    <xs:sequence>
      <!-- deferred
      <xs:element name="AssertionIDReference" type="aaa:SamlNCName" minOccurs="0" maxOccurs="unbounded"/>
      <xs:element name="Assertion" type="aaa:SamlAppExtPt" minOccurs="0" maxOccurs="unbounded"/>
      -->
    </xs:sequence>
  </xs:complexType>
  <xs:complexType name="Advice-2dot0">
    <xs:sequence>
      <!-- deferred
      <xs:element name="AssertionIDRef" type="aaa:SamlNCName" minOccurs="0" maxOccurs="unbounded"/>
      <xs:element name="AssertionURIRef" type="aaa:SamlUri" minOccurs="0" maxOccurs="unbounded"/>
      <xs:element name="Assertion" type="aaa:SamlAppExtPt" minOccurs="0" maxOccurs="unbounded"/>
      -->
    </xs:sequence>
  </xs:complexType>
  <xs:complexType name="ConditionsInfo-1dotx">
    <xs:sequence>
      <xs:element name="AudienceRestrictionCondition-Audience" type="aaa:SamlUri" minOccurs="0" maxOccurs="unbounded"/>
      <xs:element name="DoNotCacheCondition" type="aaa:EmptyType" nillable="true" minOccurs="0"/>
      <!-- deferred
      <xs:element name="Condition" type="aaa:SamlAppExtPt" minOccurs="0" maxOccurs="unbounded">
        <xs:annotation>
          <xs:documentation>
            Extension Point.
            Application may add multiple Condition elements with their own semantics here as long as it is valid XML.
          </xs:documentation>
        </xs:annotation>
      </xs:element>
      -->
    </xs:sequence>
  </xs:complexType>
  <xs:complexType name="ConditionsInfo-2dot0">
    <xs:sequence>
      <xs:element name="AudienceRestriction-Audience" type="aaa:SamlUri" minOccurs="0" maxOccurs="unbounded">
        <xs:annotation>
          <xs:documentation>Specifies that the assertion is addressed to a particular audience.</xs:documentation>
        </xs:annotation>
      </xs:element>
      <xs:element name="OneTimeUse" type="aaa:EmptyType" nillable="true" minOccurs="0">
        <xs:annotation>
          <xs:documentation>Assertion SHOULD be used immediately and MUST NOT be retained for future use.</xs:documentation>
        </xs:annotation>
      </xs:element>
      <!-- deferred
      <xs:element name="ProxyRestriction-Audience" type="aaa:SamlUri" minOccurs="0/>
      <xs:element name="ProxyRestriction-Count" type="xs:nonNegativeInteger" minOccurs="0>
        <xs:annotation>
          <xs:documentation>Attribute. No clear on its semantics.</xs:documentation>
        </xs:annotation>
      </xs:element>
      <xs:element name="Condition" type="aaa:SamlAppExtPt" minOccurs="0>
        <xs:annotation>
          <xs:documentation>
            Extension Point.
            Application may add multiple Condition elements with their own semantics here as long as it is valid XML.
          </xs:documentation>
        </xs:annotation>
      </xs:element>
      -->
    </xs:sequence>
  </xs:complexType>
  <xs:complexType name="AttributeStatementV1dotx">
    <xs:annotation>
      <xs:appinfo>Not utilized in restrictive AAA SAML authentication assertion</xs:appinfo>
    </xs:annotation>
    <xs:sequence>
      <xs:element name="Subject-NameIdentifier-NameQualifier-Attribute" type="aaa:SamlString" minOccurs="0"/>
      <xs:element name="Subject-NameIdentifier-Format-Attribute" type="aaa:NameIdFormatType" minOccurs="0"/>
      <xs:element name="Subject-NameIdentifier" type="aaa:SamlString" minOccurs="0"/>
      <xs:element name="Subject-SubjectConfirmation" type="aaa:SubjectConfirmationType" minOccurs="0"/>
      <xs:element name="Attribute" maxOccurs="unbounded">
        <xs:complexType>
          <xs:sequence>
            <xs:element name="AttributeName" type="aaa:SamlString"/>
            <xs:element name="AttributeNamespace" type="aaa:SamlUri"/>
            <xs:element name="AttributeValue" type="aaa:SamlAppExtPt" maxOccurs="unbounded"/>
          </xs:sequence>
        </xs:complexType>
      </xs:element>
    </xs:sequence>
  </xs:complexType>
  <xs:complexType name="AttributeStatementV2dot0">
    <xs:sequence>
      <xs:element name="Attribute" maxOccurs="unbounded">
        <xs:complexType>
          <xs:sequence>
            <xs:element name="Name-attribute" type="aaa:SamlString"/>
            <xs:element name="NameFormat-attribute" type="aaa:NameFormatType" minOccurs="0"/>
            <xs:element name="FriendlyName-attribute" type="aaa:SamlString" minOccurs="0"/>
            <xs:element name="AttributeValue" type="aaa:SamlAppExtPt" minOccurs="0" maxOccurs="unbounded"/>
          </xs:sequence>
        </xs:complexType>
      </xs:element>
    </xs:sequence>
  </xs:complexType>
  <xs:complexType name="V1_SubjectConfirmationType">
    <xs:sequence>
      <xs:element name="Method" type="aaa:ConfirmationMethodType">
        <xs:annotation>
          <xs:documentation>
            For SAML 2.0, ConfirmationMethod is embedded within Subject_element - SubjectConfirmation_element. 
            ConfirmationMethod is mapped to Method_attribute.
          </xs:documentation>
        </xs:annotation>
        <!-- constraint: 
              1) If any holder-of-key confirmation method selected then the SAML assertion must be signed.
              2) While we should expect that the SAML version should restrict the actual value, it is possible
                 for a user to use value from a different release. At most, we should generate a warning message 
                 when a developer selects a value from a different SAML version.
        -->
      </xs:element>
      <xs:element name="confirmationKeyInfo" type="aaa:HolderOfKeyKeyInfo" minOccurs="0">
        <!-- constraint: 1) only Present when SubjectConfirmationType Method is some form of holder-of-key
                         2) MUST be populated if SubjectConfirmationType Method is some form of holder-of-key
        -->
      </xs:element>
      <!-- deferred for AAA
      <xs:element name="SubjectConfirmationData" type="aaa:SamlAppExtPt" minOccurs="0"/>
      -->
    </xs:sequence>
  </xs:complexType>
  <xs:complexType name="SubjectConfirmationType">
    <xs:sequence>
      <xs:element name="Method" type="aaa:ConfirmationMethodType">
        <xs:annotation>
          <xs:documentation>
            For SAML 2.0, ConfirmationMethod is embedded within Subject_element - SubjectConfirmation_element. 
            ConfirmationMethod is mapped to Method_attribute.
          </xs:documentation>
        </xs:annotation>
        <!-- constraint: 
              1) If any holder-of-key confirmation method selected then the SAML assertion must be signed.
              2) While we should expect that the SAML version should restrict the actual value, it is possible
                 for a user to use value from a different release. At most, we should generate a warning message 
                 when a developer selects a value from a different SAML version.
        -->
      </xs:element>
      <xs:element name="confirmationKeyInfo" type="aaa:HolderOfKeyKeyInfo" minOccurs="0">
        <!-- constraint: 1) only Present when SubjectConfirmationType Method is some form of holder-of-key
                         2) MUST be populated if SubjectConfirmationType Method is some form of holder-of-key
        -->
      </xs:element>
      <xs:element name="SubjectConfirmationData-Recipent-Attribute" type="aaa:SamlUri" minOccurs="0"/>
      <xs:element name="SubjectConfirmationData-InResponseTo-Attribute" type="aaa:SamlNCName" minOccurs="0"/>
      <xs:element name="SubjectConfirmationData-Address-Attribute" type="aaa:SamlString" minOccurs="0"/>
      <!-- deferred for AAA
      <xs:element name="SubjectConfirmationData" type="aaa:SamlAppExtPt" minOccurs="0"/>
      -->
    </xs:sequence>
  </xs:complexType>
  <xs:simpleType name="ConfirmationMethodType">
    <xs:restriction base="xs:anyURI">
      <xs:enumeration value="urn:oasis:names:tc:SAML:1.0:cm:sender-vouches">
        <xs:annotation>
          <xs:documentation>
            Indicates that no other information is available about the context of use of the assertion. The relying party SHOULD utilize 
            other means to determine if it should process the assertion further, subject to optional constraints on confirmation using 
            the attributes that MAY be present in the SubjectConfirmationData element.
          </xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="urn:oasis:names:tc:SAML:1.1:cm:sender-vouches">
        <xs:annotation>
          <xs:documentation>
            Indicates that no other information is available about the context of use of the assertion. The relying party SHOULD utilize 
            other means to determine if it should process the assertion further, subject to optional constraints on confirmation using 
            the attributes that MAY be present in the SubjectConfirmationData element.
          </xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="urn:oasis:names:tc:SAML:2.0:cm:sender-vouches">
        <xs:annotation>
          <xs:documentation>
            Indicates that no other information is available about the context of use of the assertion. The relying party SHOULD utilize 
            other means to determine if it should process the assertion further, subject to optional constraints on confirmation using 
            the attributes that MAY be present in the SubjectConfirmationData element.
          </xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="urn:oasis:names:tc:SAML:1.0:cm:bearer">
        <xs:annotation>
          <xs:documentation>
            The subject of the assertion is the bearer of the assertion, subject to optional constraints on confirmation using the attributes 
            that MAY be present in the SubjectConfirmationData element.
          </xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="urn:oasis:names:tc:SAML:1.1:cm:bearer">
        <xs:annotation>
          <xs:documentation>
            The subject of the assertion is the bearer of the assertion, subject to optional constraints on confirmation using the attributes 
            that MAY be present in the SubjectConfirmationData element.
          </xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="urn:oasis:names:tc:SAML:2.0:cm:bearer">
        <xs:annotation>
          <xs:documentation>
            The subject of the assertion is the bearer of the assertion, subject to optional constraints on confirmation using the attributes 
            that MAY be present in the SubjectConfirmationData element.
          </xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="urn:oasis:names:tc:SAML:1.0:cm:artifact">
        <xs:annotation>
          <xs:documentation>
              Artifact Resolution protocol for dereferencing a SAML artifact into a corresponding protocol message.
          </xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="urn:oasis:names:tc:SAML:1.1:cm:artifact">
        <xs:annotation>
          <xs:documentation>
            Artifact Resolution protocol for dereferencing a SAML artifact into a corresponding protocol message.
          </xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="urn:oasis:names:tc:SAML:2.0:cm:artifact">
        <xs:annotation>
          <xs:documentation>
            Artifact Resolution protocol for dereferencing a SAML artifact into a corresponding protocol message.
          </xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="urn:oasis:names:tc:SAML:1.0:cm:holder-of-key">
        <xs:annotation>
          <xs:documentation>
            The holder of a specified key is considered to be the subject of the assertion by the asserting party.
            When this is used one or more associated KeyInfo elements MUST be defined.
          </xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="urn:oasis:names:tc:SAML:1.1:cm:holder-of-key">
        <xs:annotation>
          <xs:documentation>
            The holder of a specified key is considered to be the subject of the assertion by the asserting party.
            When this is used one or more associated KeyInfo elements MUST be defined.
          </xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="urn:oasis:names:tc:SAML:2.0:cm:holder-of-key">
        <xs:annotation>
          <xs:documentation>
            The holder of a specified key is considered to be the subject of the assertion by the asserting party.
            When this is used one or more associated KeyInfo elements MUST be defined.
          </xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <!-- Supporting holder-of-key is more complex because complex KeyInfo element must also be populated. We should be able to support this 
           when extracted identity is username or X.509-related entity. However, deferring until a later release based upon actual customer needs.
           This is also true for all the other confirmation method types whose usage are very business area specific.
      -->
      <!-- deferred  
      <xs:enumeration value="urn:mace:shibboleth:SAML:1.0:cm:nonbrowser">
        <xs:annotation>
          <xs:documentation>
            The subject of the assertion is the party that presented a SAML artifact, which the relying party used to obtain the assertion from
            the party that created the artifact.
          </xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      -->
    </xs:restriction>
  </xs:simpleType>
  <xs:complexType name="HolderOfKeyKeyInfo">
    <xs:sequence>
      <xs:element name="holderOfKeyKeyInfoType" type="aaa:HolderOfKeyKeyInfoType" maxOccurs="unbounded">
        <xs:annotation>
          <xs:appinfo>Would implement with vector of flags with X509Certificate defaulted on.</xs:appinfo>
        </xs:annotation>
        <!-- constraint: When multiple holderOfKeyKeyInfoType elements are defined, only consistent elements can be defined.
        -->
        <!-- constraint:
             1) if ((extract identity is (certificateFromPeerSsl OR bstFromVerifyOperation)) OR
                    ((extract identity is (x509CertificateFromSecurityHeader OR x509CertificateFromWorkflow)) AND
                     (authenticateIdentity is (checkX509CertificateChainOfTrust))
                    )
                   )
                then HolderOfKeyKeyInfoType can be (X509Certificate OR X509SubjectName OR X509SKI OR RSAKeyValue OR DSAKeyValue OR KeyName)
                Note: Would generate a WARNING message if KeyName selected because it is potentially ambiguous. 
             2) if (extract identity is (usernameFromHttpbasicAuthentication OR usernameFromSecurityHeader OR
                                         usernamePasswordFromWorkflow OR derivedUsernameFromSecurityHeader
                                        )
                   )
                then HolderOfKeyKeyInfoType can be (KeyName)
             3) Both RSAKeyValue and DSAKeyValue can NOT both be enable at the same HolderOfKeyKeyInfo element.
             4) If (extract identity is certificateAttributeFromSecurityHeader with sub-extraction is subject name then 
                holderOfKeyKeyInfoType can only be X509SubjectName or KeyName
             5) If (extract identity is certificateAttributeFromSecurityHeader with sub-extraction is SKI then 
                holderOfKeyKeyInfoType can only be X509SKI
             6) If (extract identity is certificateAttributeFromSecurityHeader with sub-extraction is ThumbprintSha1 then 
                holderOfKeyKeyInfoType can only be X509ThumbprintSha1
             7) if (extract identity is (x509CertificateFromSecurityHeader OR x509CertificateFromWorkflow))
                then ERROR/NOT PRESENTED because these mechanism do not show actual proof-of-key, i.e., actual private 
                     key/symmetric key was not used by the client.
             8) Multiple elements with (X509Certificate OR X509SubjectName OR X509SKI or X509Thunmbprint OR X509RSAKeyValue OR
                                        X509DSAKeyValue OR X509IssuerSerialNumber OR KeyName
                                       )
             9) Multiple elements with (KeyName OR KeyValue)
             10) (holderOfKeyKeyInfoType == BinarySecret) is independent of any extract identity mechanism
        -->
      </xs:element>
      <xs:element name="importedClientCredential" type="xs:string" default="internal:importedClientCredential" minOccurs="0">
        <xs:annotation>
          <xs:documentation>
            This value uniquely identify this user supplied data instance.
            
            This value is used to identify to the developer what information needs to be resolved.
            This value is also used as the name string in the name/value pair on the extension function optional parameter.
          </xs:documentation>
        </xs:annotation>
        <!-- constraint: 
             1) NOT PRESENT if (holderOfKeyKeyInfoType == BinarySecret)
             2) MUST be POPULATED if (holderOfKeyKeyInfoType == (X509Certifiate OR X509SubjectName OR X509SKI OR
                                                                 X509ThumbprintSha2 OR X509RSAKeyValue OR X509DSAKeyValue OR
                                                                 X509IssuerSerialNumber OR KeyName OR KeyValue
                                                                )
                                     )
                Note: boolean expression equivalent to (holderOfKeyKeyInfoType != BinarySecret)
        -->
        <!-- contraint: Service Designer policy editor must ensure that each imported client credential has a unique value in each policy. 
                        Since this is restricted for a AAA to the client credential, there will only be a single importedClientCredential possible.
                        Therefore, Service Designer action builder has only a single possible internal variable to pass in.
                        This check should not be needed in AAA policy editor.
        -->
      </xs:element>
    </xs:sequence>
    <xs:attribute name="type" use="required" fixed="string">
      <xs:annotation>
        <xs:appinfo>Not to be displayed. Must be populated by policy editor.</xs:appinfo>
      </xs:annotation>
      <xs:simpleType>
        <xs:restriction base="xs:string"/>
      </xs:simpleType>
    </xs:attribute>
  </xs:complexType>
  <xs:simpleType name="NameIdFormatType">
    <xs:restriction base="xs:anyURI">
      <xs:annotation>
        <xs:documentation>
          All of the following enumerations valid for SAML 2.0, including the 1.1 URIs in various standard documents.
          In particular, some places appear to want the 2.0 and some want the 1.1 and 1.0 unspecified URI. 
          The 1.1 is the default format value.
          As far as I can see, the application has to know what is required for their usage to correctly interwork. :(
        </xs:documentation>
      </xs:annotation>
      <xs:enumeration value="urn:oasis:names:tc:SAML:1.1:nameid-format:unspecified">
        <xs:annotation>
          <xs:documentation>The interpretation of the content of the element is left to individual implementations.</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="urn:oasis:names:tc:SAML:1.0:nameid-format:unspecified">
        <xs:annotation>
          <xs:documentation>The interpretation of the content of the element is left to individual implementations.</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="urn:oasis:names:tc:SAML:2.0:nameid-format:unspecified">
        <xs:annotation>
          <xs:documentation>The interpretation of the content of the element is left to individual implementations.</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="urn:oasis:names:tc:SAML:1.1:nameid-format:entity">
        <xs:annotation>
          <xs:documentation>
            Indicates that the content of the element is the identifier of an entity that provides SAML-based services (such as a SAML authority, 
            requester, or responder) or is a participant in SAML profiles (such as a service provider supporting the browser SSO profile). Such 
            an identifier can be used in the Issuer element to identify the issuer of a SAML request, response, or assertion, or within the NameID 
            element to make assertions about system entities that can issue SAML requests, responses, and assertions. It can also be used in 
            other elements and attributes whose purpose is to identify a system entity in various protocol exchanges.
            
            The syntax of such an identifier is a URI of not more than 1024 characters in length. It is RECOMMENDED that a system entity use a 
            URL containing its own domain name to identify itself.
          </xs:documentation>
          <!-- constraint: The NameQualifier, SPNameQualifier, and SPProvidedID attributes MUST be omitted. -->
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="urn:oasis:names:tc:SAML:2.0:nameid-format:entity">
        <xs:annotation>
          <xs:documentation>
            Indicates that the content of the element is the identifier of an entity that provides SAML-based services (such as a SAML authority, 
            requester, or responder) or is a participant in SAML profiles (such as a service provider supporting the browser SSO profile). Such 
            an identifier can be used in the Issuer element to identify the issuer of a SAML request, response, or assertion, or within the NameID 
            element to make assertions about system entities that can issue SAML requests, responses, and assertions. It can also be used in 
            other elements and attributes whose purpose is to identify a system entity in various protocol exchanges.
            
            The syntax of such an identifier is a URI of not more than 1024 characters in length. It is RECOMMENDED that a system entity use a 
            URL containing its own domain name to identify itself.
          </xs:documentation>
          <!-- constraint: The NameQualifier, SPNameQualifier, and SPProvidedID attributes MUST be omitted. -->
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="urn:oasis:names:tc:SAML:1.1:nameid-format:emailAddress">
        <xs:annotation>
          <xs:documentation>
            Indicates that the content of the element is in the form of an email address, specifically "addr-spec" as defined in IETF RFC 2822 
            Section 3.4.1. An addr-spec has the form local-part@domain. Note that an addr-spec has no phrase (such as a common name) before 
            it, has no comment (text surrounded in parentheses) after it, and is not surrounded by "@lt;" and "@gt;".
          </xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="urn:oasis:names:tc:SAML:1.1:nameid-format:X509SubjectName">
        <xs:annotation>
          <xs:documentation>
            Indicates that the content of the element is in the form specified for the contents of the ds:X509SubjectName element in the XML 
            Signature Recommendation [XMLSig]. Implementors should note that the XML Signature specification specifies encoding rules for 
            X.509 subject names that differ from the rules given in IETF RFC 2253
          </xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="urn:oasis:names:tc:SAML:1.1:nameid-format:WindowsDomainQualifiedName">
        <xs:annotation>
          <xs:documentation>
            Indicates that the content of the element is a Windows domain qualified name. A Windows domain qualified user name is a string 
            of the form "DomainName\UserName". The domain name and "\" separator MAY be omitted.
          </xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="urn:oasis:names:tc:SAML:2.0:nameid-format:persistent">
        <xs:annotation>
          <xs:documentation>
            Indicates that the content of the element is a persistent opaque identifier for a principle that is specific to an identity provider and a service 
            provider or affiliation of service providers. Persistent name identifiers generated by identity providers MUST be constructed using 
            pseudo-random values that have no discernible correspondence with the subject's actual identifier (for example, username). The intent is to
            create a non-public, pair-wise pseudonym to prevent the discovery of the subject's identity or activities. Persistent name identifier values 
            MUST NOT exceed a length of 256 characters.
            
            The element's NameQualifier attribute, if present, MUST contain the unique identifier of the identity provider that generated the identifier. It MAY
            be omitted if the value can be derived from the context of the message containing the element, such as the issuer of a protocol message or an
            assertion containing the identifier in its subject. Note that a different system entity might later issue its own protocol message or assertion
            containing the identifier; the NameQualifier attribute does not change in this case, but MUST continue to identify the entity that originally created
            the identifier (and MUST NOT be omitted in such a case).
            
            The element's SPNameQualifier attribute, if present, MUST contain the unique identifier of the service provider or affiliation of providers for whom
            the identifier was generated. It MAY be omitted if the element is contained in a message intended only for consumption directly by the service
            provider, and the value would be the unique identifier of that service provider.
            
            The element's SPProvidedID attribute MUST contain the alternative identifier of the principal most recently set by the service provider or affiliation, 
            if any. If no such identifier has been established, then the attribute MUST be omitted.
            
            Persistent identifiers are intended as a privacy protection mechanism; as such they MUST NOT be shared in clear text with providers other than 
            the providers that have established the shared identifier. Furthermore, they MUST NOT appear in log files or similar locations without appropriate 
            controls and protections. Deployments without such requirements are free to use other kinds of identifiers in their SAML exchanges, but MUST 
            NOT overload this format with persistent but non-opaque values Note also that while persistent identifiers are typically used to reflect an account 
            linking relationship between a pair of providers, a service provider is not obligated to recognize or make use of the long term nature of the persistent 
            identifier or establish such a link. Such a "one-sided" relationship is not discernibly different and does not affect the behavior of the 
            identity provider.
            For any processing rules specific to persistent identifiers in the protocols defined in this specification.
            
            Finally, note that the NameQualifier and SPNameQualifier attributes indicate directionality of creation, but not of use. If a persistent identifier is created 
            by a particular identity provider, the NameQualifier attribute value is permanently established at that time. If a service provider that receives such an 
            identifier takes on the role of an identity provider and issues its own assertion containing that identifier, the NameQualifier attribute value does not 
            change (and would of course not be omitted). It might alternatively choose to create its own persistent identifier to represent the principal and link the 
            two values. This is a deployment decision.
          </xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="urn:oasis:names:tc:SAML:2.0:nameid-format:transient">
        <xs:annotation>
          <xs:documentation>
            Indicates that the content of the element is an identifier with transient semantics and SHOULD be treated as an opaque and temporary value by 
            the relying party. Transient identifier values MUST be generated in accordance with the rules for SAML identifiers, and MUST NOT exceed a length
            of 256 characters.
            
            The NameQualifier and SPNameQualifier attributes MAY be used to signify that the identifier represents a transient and temporary pair-wise identifier. 
          </xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="urn:oasis:names:tc:SAML:2.0:nameid-format:encrypted">
        <xs:annotation>
          <xs:documentation>
            Indicates in an Authentication Request protocol request that a specific entity should be encrypted.
          </xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="urn:oasis:names:tc:SAML:2.0:nameid-format:kerberos">
        <xs:annotation>
          <xs:documentation>
            Indicates that the content of the element is in the form of a Kerberos principal name using the format name[/instance]@REALM. 
            The syntax, format and characters allowed for the name, instance, and realm are described in IETF RFC 1510.
          </xs:documentation>
        </xs:annotation>
      </xs:enumeration>
    </xs:restriction>
  </xs:simpleType>
  <xs:simpleType name="HolderOfKeyKeyInfoType">
    <xs:restriction base="xs:string">
      <xs:enumeration value="X509Certificate">
        <xs:annotation>
          <xs:documentation>
            The full client X509 Certificate used to authenticate the client to the Security Token Service (STS) should be package within the 
            incoming SAML assertion that is using a holder-of-key confirmation method.
            The certificate should normally be in based-64 DER format.
          </xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="X509SubjectName">
        <xs:annotation>
          <xs:documentation>
            The subject name of the client certificate used to authenticate the client to the Security Token Service (STS) should 
            be package within the incoming SAML assertion that is using a holder-of-key confirmation method.
          </xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="X509SKI">
        <xs:annotation>
          <xs:documentation>
            The subject key identifier (SKI) of the client certificate used to authenticate the client to the Security Token Service (STS) should 
            be package within the incoming SAML assertion that is using a holder-of-key confirmation method. It is an error if the client certificate
            does not contain the optional SKI attribute.
          </xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="X509ThumbprintSha1">
        <xs:annotation>
          <xs:documentation>
            The SHA1 thumbprint of the client certificate used to authenticate the client to the Security Token Service (STS) should 
            be package within the incoming SAML assertion that is using a holder-of-key confirmation method.
          </xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="RSAKeyValue">
        <xs:annotation>
          <xs:documentation>
            For X509 RSA certificate, the public key of the client certificate used to authenticate the client to the Security Token Service (STS) should 
            be package within the incoming SAML assertion that is using a holder-of-key confirmation method.
            Only the modulus and exponent of the public key is packaged.
          </xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="DSAKeyValue">
        <xs:annotation>
          <xs:documentation>
            For X509 DSA certificate, the public key of the client certificate used to authenticate the client to the Security Token Service (STS) should 
            be package within the incoming SAML assertion that is using a holder-of-key confirmation method.
          </xs:documentation>
        </xs:annotation>
        <!-- deferred until some future release when it is actually needed by someone -->
      </xs:enumeration>
      <xs:enumeration value="BinarySecret">
        <xs:annotation>
          <xs:documentation>A raw symmetric key value.</xs:documentation>
          <xs:appinfo>
            We will automatically always generate a new random symmetric key for each SAML assertion being created.
            The symmetric key will be 32 bytes long, i.e., big enough for use with largest symmetric cipher, AES-256.
            Can be truncerated to work with any other encryption or signature symmetric algorithm.
          </xs:appinfo>
        </xs:annotation>
        <!-- constraint: NOT ALLOWED if (saml version == v1.0) -->
      </xs:enumeration>
      <xs:enumeration value="KeyName">
        <xs:annotation>
          <xs:documentation>
            The some information associated with the client certificate used to authenticate the client to the Security Token Service (STS) should 
            be package within the incoming SAML assertion that is using a holder-of-key confirmation method.
            
            This mechanism not recommended because the associated need for coordinated namespaces and certificate authorities. 
            Additionally, there is potential ambiguities about what type of token identifier is being package under KeyName.
            
            For example, some application package the X509 subject name, while others package the username ithin the KeyInfo KeyName element.
            Note: the X509 subject name, could be unambiguously packaged with a KeyInfo X509Data X509SubjectName element.
            There is no way to determine at AAA policy editor or action builder time that inconsistent token types have been specified, i.e., strictly
            runtime checking only.
          </xs:documentation>
          <xs:appinfo>
            For X509 token type, we will always extract the certificate subject name for the comparison.
          </xs:appinfo>
        </xs:annotation>
      </xs:enumeration>
      <!-- deferred
      <xs:enumeration value="KeyValue">
        <xs:annotation>
          <xs:documentation>
            If X509 certificate token type is being supported then RSAKeyValue or DSAKeyValue enumeration values must be utilized. This eliminated any
            ambiguity about what type of key values is being passed.
            For symmetric key/username password, the actual key/password is packaged within the KeyValue. However, this entire KeyInfo element is encrypted 
            via either a RSA Key Transport or a DH Key Agreement algorithm. [Support for symmetric keys will be deferred to some future release.]
          </xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="X509IssuerSerialNumber">
        <xs:annotation>
          <xs:documentation>
            The issuer and serial number of the client certificate used to authenticate the client to the Security Token Service (STS) should 
            be package within the incoming SAML assertion that is using a holder-of-key confirmation method.
            Deferring because of issues about how we will encode the two separate peices of information as a single contiguous character string.
          </xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      -->
    </xs:restriction>
  </xs:simpleType>
  <xs:simpleType name="AuthenticationMethodType">
    <xs:restriction base="xs:anyURI">
      <xs:enumeration value="urn:oasis:names:tc:SAML:1.0:am:password">
        <xs:annotation>
          <xs:documentation>
            Priniciple is authenticated through use of a password to an authentication authority using password over an unprotected HTTP session.
          </xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="urn:oasis:names:tc:SAML:2.0:ac:classes:Password">
        <xs:annotation>
          <xs:documentation>
            Priniciple is authenticated through use of a password to an authentication authority using password over an unprotected HTTP session.
          </xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="urn:oasis:names:tc:SAML:1.0:am:unspecified">
        <xs:annotation>
          <xs:documentation>Authentication was performed by unspecified means.</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="urn:oasis:names:tc:SAML:1.1:am:unspecified">
        <xs:annotation>
          <xs:documentation>Authentication was performed by unspecified means.</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="urn:oasis:names:tc:SAML:2.0:ac:classes:unspecified">
        <xs:annotation>
          <xs:documentation>Authentication was performed by unspecified means.</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="urn:oasis:names:tc:SAML:1.0:am:X509-PKI">
        <xs:annotation>
          <xs:documentation>
            Priniciple is authenticated by means of a digital signature where the key was validated as part of the X.509 Public Key Infrastructure.
          </xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="urn:oasis:names:tc:SAML:2.0:ac:classes:X509">
        <xs:annotation>
          <xs:documentation>
            Priniciple is authenticated by means of a digital signature where the key was validated as part of the X.509 Public Key Infrastructure.
          </xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="urn:ietf:rfc:2246">
        <xs:annotation>
          <xs:documentation>Principle authenticate using successful SSL/TLS transport layer authentication.</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="urn:oasis:names:tc:SAML:2.0:ac:classes:TLSClient">
        <xs:annotation>
          <xs:documentation>
            Priniciple is authenticated by client certificate secured with SSL/TLS transport layer.
          </xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="urn:oasis:names:tc:SAML:2.0:ac:classes:PasswordProtectedTransport">
        <xs:annotation>
          <xs:documentation>
            Priniciple is authenticated through use of a password to an authentication authority using password over a protected HTTP session.
          </xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="urn:oasis:names:tc:SAML:2.0:ac:classes:InternetProtocol">
        <xs:annotation>
          <xs:documentation>Principle is authenticated though the use of a provided IP address.</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="urn:oasis:names:tc:SAML:2.0:ac:classes:SoftwarePKI">
        <xs:annotation>
          <xs:documentation>
            Priniciple uses an X.509 certificatestored in software to authenticate to the authentication authority.
          </xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="urn:oasis:names:tc:SAML:1.0:am:SPKI">
        <xs:annotation>
          <xs:documentation>
            Priniciple is authenticated by means of a digital signature where the key was validated as part of the SPKI Infrastructure.
          </xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="urn:oasis:names:tc:SAML:1.0:am:HardwareToken">
        <xs:annotation>
          <xs:documentation>Priniciple is authenticated by means of a hardware based token mechanism.</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="urn:oasis:names:tc:SAML:1.0:am:PGP">
        <xs:annotation>
          <xs:documentation>
            Prinicipal is authenticated by means of a digital signature where the key was validated as part of the PGP Public Key Infrastructure.
          </xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="urn:ietf:rfc:2945">
        <xs:annotation>
          <xs:documentation>Principal authentication using Secure Remote Password (SRP) protocol.</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="urn:oasis:names:tc:SAML:1.0:am:XKMS">
        <xs:annotation>
          <xs:documentation>Authentication was performed by using XML Key Management Specification.</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="urn:oasis:names:tc:SAML:1.1:am:XKMS">
        <xs:annotation>
          <xs:documentation>Authentication was performed by using XML Key Management Specification.</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="urn:oasis:names:tc:SAML:2.0:ac:classes:InternetProtocolPassword">
        <xs:annotation>
          <xs:documentation>
            Principle is authenticated though the use of a provided IP address in addition to a username/password.
          </xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="urn:oasis:names:tc:SAML:2.0:ac:classes:Kerberos">
        <xs:annotation>
          <xs:documentation>
            Principle is authenticated though the use of a password to a local authentication authority to acquire a Kerberos ticket.
            The Kerberos ticket is then used for subsequent network authentication.
          </xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="urn:oasis:names:tc:SAML:2.0:ac:classes:XMLDSig">
        <xs:annotation>
          <xs:documentation>
            Priniciple is authenticated by means of a digital signature where the key was validated using XML Digital Signature specification.
          </xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="urn:oasis:names:tc:SAML:2.0:ac:classes:PGP">
        <xs:annotation>
          <xs:documentation>
            Priniciple is authenticated by means of a digital signature where the key was validated as part of the PGP Public Key Infrastructure.
          </xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="urn:oasis:names:tc:SAML:2.0:ac:classes:SPKI">
        <xs:annotation>
          <xs:documentation>
            Priniciple is authenticated by means of a digital signature where the key was validated as part of the SPKI Infrastructure.
          </xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="urn:oasis:names:tc:SAML:2.0:ac:classes:SecureRemotePassword">
        <xs:annotation>
          <xs:documentation>
            Priniciple is authenticated via Secure Remote Password as defined in RFC 2945.
          </xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="urn:oasis:names:tc:SAML:2.0:ac:classes:TimeSyncToken">
        <xs:annotation>
          <xs:documentation>
            Priniciple is authenticated through a time synchronization token.
          </xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <!-- deferred
      <xs:enumeration value="urn:oasis:names:tc:SAML:2.0:ac:classes:MobileOneFactorUnregistered">
        <xs:annotation>
          <xs:documentation>
            Reflects that no mobile customer registration procedure and that an authentication of the mobile device without requiring any
            explicit end-user interaction.Authenticates only the device and never the user. Is useful when services other than the mobile operator 
            wants to add a secure device authentication to their process.
          </xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="urn:oasis:names:tc:SAML:2.0:ac:classes:MobileTwoFactorUnregistered">
        <xs:annotation>
          <xs:documentation>
            Reflects that no mobile customer registration procedure and a two-factor based authentication, i.e., secure device and user PIN..
            Is useful when services other than the mobile operator wants to link their customer ID to a moble supplied two-factor authentication service.
          </xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="urn:oasis:names:tc:SAML:2.0:ac:classes:MobileOneFactorContract">
        <xs:annotation>
          <xs:documentation>
            Reflects mobile customer contract registration procedure and a single factor authentication, e.g., digital signing device with tamper resistent 
            memory for key storage, but not required PIN or biometrics.
          </xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="urn:oasis:names:tc:SAML:2.0:ac:classes:MobileTwoFactorContract">
        <xs:annotation>
          <xs:documentation>
            Reflects mobile customer contract registration procedure and a two-factor authentication, e.g., digital signing device with tamper resistent 
            memory for key storage and a PIN or biometrics.
          </xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="urn:oasis:names:tc:SAML:2.0:ac:classes:PreviousSession">
        <xs:annotation>
          <xs:documentation>
            Priniciple is authenticated at some point in the past using an authentication context supported by that authentication authority.
            Therefore, a significant time may have elapsed from the current request. Because of this large potential time, the mechanism used in
            the earlier authentication should not be used as part of this decision process for accessing the resource.
          </xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="urn:oasis:names:tc:SAML:2.0:ac:classes:Smartcard">
        <xs:annotation>
          <xs:documentation>
            Priniciple is authenticated by means of an authentication authority using a smart card.
          </xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="urn:oasis:names:tc:SAML:2.0:ac:classes:SmartcardPKI">
        <xs:annotation>
          <xs:documentation>
            Priniciple is authenticated by means of an authentication authority with two-factor authenticatin mechanism using a smart card with
            an enclosed private key or a PIN.
          </xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="urn:oasis:names:tc:SAML:2.0:ac:classes:Telephony">
        <xs:annotation>
          <xs:documentation>
            Priniciple is authenticated via the provisioning of a fixed line telehone number using telephony protocol such as ADSL.
          </xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="urn:oasis:names:tc:SAML:2.0:ac:classes:NomadTelephony">
        <xs:annotation>
          <xs:documentation>
            Priniciple is roaming and authenticated via the line number, a user suffix and a password element.
          </xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="urn:oasis:names:tc:SAML:2.0:ac:classes:PersonalTelephony">
        <xs:annotation>
          <xs:documentation>
            Priniciple is authenticated via the provisioning of a fixed line telehone number via fixed line telephone number and a user suffix 
            transmitted over a telephony protocol such as ADSL.
          </xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="urn:oasis:names:tc:SAML:2.0:ac:classes:AuthenticatedTelephony">
        <xs:annotation>
          <xs:documentation>
            Priniciple is authenticated via the line number, user suffix and a password element..
          </xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      -->
    </xs:restriction>
  </xs:simpleType>
  <xs:simpleType name="NameFormatType">
    <xs:restriction base="xs:anyURI">
      <xs:enumeration value="urn:oasis:names:tc:SAML:2.0:attrname-format:uri"/>
      <xs:enumeration value="urn:oasis:names:tc:SAML:2.0:attrname-format:unspecified"/>
      <xs:enumeration value="urn:oasis:names:tc:SAML:2.0:attrname-format:basic"/>
      <!-- may have the following screwed up because my french is not very good :)
      <xs:enumeration value="urn:interops:1.0:attr-policy:matchAny"/>
      <xs:enumeration value="urn:interops:1.0:attr-policy:onlyOne"/>
      -->
    </xs:restriction>
  </xs:simpleType>
  <xs:simpleType name="DecisionType">
    <xs:restriction base="xs:NMTOKEN">
      <xs:enumeration value="Permit"/>
      <xs:enumeration value="Deny"/>
      <xs:enumeration value="Indeterminate"/>
    </xs:restriction>
  </xs:simpleType>
  <xs:complexType name="SamlAppExtPt">
    <xs:annotation>
      <xs:documentation>
        Allows an application to specify a string either:
        1) a hardcored string that is know at policy definition time, or
        2) a BEPL variable associated an input parameter associated with the AAA action.
      </xs:documentation>
    </xs:annotation>
    <xs:choice>
      <xs:element name="staticValue">
        <xs:simpleType>
          <xs:restriction base="xs:string">
            <xs:minLength value="1"/>
          </xs:restriction>
        </xs:simpleType>
      </xs:element>
      <xs:element name="inputFromWorkflow" type="xs:string">
        <xs:annotation>
          <xs:documentation>
            This value uniquely identify this user supplied data instance.
            
            This value is used to identify to the developer what information needs to be resolved.
            This value is also used as the name string in the name/value pair on the extension function optional parameter.
          </xs:documentation>
        </xs:annotation>
      </xs:element>
    </xs:choice>
    <xs:attribute name="type" use="required" fixed="anyType">
      <xs:annotation>
        <xs:appinfo>
          Not to be displayed. Must be populated by policy editor.
          This should really be of type string but that would cause retrofit issues.
        </xs:appinfo>
      </xs:annotation>
      <xs:simpleType>
        <xs:restriction base="xs:string"/>
      </xs:simpleType>
    </xs:attribute>
  </xs:complexType>
  <xs:complexType name="OriginalSamlAppExtPt">
    <xs:annotation>
      <xs:documentation>
        Allows an application to specify a well-formed XML fragment from either:
        1) a hardcored XML fragment that is know at policy definition time, or
        2) a BEPL variable associated an input parameter associated with the AAA action.
      </xs:documentation>
    </xs:annotation>
    <xs:choice>
      <xs:element name="staticValue" type="aaa:Anything"/>
      <xs:element name="inputFromWorkflow" type="xs:string">
        <xs:annotation>
          <xs:documentation>
            This user supplied value uniquely identify this user supplied data instance.
            
            This value is used to identify to the developer what information needs to be resolved.
            This value is also used as the name string in the name/value pair on the extension function optional parameter.
          </xs:documentation>
        </xs:annotation>
      </xs:element>
    </xs:choice>
    <xs:attribute name="type" use="required" fixed="anyType">
      <xs:annotation>
        <xs:appinfo>Not to be displayed. Simplify operational code. Must be populated by policy editor.</xs:appinfo>
      </xs:annotation>
      <xs:simpleType>
        <xs:restriction base="xs:string"/>
      </xs:simpleType>
    </xs:attribute>
  </xs:complexType>
  <xs:complexType name="Anything">
    <xs:sequence>
      <xs:any processContents="skip"/>
    </xs:sequence>
    <xs:anyAttribute namespace="##any" processContents="skip"/>
  </xs:complexType>
  <xs:complexType name="SamlString">
    <xs:annotation>
      <xs:documentation>
        Allows an application to specify a string either:
        1) a hardcored string that is know at policy definition time, or
        2) a BEPL variable associated an input parameter associated with the AAA action.
      </xs:documentation>
    </xs:annotation>
    <xs:choice>
      <xs:element name="staticValue">
        <xs:simpleType>
          <xs:restriction base="xs:string">
            <xs:minLength value="1"/>
          </xs:restriction>
        </xs:simpleType>
      </xs:element>
      <xs:element name="inputFromWorkflow" type="xs:string">
        <xs:annotation>
          <xs:documentation>
            This value uniquely identify this user supplied data instance.
            
            This value is used to identify to the developer what information needs to be resolved.
            This value is also used as the name string in the name/value pair on the extension function optional parameter.
          </xs:documentation>
        </xs:annotation>
      </xs:element>
    </xs:choice>
    <xs:attribute name="type" use="required" fixed="string">
      <xs:annotation>
        <xs:appinfo>Not to be displayed. Must be populated by policy editor.</xs:appinfo>
      </xs:annotation>
      <xs:simpleType>
        <xs:restriction base="xs:string"/>
      </xs:simpleType>
    </xs:attribute>
  </xs:complexType>
  <xs:complexType name="SamlNameIdFormat">
    <xs:annotation>
      <xs:documentation>
        Allows an application to specify a string either:
        1) a hardcored string that is know at policy definition time, or
        2) a BEPL variable associated an input parameter associated with the AAA action.
      </xs:documentation>
    </xs:annotation>
    <xs:choice>
      <xs:element name="staticValue" type="aaa:NameIdFormatType"/>
      <xs:element name="inputFromWorkflow" type="xs:string">
        <xs:annotation>
          <xs:documentation>
            This value uniquely identify this user supplied data instance.
            
            This value is used to identify to the developer what information needs to be resolved.
            This value is also used as the name string in the name/value pair on the extension function optional parameter.
          </xs:documentation>
        </xs:annotation>
      </xs:element>
    </xs:choice>
    <xs:attribute name="type" use="required" fixed="string">
      <xs:annotation>
        <xs:appinfo>Not to be displayed. Must be populated by policy editor.</xs:appinfo>
      </xs:annotation>
      <xs:simpleType>
        <xs:restriction base="xs:string"/>
      </xs:simpleType>
    </xs:attribute>
  </xs:complexType>
  <xs:complexType name="SamlUri">
    <xs:annotation>
      <xs:documentation>
        Allows an application to specify  a URL from either:
        1) a hardcored string that is know at policy definition time, or
        2) a BEPL variable associated an input parameter associated with the AAA action.
      </xs:documentation>
    </xs:annotation>
    <xs:choice>
      <xs:element name="staticValue">
        <xs:simpleType>
          <xs:restriction base="xs:anyURI">
            <xs:minLength value="1"/>
          </xs:restriction>
        </xs:simpleType>
      </xs:element>
      <xs:element name="inputFromWorkflow" type="xs:string">
        <xs:annotation>
          <xs:documentation>
            This value uniquely identify this user supplied data instance.
            
            This value is used to identify to the developer what information needs to be resolved.
            This value is also used as the name string in the name/value pair on the extension function optional parameter.
          </xs:documentation>
        </xs:annotation>
      </xs:element>
    </xs:choice>
    <xs:attribute name="type" use="required" fixed="anyURI">
      <xs:annotation>
        <xs:appinfo>Not to be displayed. Must be populated by policy editor.</xs:appinfo>
      </xs:annotation>
      <xs:simpleType>
        <xs:restriction base="xs:string"/>
      </xs:simpleType>
    </xs:attribute>
  </xs:complexType>
  <xs:complexType name="ExpirationLifetimeType">
    <xs:annotation>
      <xs:documentation>
        Allows an application to specify  the expiration time (in seconds) from either:
        1) a hardcored unsigned integer that is know at policy definition time, or
        2) a BEPL variable associated an input parameter associated with the AAA action.
      </xs:documentation>
    </xs:annotation>
    <xs:choice>
      <xs:element name="staticValue" type="xs:unsignedInt" default="300"/>
      <xs:element name="inputFromWorkflow" type="xs:string">
        <xs:annotation>
          <xs:documentation>
            This value uniquely identify this user supplied data instance.
            
            This value is used to identify to the developer what information needs to be resolved.
            This value is also used as the name string in the name/value pair on the extension function optional parameter.
          </xs:documentation>
        </xs:annotation>
      </xs:element>
    </xs:choice>
    <xs:attribute name="type" use="required" fixed="unsignedInt">
      <xs:annotation>
        <xs:appinfo>Not to be displayed. Must be populated by policy editor.</xs:appinfo>
      </xs:annotation>
      <xs:simpleType>
        <xs:restriction base="xs:string"/>
      </xs:simpleType>
    </xs:attribute>
  </xs:complexType>
  <xs:complexType name="SamlAttributeNamespaceUri">
    <xs:annotation>
      <xs:documentation>
        Allows an application to specify a URL from either:
        1) a hardcored string that is know at policy defination time, or
        2) a BEPL variable associated an input parameter associated with the AAA action.
      </xs:documentation>
    </xs:annotation>
    <xs:choice>
      <xs:element name="staticValue">
        <xs:simpleType>
          <xs:restriction base="xs:anyURI">
            <xs:minLength value="1"/>
            <xs:pattern value="[^&#34;']*">
              <xs:annotation>
                <xs:appinfo>
                  This pattern expression is trying to protect the operational deploy code from trying to produce a malform
                  AttributeNamespace attribute value. It is normally a simple URI like: http://a/b/c/d and not something like
                  
  xmlns: sam="http://t/w/y/z".
                </xs:appinfo>
              </xs:annotation>
            </xs:pattern>
          </xs:restriction>
        </xs:simpleType>
      </xs:element>
      <xs:element name="inputFromWorkflow" type="xs:string">
        <xs:annotation>
          <xs:documentation>
            This value uniquely identify this user supplied data instance.
            
            This value is used to identify to the developer what information needs to be resolved.
            This value is also used as the name string in the name/value pair on the extension function optional parameter.
          </xs:documentation>
        </xs:annotation>
      </xs:element>
    </xs:choice>
    <xs:attribute name="type" use="required" fixed="anyURI">
      <xs:annotation>
        <xs:appinfo>Not to be displayed. Must be populated by policy editor.</xs:appinfo>
      </xs:annotation>
      <xs:simpleType>
        <xs:restriction base="xs:string"/>
      </xs:simpleType>
    </xs:attribute>
  </xs:complexType>
  <xs:complexType name="SamlNCName">
    <xs:annotation>
      <xs:documentation>
        Allows an application to specify a NCName from either:
        1) a hardcored NCName that is know at policy definition time, or
        2) a BEPL variable associated an input parameter associated with the Ws-Security action.
      </xs:documentation>
    </xs:annotation>
    <xs:choice>
      <xs:element name="staticValue">
        <xs:simpleType>
          <xs:restriction base="xs:NCName">
            <xs:minLength value="1"/>
          </xs:restriction>
        </xs:simpleType>
      </xs:element>
      <xs:element name="inputFromWorkflow" type="xs:string">
        <xs:annotation>
          <xs:documentation>
            This value uniquely identify this user supplied data instance.
            
            This value is used to identify to the developer what information needs to be resolved.
            This value is also used as the name string in the name/value pair on the extension function optional parameter.
          </xs:documentation>
        </xs:annotation>
      </xs:element>
    </xs:choice>
    <xs:attribute name="type" use="required" fixed="NCName">
      <xs:annotation>
        <xs:appinfo>Not to be displayed. Must be populated by policy editor.</xs:appinfo>
      </xs:annotation>
      <xs:simpleType>
        <xs:restriction base="xs:string"/>
      </xs:simpleType>
    </xs:attribute>
  </xs:complexType>
  <xs:simpleType name="AcceptableSamlKeyInfo">
    <xs:annotation>
      <xs:documentation>What form of KeyInfo should be package with either the signature generation or encryption.</xs:documentation>
    </xs:annotation>
    <xs:restriction base="xs:string">
      <xs:enumeration value="Certificate">
        <xs:annotation>
          <xs:documentation>X509Data: associated certificate</xs:documentation>
        </xs:annotation>
        <!-- constraint: only allowed is tokenType is x509 -->
      </xs:enumeration>
      <xs:enumeration value="SubjectName">
        <xs:annotation>
          <xs:documentation>X509Data: subject distiguished name from associated certificate</xs:documentation>
        </xs:annotation>
        <!-- constraint: only allowed is tokenType is x509 -->
      </xs:enumeration>
      <xs:enumeration value="SKI">
        <xs:annotation>
          <xs:documentation>
            X509Data: SubjectKeyIdentifier (SKI) from associated certificate.
            The subjectKeyIdentifier is an optional element with a certificate. 
            We can generate all the well-defined forms of it but we have no way of know what form the recepient will be expecting.
            This can cause interoperate failures.
            Therefore, WSSEC will automatically use optional element in specified certificate.
            If specified certificate does not contain optional SKI, WSSEC processing will fail.
          </xs:documentation>
        </xs:annotation>
        <!-- constraint: only allowed is tokenType is x509 -->
      </xs:enumeration>
      <xs:enumeration value="ThumbprintSha1">
        <xs:annotation>
          <xs:documentation>
            X509Data: ThumbprintSHA1 from associated certificate.
            The ThumbrintSHA1 is derived from the certificate. 
            It is also referred to s the SHA-1 Fingerprint in most browsers and X.509 PKI systems and our local keystore query mechanism.
          </xs:documentation>
        </xs:annotation>
        <!-- constraint: only allowed is tokenType is x509 -->
      </xs:enumeration>
      <xs:enumeration value="KeyName">
        <xs:annotation>
          <xs:documentation>
            A character string that the signer uses to uniquely identify the key to the recipent.
          </xs:documentation>
          <xs:appinfo>
            If tokenType is x509 then the subject name of the certificate is assumed.
            If tokenType is symmetric then keyname is assumed. Future.
          </xs:appinfo>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="RsaKeyValue">
        <xs:annotation>
          <xs:documentation>
            RSA public key value from X.509 certificate used to sign SAML Assertion.
            Encoded as separate required Modulus and Exponent elements.
          </xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <!-- Currently do not support these forms
      <xs:enumeration value="IssuerSerial">
        <xs:annotation>
          <xs:documentation>X509Data: issuer distinguished name/serial number from associated certificate</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="DsaKeyValue">
        <xs:annotation>
          <xs:documentation>
            DSA public key value from X.509 certificate used to sign SAML Assertion.
            Encoded as separate P, Q, G, Y, J, Seed and PgenCounter elements.
          </xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="RetrievalMethod">
        <xs:annotation>
          <xs:documentation>Reference to KeyInfo data that is stored at another location</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      -->
    </xs:restriction>
  </xs:simpleType>
  <xs:complexType name="TokenFromWorkflowType">
    <xs:annotation>
      <xs:documentation>
        Allows an application to supply a security token (based64 string) from a BEPL variable as an input parameter
        when policy is bound to a AAA action.
      </xs:documentation>
    </xs:annotation>
    <xs:choice>
      <xs:element name="inputFromWorkflow" type="xs:string">
        <xs:annotation>
          <xs:documentation>
            This value uniquely identify this user supplied data instance.
            
            This value is used to identify to the developer what information needs to be resolved.
            This value is also used as the name string in the name/value pair on the extension function optional parameter.
          </xs:documentation>
        </xs:annotation>
      </xs:element>
    </xs:choice>
    <xs:attribute name="type" use="required" fixed="string">
      <xs:annotation>
        <xs:appinfo>Not to be displayed. Must be populated by policy editor.</xs:appinfo>
      </xs:annotation>
    </xs:attribute>
  </xs:complexType>
  <xs:complexType name="SecurityObjectNameFromWorkflowType">
    <xs:annotation>
      <xs:documentation>
        Allows an application to specify a BEPL variable  containing a security object name as an 
        input parameter associated with the WS-Security action.
      </xs:documentation>
    </xs:annotation>
    <xs:choice>
      <xs:element name="inputFromWorkflow" type="xs:string">
        <xs:annotation>
          <xs:documentation>
            This value uniquely identify this user supplied data instance.
            
            This value is used to identify to the developer what information needs to be resolved.
            This value is also used as the name string in the name/value pair on the extension function optional parameter.
          </xs:documentation>
        </xs:annotation>
      </xs:element>
    </xs:choice>
    <xs:attribute name="type" use="required" fixed="string">
      <xs:annotation>
        <xs:appinfo>Not to be displayed. Must be populated by policy editor.</xs:appinfo>
      </xs:annotation>
      <xs:simpleType>
        <xs:restriction base="xs:string"/>
      </xs:simpleType>
    </xs:attribute>
    <!-- constraint: the token type must agree with the type of security object in the security config.
                     a) if (token type == X.509) then security object name must be for an Certificate security object.
                     b) if (tokentype == symmetric) then security object name must be for a SharedSecret security object whose 
                        (typeOfSharedSecret == symmetric-key).
    -->
  </xs:complexType>
  <xs:complexType name="AttributesFromWorkflowType">
    <xs:annotation>
      <xs:documentation>
        Allows an application to supply one or more Attribute elements from a BEPL variable as an input parameter
        when policy is bound to a AAA action.
        It is the application responsibility that a well-formed, valid set of one or more SAML Attribute elements have been defined.
      </xs:documentation>
    </xs:annotation>
    <xs:choice>
      <xs:element name="inputFromWorkflow" type="xs:string" default="prebuild-Attribute-elements">
        <xs:annotation>
          <xs:documentation>
            This value uniquely identify this user supplied data instance.
            
            This value is used to identify to the developer what information needs to be resolved.
            This value is also used as the name string in the name/value pair on the extension function optional parameter.
          </xs:documentation>
        </xs:annotation>
      </xs:element>
    </xs:choice>
    <xs:attribute name="type" use="required" fixed="string">
      <xs:annotation>
        <xs:appinfo>Not to be displayed. Must be populated by policy editor.</xs:appinfo>
      </xs:annotation>
    </xs:attribute>
  </xs:complexType>
  <xs:simpleType name="SignatureGenerationMethod">
    <xs:annotation>
      <xs:documentation>
        What signature methods will we use when generating an enveloped X.509-based signature for the SAML assertion.
        Note: only legal algorithm is rsa-sha1. Stupid and dangerous in the long-term but this is the standard.
        We have added rsaWithSha256, 384 and 512 because of interworking with Microsoft ADFS.
        We have added rsaWithRipemd160 because of interworking with IBM.
      </xs:documentation>
    </xs:annotation>
    <xs:restriction base="xs:string">
      <xs:enumeration value="rsaWithSha1">
        <xs:annotation>
          <xs:documentation>Signature method using assymmetric RSA key with SHA1 digest.</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="rsaWithSha256">
        <xs:annotation>
          <xs:documentation>Signature method using assymmetric RSA key with SHA-256 digest.</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="rsaWithSha384">
        <xs:annotation>
          <xs:documentation>Signature method using assymmetric RSA key with SHA-384 digest.</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="rsaWithSha512">
        <xs:annotation>
          <xs:documentation>Signature method using assymmetric RSA key with SHA-512 digest.</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="rsaWithRipemd160">
        <xs:annotation>
          <xs:documentation>
            Signature method using assymmetric RSA key with RIPEMD-160 digest.
            Do not know anyone but IBM that is currently supporting this.
          </xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="dsaWithSha1">
        <xs:annotation>
          <xs:documentation>Signature method using assymmetric DSA key with SHA1 digest.</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
    </xs:restriction>
  </xs:simpleType>
  <xs:complexType name="SignatureAcceptMethod">
    <xs:annotation>
      <xs:documentation>
        SAML assertion processing only officially is defined to accept RSA with SHA1. With the advances attacking
        SHA1 digest method this reliance on RSA with SHA1 is questionable. 
        Some vendors like Microsoft ADFS are now supporting stronger signature methods.
      </xs:documentation>
    </xs:annotation>
    <xs:all>
      <xs:element name="rsaWithSha1" type="aaa:EmptyType" minOccurs="0">
        <xs:annotation>
          <xs:documentation>Signature method using assymmetric RSA key with SHA1 digest.</xs:documentation>
        </xs:annotation>
      </xs:element>
      <xs:element name="rsaWithSha256" type="aaa:EmptyType" minOccurs="0">
        <xs:annotation>
          <xs:documentation>Signature method using assymmetric RSA key with SHA-256 digest.</xs:documentation>
        </xs:annotation>
      </xs:element>
      <xs:element name="rsaWithSha384" type="aaa:EmptyType" minOccurs="0">
        <xs:annotation>
          <xs:documentation>Signature method using assymmetric RSA key with SHA-384 digest.</xs:documentation>
        </xs:annotation>
      </xs:element>
      <xs:element name="rsaWithSha512" type="aaa:EmptyType" minOccurs="0">
        <xs:annotation>
          <xs:documentation>Signature method using assymmetric RSA key with SHA-512 digest.</xs:documentation>
        </xs:annotation>
      </xs:element>
      <xs:element name="rsaWithRipemd160" type="aaa:EmptyType" minOccurs="0">
        <xs:annotation>
          <xs:documentation>Signature method using assymmetric RSA key with RIPEMD-160 digest.</xs:documentation>
        </xs:annotation>
      </xs:element>
    </xs:all>
  </xs:complexType>
  <xs:simpleType name="DigestGenerationMethod">
    <xs:restriction base="xs:string">
      <xs:enumeration value="sha1">
        <xs:annotation>
          <xs:documentation>SHA1 (160 bit) digest method. Recommended method</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="sha224">
        <xs:annotation>
          <xs:documentation>
            SHA-224 bit digest method. Stronger but slower method.
            Basically SHA-256 but with different initial value and truncated SHA-256 result.
          </xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="sha256">
        <xs:annotation>
          <xs:documentation>SHA-256 bit digest method. Stronger but slower method</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="sha384">
        <xs:annotation>
          <xs:documentation>
            SHA-384 bit digest method. Very strong but slow method.
            Basically SHA-512 but with different initial value and truncated SHA-512 result.
          </xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="sha512">
        <xs:annotation>
          <xs:documentation>SHA-512 bit digest method. Strongest but slowest method</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="md5">
        <xs:annotation>
          <xs:documentation>MD5 hash method. Popular, but no longer recommended!</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="ripemd160">
        <xs:annotation>
          <xs:documentation>RIPEMD-160 hash method. Equivalent to SHA-1.</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
    </xs:restriction>
  </xs:simpleType>
  <xs:complexType name="DigestAcceptMethods">
    <xs:all>
      <xs:element name="sha1" type="aaa:EmptyType" minOccurs="0">
        <xs:annotation>
          <xs:documentation>SHA1 (160 bit) digest method. Recommended method</xs:documentation>
        </xs:annotation>
      </xs:element>
      <xs:element name="sha224" type="aaa:EmptyType" minOccurs="0">
        <xs:annotation>
          <xs:documentation>
            SHA-224 bit digest method. Stronger but slow method.
            Basically SHA-256 but with different initial vector and truncated SHA-256 result.
          </xs:documentation>
        </xs:annotation>
      </xs:element>
      <xs:element name="sha256" type="aaa:EmptyType" minOccurs="0">
        <xs:annotation>
          <xs:documentation>SHA-256 bit digest method. Stronger but slow method</xs:documentation>
        </xs:annotation>
      </xs:element>
      <xs:element name="sha384" type="aaa:EmptyType" minOccurs="0">
        <xs:annotation>
          <xs:documentation>
            SHA-384 bit digest method. Very strong but slow method.
            Basically SHA-512 but with different initial vector and truncated SHA-512 result.
          </xs:documentation>
        </xs:annotation>
      </xs:element>
      <xs:element name="sha512" type="aaa:EmptyType" minOccurs="0">
        <xs:annotation>
          <xs:documentation>SHA-512 bit digest method. Strongest but slowest method</xs:documentation>
        </xs:annotation>
      </xs:element>
      <xs:element name="md5" type="aaa:EmptyType" minOccurs="0">
        <xs:annotation>
          <xs:documentation>MD5 hash method. Popular, but no longer recommended</xs:documentation>
        </xs:annotation>
      </xs:element>
      <xs:element name="ripemd160" type="aaa:EmptyType" minOccurs="0">
        <xs:annotation>
          <xs:documentation>RIPEMD-160 hash method. Equivalent to SHA1.</xs:documentation>
        </xs:annotation>
      </xs:element>
    </xs:all>
  </xs:complexType>
  <xs:simpleType name="CanonicalGenerationMethod">
    <xs:annotation>
      <xs:documentation>Note: inclusive canonicalization not supported by SAML standard.</xs:documentation>
    </xs:annotation>
    <xs:restriction base="xs:string">
      <xs:enumeration value="C14N_exclusive">
        <xs:annotation>
          <xs:documentation>C14N Exclusive canonicalization method. Comments removed. Recommended method</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <!-- Will be added in future release. See Exclusive XML Canonicalization, Version 1.0, W3C Recommendation 18 July 2002.
        http://www.w3.org/TR/xml-exc-c14n/)
        <xs:enumeration value="C14N_exclusiveWithComments">
          <xs:annotation>
            <xs:documentation>C14N Exclusive canonicalization method. Comments retained. Not recommended.</xs:documentation>
          </xs:annotation>
        </xs:enumeration>
      -->
    </xs:restriction>
  </xs:simpleType>
  <xs:complexType name="CanonicalAcceptMethods">
    <xs:all>
      <!-- default on only recommended methods -->
      <xs:element name="C14N_exclusive" type="aaa:EmptyType" minOccurs="0">
        <xs:annotation>
          <xs:documentation>C14N Exclusive canonicalization method. Comments removed. Recommended method</xs:documentation>
        </xs:annotation>
      </xs:element>
      <!-- Will be added in future release. See Exclusive XML Canonicalization, Version 1.0, W3C Recommendation 18 
        July 2002. (http://www.w3.org/TR/xml-exc-c14n/)
        <xs:element name="C14N_exclusiveWithComments" minOccurs="0">
          <xs:annotation>
            <xs:documentation>C14N Exclusive canonicalization method. Comments retained. Not Recommended.</xs:documentation>
          </xs:annotation>
        </xs:element>
      -->
    </xs:all>
  </xs:complexType>
  <xs:complexType name="JsonReceiveSecurityToken">
    <xs:annotation>
      <xs:documentation>JSON Receive Tokens</xs:documentation>
    </xs:annotation>
    <xs:choice>
      <xs:element name="securityObjectNameFromIncomingToken" type="aaa:EmptyType">
        <xs:annotation>
          <xs:documentation>
            The symmetric key security object with the name matching the kid claim from the incoming JSON Web Signature (JWS)
            or JSON Web Encryption (JWE) will be utilized.
          </xs:documentation>
        </xs:annotation>
      </xs:element>
      <xs:element name="security-config-package" type="aaa:SecurityPackageHandle">
        <xs:annotation>
          <xs:documentation>Using security object defined in application related security config package</xs:documentation>
        </xs:annotation>
        <!-- constraint: name specified must match abstract handle defined in associated security package.
                         Also the type of the security object in the security package and wihtin the AAA policy must match
        -->
      </xs:element>
      <xs:element name="securityObjectNameFromWorkflow" type="aaa:SecurityObjectNameFromWorkflowType">
        <!-- constraint: Service Designer require to prompt developer for data from workflow when this AAA policy is bind to a specific action. -->
      </xs:element>
      <xs:element name="keyFromWorkflow" type="aaa:TokenFromWorkflowType">
        <!-- constraint: Service Designer require to prompt developer for data from workflow when this AAA policy is bind to a specific action. -->
        <!-- constraint: ONLY PRESENT if tokenType == symmetric-key -->
      </xs:element>
    </xs:choice>
  </xs:complexType>
  <xs:complexType name="SecurityToken">
    <xs:annotation>
      <xs:documentation>Binary Security Token (X.509)</xs:documentation>
    </xs:annotation>
    <xs:choice>
      <xs:element name="security-config-package" type="aaa:SecurityPackageHandle">
        <xs:annotation>
          <xs:documentation>Using security object defined in application related security config package</xs:documentation>
        </xs:annotation>
        <!-- constraint: name specified must match abstract handle defined in associated security package.
                         Also the type of the security object in the security package and wihtin the AAA policy must match
        -->
      </xs:element>
      <xs:element name="bstFromWorkflow" type="aaa:TokenFromWorkflowType">
        <!-- constraint: Service Designer require to prompt developer for data from workflow when this AAA policy is bind to a specific action. -->
        <!-- constraint: ONLY PRESENT if tokenType == X509 -->
      </xs:element>
      <xs:element name="keyFromWorkflow" type="aaa:TokenFromWorkflowType">
        <!-- constraint: Service Designer require to prompt developer for data from workflow when this AAA policy is bind to a specific action. -->
        <!-- constraint: ONLY PRESENT if tokenType == symmetric-key -->
      </xs:element>
      <xs:element name="securityObjectNameFromWorkflow" type="aaa:SecurityObjectNameFromWorkflowType">
        <!-- constraint: Service Designer require to prompt developer for data from workflow when this AAA policy is bind to a specific action. -->
      </xs:element>
      <!-- deferred
        <xs:element name="localSqlDatabase" type="aaa:LocalSqlDatabase"/>
      -->
    </xs:choice>
  </xs:complexType>
  <xs:complexType name="CreateKeyPairSecurityToken">
    <xs:annotation>
      <xs:documentation>
        PKI Public (X.509 certificate)/Private Key Pair
      </xs:documentation>
    </xs:annotation>
    <xs:sequence>
      <xs:choice>
        <xs:element name="security-config-package" type="aaa:SecurityPackageHandle">
          <xs:annotation>
            <xs:documentation>Using security object defined in application related security config package</xs:documentation>
          </xs:annotation>
          <!-- constraint: name specified must match abstract handle defined in associated security package.
                           Also the type of the security object in the security package and wihtin the AAA policy must match
          -->
        </xs:element>
        <!-- deferred
        <xs:element name="bstFromWorkflow" type="xs:string">
          <xs:annotation>
            <xs:documentation>
              This value uniquely identify this user supplied data instance.
              
              This value is used to identify to the developer what information needs to be resolved.
              This value is also used as the name string in the name/value pair on the extension function optional parameter.
            </xs:documentation>
            <xs:appinfo>
              Change back to constraint comments when if we decide to support this functionality in the future.
              constraint: Service Designer require to prompt developer for data from workflow when this AAA policy is bind to a specific action.
              constraint: must be in either [unbased 64] PEM format with unencrypted private key or base64 unencrypted PKCS12 bag.
            </xs:appinfo>
          </xs:annotation>
        </xs:element>
        <xs:element name="ldap" type="aaa:LdapSearchRequest"/>
        <xs:element name="localSqlDatabase" type="aaa:LocalSqlDatabase"/>
        -->
      </xs:choice>
    </xs:sequence>
  </xs:complexType>
  <xs:complexType name="CreateCaPathSecurityToken">
    <xs:annotation>
      <xs:documentation>
        Immediate [and root] Certificate Authority (CA) Certificates.
        Must be in either PEM format, base64 encoded PKCS12 format or single base64 encoded DER format certificate.
      </xs:documentation>
    </xs:annotation>
    <xs:sequence>
      <xs:choice>
        <xs:element name="security-config-package" type="aaa:SecurityPackageHandle">
          <xs:annotation>
            <xs:documentation>Using security object defined in application related security config package</xs:documentation>
          </xs:annotation>
          <!-- constraint: name specified must match abstract handle defined in associated security package.
                           Also the type of the security object in the security package and within the AAA policy must match
          -->
        </xs:element>
        <xs:element name="bstFromWorkflow" type="aaa:EmptyType">
          <!--  constraint: Service Designer require to prompt developer for data from workflow when this AAA policy is bind to a specific action. -->
        </xs:element>
        <!-- deferred
        <xs:element name="ldap" type="aaa:LdapSearchRequest"/>
        <xs:element name="localSqlDatabase" type="aaa:LocalSqlDatabase"/>
        -->
      </xs:choice>
    </xs:sequence>
  </xs:complexType>
  <xs:complexType name="VerifyCertSecurityToken">
    <xs:annotation>
      <xs:documentation>Input Certificate needed for SAML signature verification</xs:documentation>
    </xs:annotation>
    <xs:sequence>
      <xs:choice>
        <xs:element name="security-config-package" type="aaa:SecurityPackageHandle">
          <xs:annotation>
            <xs:documentation>Using security object defined in application related security config package</xs:documentation>
          </xs:annotation>
          <!-- constraint: name specified must match abstract handle defined in associated security package.
                           Also the type of the security object in the security package and within the AAA policy must match
          -->
        </xs:element>
        <xs:element name="keystore" type="aaa:GenerateKeystore">
          <xs:annotation>
            <xs:appinfo>
              1) keyname is treated like subjectname by keystore look-up code.
              2) On screen, 
                 a) embedded-SKI should show up as SKI
                 b) SKI should show up as generated-SKI
                 c) sha1-fingerprint shows up as SHA1-Thumbprint
            </xs:appinfo>
          </xs:annotation>
          <!-- constraint: ONLY the following choices are valid: subjectname, sha1-fingerprint, embedded-SKI, SKI, SKI-short,
                           issuer-serialnumber and keyname
          -->
        </xs:element>
        <xs:element name="inputFromWorkflow" type="xs:string" default="Certificate_to_use_for_verifying_SAML_assertion_signature">
          <xs:annotation>
            <xs:documentation>
              This value uniquely identify this user supplied data instance.
              This option should only be utilized if the SAML assertion does not contain the full certificate, but only a certificate attribute like SKI.
              
              This value is used to identify to the developer what information needs to be resolved.
              This value is also used as the name string in the name/value pair on the extension function optional parameter.
            </xs:documentation>
            <xs:appinfo>
              Currently, service designer action builder will need to pass the application supplied certificate to two extension functions that utilize
              different parametrization mechanisms:
                verifyDecryptInitialValidateSamlAssertion: does not utilized the name/value pair mechanism. It is explicitly passed as the last parameter.
                validate-saml-attribute-query: utilizes the name/value pair mechanism.
              
              Operational code could perform additional validation by explicitly checking that this certificate contains the certificate attribute in the SAML assertion.
              It is possible for two certificate to be created with the same public/private key pair values, but not have the same subject name, sha1-thumprint, etc.
            </xs:appinfo>
          </xs:annotation>
          <!-- constraint: 1) Service Designer AAA policy editor required to see that element is populated.
                           2) Service Designer action builder require to prompt developer for data from workflow when this AAA policy is bind to a specific action.
          -->
        </xs:element>
        <!-- deferred Can not support this functionality until we split SAML validation function into separate extract and complete functions
        <xs:element name="ldap" type="aaa:VerifyLdapSearchRequest"/>
        <xs:element name="localSqlDatabase" type="aaa:VerifyLocalSqlDatabase"/>
        -->
      </xs:choice>
    </xs:sequence>
  </xs:complexType>
  <xs:complexType name="VerifyCaPathSecurityToken">
    <xs:annotation>
      <xs:documentation>Input Certificate Path for Signature Chain-of-trust Verification (Authentication)</xs:documentation>
    </xs:annotation>
    <xs:sequence>
      <xs:choice>
        <xs:element name="security-config-package" type="aaa:SecurityPackageHandle">
          <xs:annotation>
            <xs:documentation>Using security object defined in application related security config package</xs:documentation>
          </xs:annotation>
          <!-- constraint: name specified must match abstract handle defined in associated security package.
                           Also the type of the security object in the security package and wihtin the AAA policy must match
          -->
        </xs:element>
        <xs:element name="fromWorkflow">
          <xs:annotation>
            <xs:documentation>
              Application will be supplying immediate Certificate Authorities (CA Path) from the workflow.
              This element identifies a list of untrusted Certificate Authorities.
              It can be specified in two possible formats (See "Web Services Security X.509 Certificate Token Profile 1.1 OASIS Standard
              Specification, 1 February 2006" for details.
              1) one or more PEM format Certificate Authorities certificates concatenated in the same physical file. The order of certificates is 
                 such that the subject of the first certificate is the issuer of the second certificate, etc. Additionally, the certificate path 
                 excludes the end-entity certficate. This format is implied by a BinarySecurityToken with its attribute 
                 ValueType"#X509PKIPathv1".
                 See ITU-T Rec.X.509 (2000)/Cor.1 (10/2001 E) for details.
              2) PKCS7 bag. This format is implied by a BinarySecurityToken with its attribute ValueType="#PKCS7".
            </xs:documentation>
            <xs:appinfo>
              Service Designer Action must prompt the application developer for where the CA Path certificates will come from when AAA policy is 
              bound to an action.
            </xs:appinfo>
          </xs:annotation>
          <!-- constraint: this element is ONLY supported at this time for checkX509CertifcateChainOfTrust and NOT VerifyDecryptInitialValidateSamlAssertion -->
          <xs:simpleType>
            <xs:restriction base="xs:string">
              <xs:enumeration value="PEM"/>
              <xs:enumeration value="PKCS7"/>
            </xs:restriction>
          </xs:simpleType>
        </xs:element>
      </xs:choice>
    </xs:sequence>
  </xs:complexType>
  <xs:complexType name="SymmetricSecurityToken">
    <xs:annotation>
      <xs:documentation/>
    </xs:annotation>
    <xs:sequence>
      <xs:choice>
        <xs:element name="securityConfig" type="aaa:SecurityPackageHandle">
          <xs:annotation>
            <xs:documentation>Using security object defined in application related security config package</xs:documentation>
          </xs:annotation>
          <!-- constraint: name specified must match abstract handle defined in associated security package.
                           Also the type of the security object in the security package and wihtin the AAA policy must match
          -->
        </xs:element>
        <xs:element name="secretFromWorkflow" type="aaa:TokenFromWorkflowType">
          <!--  constraint: Service Designer require to prompt developer for data from workflow when this AAA policy is bind to a specific action. -->
        </xs:element>
      </xs:choice>
    </xs:sequence>
  </xs:complexType>
  <xs:complexType name="MapUsernameSecurityToken">
    <xs:annotation>
      <xs:documentation/>
    </xs:annotation>
    <xs:sequence>
      <xs:choice>
        <xs:element name="useExtractedIdentity" type="aaa:EmptyType">
          <xs:annotation>
            <xs:documentation>Use the extracted username and password.</xs:documentation>
          </xs:annotation>
          <!-- constraint: 
              1) ALLOWED if identity extraction method is: usernameFromHttpBasicAuthentication,
                 usernameFromSecurityHeader, usernamePasswordFromWorkflow, or
              2) ALLOWED if identity extraction method is: derivedUsernameFromSecurityHeader and identity 
                 authentication is: keystore or LDAP
              3) NOT ALLOWED if identity extraction method is ssoFromCookie or ssoFromWorkflow
              4) NOT ALLOWED if ((extract identity is usernameFromSecurityHeader) AND (map identity keyformat
                 is passwordText))
                 Note: duplicating same token representation
              5) NOT ALLOWED if ((extract identity is derivedUsernameFromSecurityHeader) AND (map identity 
                 keyformat is passwordDigest))
                 Note: duplicating same token representation
              6) WARNING "Multiple username tokens with same username" if ((extract identity is derivedUsernameFromSecurityHeader) 
                 AND (map identity keyformat is passwordText) AND (remove extract identity is false))
              7) WARNING "Multiple username tokens with same username" if ((extract identity is usernameFromSecurityHeader) 
                 AND (map identity keyformat is passwordDigest) AND (remove extract identity is false))
          -->
        </xs:element>
        <xs:element name="securityConfig" type="aaa:SecurityPackageHandle">
          <xs:annotation>
            <xs:documentation>
              Using username security object defined in application related security config package.
              This allows application to hardcore the username token to be created.
            </xs:documentation>
          </xs:annotation>
        </xs:element>
        <xs:element name="usernamePasswordFromWorkflow" type="aaa:EmptyType">
          <!-- constraint: 1) if (keyFormat == (PasswordText OR PasswordDigest OR KeyDerivation)) then service designer action builder 
                              must prompt developer to identify:
                              a) username: from current workflow variables when this AAA policy is bound to a workflow action. 
                              b) password: from current workflow variables when this AAA policy is bound to a workflow action. 
                (Deferred) 2) if (keyFormat == none) then service designer action builder must prompt developer to only identify:
                              a) username: from current workflow variables when this AAA policy is bound to a workflow action.
          -->
          <!-- constraint: 
            1) NOT ALLOWED if identity extraction method is: usernameFromHttpBasicAuthentication,
                           usernameFromSecurityHeader, usernamePasswordFromWorkflow.
            2) NOT ALLOWED if (identity extraction method is derivedUsernameFromSecurityHeader)
               Note: derivedUsernameFromSecurityHeader require authenticate identity mechanism of keystore or LDAP
               to retrieve password to validate incoming digest value ==> redundant password resolution
               Note: Look into removing this constraint by having SD action builder retrieve username allowing
               application to change both username and password.
          -->
        </xs:element>
        <xs:element name="keystore" type="aaa:EmptyType">
          <xs:annotation>
            <xs:documentation>
              Use extracted identity as source data for keystore queries for username and password.
              If X.509 (BST) extracted identity and certificateAttribute to determine keystore source type.
              
              Note: could consider mapping the name from SAML assertion (email address)to keystore identity type.
            </xs:documentation>
          </xs:annotation>
          <!-- constraint: 
              1) NOT ALLOWED if identity extraction method is: usernameFromHttpBasicAuthentication,
                 usernameFromSecurityHeader, usernamePasswordFromWorkflow.
              2) NOT ALLOWED if identity extraction method is clientIpAddress.
              3) NOT ALLOWED if identity extraction method is ssoFromCookie or ssoFromWorkflow
              4) Present when (extract identity is nameFromSamlSubject, nameFromSamlAuthentication or nameFromSamlAttribute) AND (NameIdentifierFormat 
                 is urn:oasis:names:tc:SAML:1.1:nameid-format:X509SubjectName) AND (sub-extraction is disabled)
                 {Reason: have full X509 subject name for keystore query.}
              5) NOT ALLOWED if (identity extraction method is derivedUsernameFromSecurityHeader)
                 Note: derivedUsernameFromSecurityHeader require authenticate identity mechanism of keystore or LDAP
                 to retrieve password to validate incoming digest value ==> redundant password resolution
              6) NOT ALLOWED if (identity extraction method is principalNameFromKerberosToken)
                 Note: we sould be able to support this functionality when sub-extraction of primary component of prinicpal name enabled by
                 assuming that primary is the username. Deferring until future release because of testing and development time and staff restictions.
          -->
        </xs:element>
        <xs:element name="ldap" type="aaa:MapLdapSearchRequest">
          <xs:annotation>
            <xs:documentation>
              Use extracted identity as source data for LDAP search request to get the username and password.
            </xs:documentation>
            <xs:appinfo>
              A potential optimization is for Action Builder to combine this LDAP Authentication request with the LDAP authorization request 
              into a single LDAP request as a batch request.
            </xs:appinfo>
          </xs:annotation>
          <!-- constraint:  
              1) NOT ALLOWED if identity extraction method is: usernameFromHttpBasicAuthentication,
                 usernameFromSecurityHeader, usernamePasswordFromWorkflow.
              2) ONLY ALLOWED if extract identity mechanism is certificateFromPeerSsl, x509CertificateFromSecurityHeader, x509CertificateFromWorkflow, or 
                 bstFromVerifyOperation, and certifcate-attribute exraction is subject name
              3) NOT ALLOWED if identity extraction method is ssoFromCookie or ssoFromWorkflow
              4) NOT ALLOWED if (identity extraction method is derivedUsernameFromSecurityHeader)
                 Note: derivedUsernameFromSecurityHeader require authenticate identity mechanism of keystore or LDAP
              5) NOT ALLOWED if (identity extraction method is principalNameFromKerberosToken)
                 Note: we sould be able to support this functionality when sub-extraction of primary component of prinicpal name enabled by
                 assuming that primary is the username being sustituted between prefix and postfix strings. Deferring until future release because of 
                 testing and development time and staff restictions.
          -->
        </xs:element>
        <!-- deferred
        <xs:element name="localSqlDatabase" type="aaa:LocalSqlDatabase">
          <xs:annotation>
            <xs:documentation>
              Use extracted identity as source data for SQL query to get the username and password.
            </xs:documentation>
            <xs:appinfo>
              constraint:  
              1) NOT ALLOWED if identity extraction method is: usernameFromHttpBasicAuthentication,
                 usernameFromSecurityHeader, usernamePasswordFromWorkflow.
              2) NOT ALLOWED if identity extraction mechanism is derivedUsernameFromSecurityHeader and 
                 authenticateIdentity mechanism is keystore or LDAP. 
              3) NOT ALLOWED if identity extraction method is ssoFromCookie or ssoFromWorkflow
              4) NOT ALLOWED if (identity extraction method is derivedUsernameFromSecurityHeader)
                 Note: derivedUsernameFromSecurityHeader require authenticate identity mechanism of keystore or LDAP
            </xs:appinfo>
          </xs:annotation>
        </xs:element>
        -->
      </xs:choice>
    </xs:sequence>
  </xs:complexType>
  <xs:complexType name="GenerateKeystore">
    <xs:annotation>
      <xs:documentation>Retrieve information from the Keystore for populating security token.</xs:documentation>
    </xs:annotation>
    <xs:sequence>
      <xs:element name="sourceType" type="aaa:KeystoreSourceType" default="use-extracted-identity" minOccurs="0"/>
    </xs:sequence>
  </xs:complexType>
  <xs:simpleType name="WebServiceAuthenticationPolicy">
    <xs:annotation>
      <xs:documentation>Name of WebServiceAuthenticationPolicy in associated Security Config Package</xs:documentation>
    </xs:annotation>
    <xs:restriction base="xs:NMTOKEN">
      <xs:minLength value="1"/>
      <xs:maxLength value="160"/>
    </xs:restriction>
    <!-- constraint: name specified must match abstract handle of a WebServiceAuthetnicationPolicy defined in associated 
                     security config package.
    -->
  </xs:simpleType>
  <xs:simpleType name="SecurityPackageHandle">
    <xs:restriction base="xs:NMTOKEN">
      <xs:minLength value="1"/>
      <xs:maxLength value="160"/>
    </xs:restriction>
    <!-- constraint: name specified must match abstract handle defined in associated security package.
        Also the type of the security object in the security package and wihtin the AAA policy must match
    -->
  </xs:simpleType>
  <xs:simpleType name="KeystoreSourceType">
    <xs:restriction base="xs:string">
      <xs:enumeration value="use-extracted-identity"/>
      <xs:enumeration value="username"/>
      <xs:enumeration value="keyname"/>
      <xs:enumeration value="identity"/>
      <xs:enumeration value="certificate"/>
      <xs:enumeration value="embedded-SKI"/>
      <xs:enumeration value="SKI"/>
      <xs:enumeration value="SKI-short"/>
      <xs:enumeration value="issuer-serialnumber"/>
      <xs:enumeration value="sha1-fingerprint"/>
      <xs:enumeration value="md5-fingerprint"/>
      <xs:enumeration value="subjectname"/>
      <xs:enumeration value="keyvalue"/>
    </xs:restriction>
  </xs:simpleType>
  <xs:complexType name="LdapSearchRequest">
    <xs:annotation>
      <xs:documentation>
        Generate an LDAP search request to retrieve associated infomration required by operation given workflow supplied identity.
      </xs:documentation>
    </xs:annotation>
    <xs:sequence>
      <xs:element name="distinguishedNamePrefix" type="aaa:DistinguishedNameType">
        <xs:annotation>
          <xs:documentation>This string will be used to prefix the extracted identity being substituted in the search expression</xs:documentation>
        </xs:annotation>
      </xs:element>
      <xs:element name="distinguishedNamePostfix" type="aaa:DistinguishedNameType">
        <xs:annotation>
          <xs:documentation>This string will be used to postfix the extracted identity being substituted in the search expression.</xs:documentation>
        </xs:annotation>
      </xs:element>
      <xs:element name="resultAttrName" type="aaa:ResultAttrType">
        <xs:annotation>
          <xs:documentation>
            The name of the searchResponse - searchResultEntry - attr element containing the desired retrieve value, e.g., password, certificate.
          </xs:documentation>
        </xs:annotation>
      </xs:element>
      <xs:element name="serverUrl" type="xs:anyURI" minOccurs="0">
        <xs:annotation>
          <xs:documentation>
            Allows AAA Policy writer to bind LDAP IA to a specific backend server.
            This is very useful when automatically using the same AAA policy in multiple places so that they are all bound to same LDAP server.
          </xs:documentation>
          <!-- This element will be mapped to two advanced fields: server host name and port in service designer. Default port = 389 (636 for SSL/TLS future) -->
        </xs:annotation>
      </xs:element>
    </xs:sequence>
    <!-- constraint: When this policy is being bound to an action, Service Designer will need to ask the developer for the following information:
                    1) LDAP server address
                    2) LDAP server port number. Can be defaulted to 389. 636for when LDAP over SSL/TLS.
                    3) LDAP administator Distinguished Name. This can be default to the LDAP acf config file associated with gnerated parntnerLink.
                    4) LDAP administrator Password. This can be default to the LDAP acf config file associated with gnerated parntnerLink.
    -->
    <!-- constraint: service designer must prompt developer to identify:
                     1) Value used to build distinguished name used in LDAP search request. Inserted between prefix and postfix strings 
                        from current workflow variable when this WS-Security policy is bound to a workflow action. 
    -->
    <!-- Associated action builder is required to bind these identified variables to the extension functions requirng them as input. -->
  </xs:complexType>
  <xs:complexType name="MapLdapSearchRequest">
    <xs:annotation>
      <xs:documentation>
        Generate an LDAP search request to retrieve associated infomration required by operation given workflow supplied identity.
      </xs:documentation>
    </xs:annotation>
    <xs:complexContent>
      <xs:extension base="aaa:LdapSearchRequest">
        <xs:sequence>
          <xs:element name="resultUsernameAttrName" type="aaa:ResultAttrType" minOccurs="0">
            <xs:annotation>
              <xs:documentation>
                The name of the searchResponse - searchResultEntry - attr element containing the username retrieve value matching the retrieved password.
              </xs:documentation>
              <!-- constraint: must be populated when ExtractIdentitiy mechanism is NOT usernameFromHttpBasicAuthentication, usernameFromSecurityHeader, 
                               usernameFromWorkflow and derviedUsernameFromSecurityHeader. 
              -->
            </xs:annotation>
          </xs:element>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:complexType name="VerifyLdapSearchRequest">
    <xs:annotation>
      <xs:documentation>
        Generate an LDAP search request to retrieve associated infomration required by operation given workflow supplied identity.
      </xs:documentation>
    </xs:annotation>
    <xs:complexContent>
      <xs:extension base="aaa:LdapSearchRequest">
        <xs:sequence>
          <xs:element name="expectedKeyInfoType" type="aaa:KeystoreSourceType"/>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:complexType name="LocalSqlDatabase"/>
  <xs:simpleType name="ResultAttrType">
    <xs:restriction base="xs:string">
      <xs:minLength value="1"/>
      <xs:pattern value="[a-zA-Z0-9_]*"/>
    </xs:restriction>
  </xs:simpleType>
  <xs:simpleType name="DistinguishedNameType">
    <xs:annotation>
      <xs:documentation>"@" only allowed because it allows a Kerberos principal name to be defined.</xs:documentation>
    </xs:annotation>
    <xs:restriction base="xs:string">
      <xs:pattern value="[\c ,;=@#\\\+]*"/>
    </xs:restriction>
  </xs:simpleType>
  <xs:simpleType name="ActorType">
    <xs:annotation>
      <xs:documentation>
        SOAP actor global attribute can be used to indicate the recipient of a header element.
        
        It is used to address the question: How does an intermediary know which WS-Security header it owns? 
        A SOAP message may contain multiple WS-Security headers. Each header is identified by a unique actor. No two 
        WS-Security headers can use the same actor or omit the actor. This makes it easy for intermediaries to 
        identify which WS-Security headers contain the information they need. Of course, the intermediary does need to 
        know which actor URI it handles. Associating a URI with an actor and making sure that the intermediary knows what 
        to do is something that must be handled via programming. The actor attribute in any SOAP header is meant to say 
        "this header is meant for any endpoint acting in the capacity indicated by the actor URI." What gives that URI meaning? 
        The team that architects the Web service gives meaning to the URI. This means that an intermediary may act in varying
        capacities. As a result, that intermediary may consume zero, one, or more headers. Yes, it may even consume 
        multiple security headers. 
      </xs:documentation>
      <xs:appinfo>
        If not present that processing will defer to default WS-Security header within SOAP Header for associated operation
        and tokens.
      </xs:appinfo>
    </xs:annotation>
    <xs:restriction base="xs:anyURI">
      <xs:minLength value="1"/>
    </xs:restriction>
  </xs:simpleType>
  <xs:simpleType name="Handle">
    <xs:annotation>
      <xs:documentation>Administrator defined name used to reference configuration entity</xs:documentation>
    </xs:annotation>
    <xs:restriction base="xs:NMTOKEN">
      <xs:minLength value="1"/>
      <xs:maxLength value="64"/>
      <xs:pattern value="[-a-zA-Z0-9_\.]*"/>
      <!-- dash A-Z a-z 0-9 underscore period -->
    </xs:restriction>
  </xs:simpleType>
  <xs:simpleType name="WsuIdPrefix">
    <xs:annotation>
      <xs:documentation>
        Prefix to be added to security token wsu:Id
        Makes it simplier for application code to locate desired security token.
      </xs:documentation>
    </xs:annotation>
    <xs:restriction base="xs:NMTOKEN">
      <xs:minLength value="1"/>
      <xs:maxLength value="64"/>
      <xs:pattern value="[-a-zA-Z0-9_\.]*"/>
      <!-- dash A-Z a-z 0-9 underscore period -->
    </xs:restriction>
  </xs:simpleType>
  <xs:simpleType name="XPathWithinSamlAssertion">
    <xs:restriction base="xs:string">
      <xs:minLength value="1"/>
    </xs:restriction>
  </xs:simpleType>
  <xs:complexType name="EmptyType"/>
</xs:schema>
